From 9866712deefeb7ac1349b65bea87250aa1e8674d Mon Sep 17 00:00:00 2001
From: Stephan Linz <linz@li-pro.net>
Date: Sun, 6 Nov 2011 00:30:39 +0100
Subject: [Xilinx] Applying Microblaze startup from Xilinx mb_gnu

Recreate from http://git.xilinx.com/?p=mb_gnu.git;a=history;f=src/gdb
  - 64795fdc54d2c0c8291491d88f1bb2a0e4c3af8e
  - 52abac44daae5dbe024bc115556df63b06fced59
  - f72559b3aa13acdbf3a5ff75edb7c7b74f112e34

Signed-off-by: Stephan Linz <linz@li-pro.net>

diff --git a/bfd/Makefile.am b/bfd/Makefile.am
index 44a4201..76325c9 100644
--- a/bfd/Makefile.am
+++ b/bfd/Makefile.am
@@ -91,6 +91,7 @@ ALL_MACHINES = \
 	cpu-m10300.lo \
 	cpu-maxq.lo \
 	cpu-mcore.lo \
+	cpu-microblaze.lo \
 	cpu-mips.lo \
 	cpu-mmix.lo \
 	cpu-mt.lo \
@@ -153,6 +154,7 @@ ALL_MACHINES_CFILES = \
 	cpu-m10300.c \
 	cpu-maxq.c \
 	cpu-mcore.c \
+	cpu-microblaze.c \
 	cpu-mips.c \
 	cpu-mmix.c \
 	cpu-mt.c \
@@ -262,6 +264,7 @@ BFD32_BACKENDS = \
 	elf-m10200.lo \
 	elf-m10300.lo \
 	elf32-mcore.lo \
+	elf32-microblaze.lo \
 	elfxx-mips.lo \
 	elf32-mips.lo \
 	elf32-mt.lo \
@@ -434,6 +437,7 @@ BFD32_BACKENDS_CFILES = \
 	elf-m10200.c \
 	elf-m10300.c \
 	elf32-mcore.c \
+	elf32-microblaze.c \
 	elfxx-mips.c \
 	elf32-mips.c \
 	elf32-mt.c \
@@ -1040,6 +1044,7 @@ cpu-m10200.lo: cpu-m10200.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-m10300.lo: cpu-m10300.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-maxq.lo: cpu-maxq.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-mcore.lo: cpu-mcore.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
+cpu-microblaze.lo: cpu-microblaze.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-mips.lo: cpu-mips.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-mmix.lo: cpu-mmix.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-mt.lo: cpu-mt.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
@@ -1379,6 +1384,10 @@ elf32-mcore.lo: elf32-mcore.c $(INCDIR)/filenames.h \
   $(INCDIR)/bfdlink.h $(INCDIR)/hashtab.h elf-bfd.h $(INCDIR)/elf/common.h \
   $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h $(INCDIR)/elf/mcore.h \
   $(INCDIR)/elf/reloc-macros.h elf32-target.h
+elf32-microblaze.lo: elf32-microblaze.c $(INCDIR)/filenames.h \
+  $(INCDIR)/bfdlink.h $(INCDIR)/hashtab.h elf-bfd.h $(INCDIR)/elf/common.h \
+  $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h $(INCDIR)/elf/microblaze.h \
+  $(INCDIR)/elf/reloc-macros.h elf32-target.h
 elfxx-mips.lo: elfxx-mips.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   $(INCDIR)/libiberty.h elf-bfd.h $(INCDIR)/elf/common.h \
   $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h \
diff --git a/bfd/Makefile.in b/bfd/Makefile.in
index 4e22167..bd67f9c 100644
--- a/bfd/Makefile.in
+++ b/bfd/Makefile.in
@@ -327,6 +327,7 @@ ALL_MACHINES = \
 	cpu-m10300.lo \
 	cpu-maxq.lo \
 	cpu-mcore.lo \
+	cpu-microblaze.lo \
 	cpu-mips.lo \
 	cpu-mmix.lo \
 	cpu-mt.lo \
@@ -389,6 +390,7 @@ ALL_MACHINES_CFILES = \
 	cpu-m10300.c \
 	cpu-maxq.c \
 	cpu-mcore.c \
+	cpu-microblaze.c \
 	cpu-mips.c \
 	cpu-mmix.c \
 	cpu-mt.c \
@@ -499,6 +501,7 @@ BFD32_BACKENDS = \
 	elf-m10200.lo \
 	elf-m10300.lo \
 	elf32-mcore.lo \
+	elf32-microblaze.lo \
 	elfxx-mips.lo \
 	elf32-mips.lo \
 	elf32-mt.lo \
@@ -671,6 +674,7 @@ BFD32_BACKENDS_CFILES = \
 	elf-m10200.c \
 	elf-m10300.c \
 	elf32-mcore.c \
+	elf32-microblaze.c \
 	elfxx-mips.c \
 	elf32-mips.c \
 	elf32-mt.c \
@@ -1606,6 +1610,7 @@ cpu-m10200.lo: cpu-m10200.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-m10300.lo: cpu-m10300.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-maxq.lo: cpu-maxq.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-mcore.lo: cpu-mcore.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
+cpu-microblaze.lo: cpu-microblaze.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-mips.lo: cpu-mips.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-mmix.lo: cpu-mmix.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
 cpu-mt.lo: cpu-mt.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h
@@ -1945,6 +1950,10 @@ elf32-mcore.lo: elf32-mcore.c $(INCDIR)/filenames.h \
   $(INCDIR)/bfdlink.h $(INCDIR)/hashtab.h elf-bfd.h $(INCDIR)/elf/common.h \
   $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h $(INCDIR)/elf/mcore.h \
   $(INCDIR)/elf/reloc-macros.h elf32-target.h
+elf32-microblaze.lo: elf32-microblaze.c $(INCDIR)/filenames.h \
+  $(INCDIR)/bfdlink.h $(INCDIR)/hashtab.h elf-bfd.h $(INCDIR)/elf/common.h \
+  $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h $(INCDIR)/elf/microblaze.h \
+  $(INCDIR)/elf/reloc-macros.h elf32-target.h
 elfxx-mips.lo: elfxx-mips.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   $(INCDIR)/libiberty.h elf-bfd.h $(INCDIR)/elf/common.h \
   $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h \
diff --git a/bfd/archures.c b/bfd/archures.c
index f4080a6..39424de 100644
--- a/bfd/archures.c
+++ b/bfd/archures.c
@@ -381,6 +381,7 @@ DESCRIPTION
 .#define bfd_mach_z80            3 {* With ixl, ixh, iyl, and iyh.  *}
 .#define bfd_mach_z80full        7 {* All undocumented instructions.  *}
 .#define bfd_mach_r800           11 {* R800: successor with multiplication.  *}
+   bfd_arch_microblaze,
 .  bfd_arch_last
 .  };
 */
@@ -450,6 +451,7 @@ extern const bfd_arch_info_type bfd_m68k_arch;
 extern const bfd_arch_info_type bfd_m88k_arch;
 extern const bfd_arch_info_type bfd_maxq_arch;
 extern const bfd_arch_info_type bfd_mcore_arch;
+extern const bfd_arch_info_type bfd_microblaze_arch;
 extern const bfd_arch_info_type bfd_mips_arch;
 extern const bfd_arch_info_type bfd_mmix_arch;
 extern const bfd_arch_info_type bfd_mn10200_arch;
@@ -517,6 +519,7 @@ static const bfd_arch_info_type * const bfd_archures_list[] =
     &bfd_m88k_arch,
     &bfd_maxq_arch,
     &bfd_mcore_arch,
+    &bfd_microblaze_arch,
     &bfd_mips_arch,
     &bfd_mmix_arch,
     &bfd_mn10200_arch,
diff --git a/bfd/bfd-in2.h b/bfd/bfd-in2.h
index 5ba74d2..30d9fdf 100644
--- a/bfd/bfd-in2.h
+++ b/bfd/bfd-in2.h
@@ -1972,6 +1972,7 @@ enum bfd_architecture
 #define bfd_mach_z80            3 /* With ixl, ixh, iyl, and iyh.  */
 #define bfd_mach_z80full        7 /* All undocumented instructions.  */
 #define bfd_mach_r800           11 /* R800: successor with multiplication.  */
+  bfd_arch_microblaze,
   bfd_arch_last
   };
 
@@ -4157,6 +4158,23 @@ BFD_RELOC_XTENSA_ASM_EXPAND.  */
 
 /* 4 bit value.  */
   BFD_RELOC_Z8K_IMM4L,
+
+/* This is a 32 bit reloc for the microblaze that stores low 16 bits of a 
+   value */
+  BFD_RELOC_MICROBLAZE_32_LO,
+
+/* This is a 32 bit pc-relative reloc for the microblaze that stores low 16 
+   bits of a value */
+  BFD_RELOC_MICROBLAZE_32_LO_PCREL,
+
+/* This is a 32 bit reloc for the microblaze that stores a value relative to
+   the read-only small data area anchor */
+  BFD_RELOC_MICROBLAZE_32_ROSDA,
+
+/* This is a 32 bit reloc for the microblaze that stores a value relative to
+   the read-write small data area anchor */
+  BFD_RELOC_MICROBLAZE_32_RWSDA,
+
   BFD_RELOC_UNUSED };
 typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;
 reloc_howto_type *bfd_reloc_type_lookup
diff --git a/bfd/config.bfd b/bfd/config.bfd
index 4fd72c1..4a3e5e6 100644
--- a/bfd/config.bfd
+++ b/bfd/config.bfd
@@ -86,6 +86,7 @@ m6812*|m68hc12*) targ_archs="bfd_m68hc12_arch bfd_m68hc11_arch" ;;
 m68*)		 targ_archs=bfd_m68k_arch ;;
 m88*)		 targ_archs=bfd_m88k_arch ;;
 maxq*)		 targ_archs=bfd_maxq_arch ;;
+microblaze*)	 targ_archs=bfd_microblaze_arch ;;
 mips*)		 targ_archs=bfd_mips_arch ;;
 or32*)		 targ_archs=bfd_or32_arch ;;
 pdp11*)		 targ_archs=bfd_pdp11_arch ;;
@@ -823,6 +824,10 @@ case "${targ}" in
     targ_selvecs="mcore_pe_big_vec mcore_pe_little_vec mcore_pei_big_vec mcore_pei_little_vec"
     ;;
 
+  microblaze-*-*)
+    targ_defvec=bfd_elf32_microblaze_vec
+    ;;
+
   mips*-big-*)
     targ_defvec=ecoff_big_vec
     targ_selvecs=ecoff_little_vec
diff --git a/bfd/configure b/bfd/configure
index ffe2556..fd0fc66 100755
--- a/bfd/configure
+++ b/bfd/configure
@@ -13127,6 +13127,7 @@ do
     bfd_elf32_m88k_vec)		tb="$tb elf32-m88k.lo elf32.lo $elf" ;;
     bfd_elf32_mcore_big_vec)	tb="$tb elf32-mcore.lo elf32.lo $elf" ;;
     bfd_elf32_mcore_little_vec)	tb="$tb elf32-mcore.lo elf32.lo $elf" ;;
+    bfd_elf32_microblaze_vec)	tb="$tb elf32-microblaze.lo elf32.lo $elf" ;;
     bfd_elf32_mn10200_vec)	tb="$tb elf-m10200.lo elf32.lo $elf" ;;
     bfd_elf32_mn10300_vec)	tb="$tb elf-m10300.lo elf32.lo $elf" ;;
     bfd_elf32_mt_vec)           tb="$tb elf32-mt.lo elf32.lo $elf" ;;
diff --git a/bfd/configure.in b/bfd/configure.in
index 1f0d2ca..c165a51 100644
--- a/bfd/configure.in
+++ b/bfd/configure.in
@@ -640,6 +640,7 @@ do
     bfd_elf32_m88k_vec)		tb="$tb elf32-m88k.lo elf32.lo $elf" ;;
     bfd_elf32_mcore_big_vec)	tb="$tb elf32-mcore.lo elf32.lo $elf" ;;
     bfd_elf32_mcore_little_vec)	tb="$tb elf32-mcore.lo elf32.lo $elf" ;;
+    bfd_elf32_microblaze_vec)	tb="$tb elf32-microblaze.lo elf32.lo $elf" ;;
     bfd_elf32_mn10200_vec)	tb="$tb elf-m10200.lo elf32.lo $elf" ;;
     bfd_elf32_mn10300_vec)	tb="$tb elf-m10300.lo elf32.lo $elf" ;;
     bfd_elf32_mt_vec)           tb="$tb elf32-mt.lo elf32.lo $elf" ;;
diff --git a/bfd/cpu-microblaze.c b/bfd/cpu-microblaze.c
new file mode 100644
index 0000000..39ae2d0
--- /dev/null
+++ b/bfd/cpu-microblaze.c
@@ -0,0 +1,57 @@
+/* BFD library support routines for Xilinx's microblaze architecture
+   Copyright (C) 1993, 1999 Free Software Foundation, Inc.
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/*
+ * Copyright (c) 2001 Xilinx, Inc.  All rights reserved. 
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by Xilinx, Inc.  The name of the Company may not be used to endorse 
+ * or promote products derived from this software without specific prior 
+ * written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ *	Xilinx, Inc.
+ */
+
+
+#include "bfd.h"
+#include "sysdep.h"
+#include "libbfd.h"
+
+const bfd_arch_info_type bfd_microblaze_arch =
+{
+  32,		  		/* 32 bits in a word */
+  32,		  		/* 32 bits in an address */
+  8,		  		/* 8 bits in a byte */
+  bfd_arch_microblaze, 		/* Architecture */
+  0,		  		/* Machine number - 0 for now */
+  "microblaze",	  		/* Architecture name */
+  "MicroBlaze",	  		/* Printable name */
+  3,		  		/* Section align power */
+  TRUE,		  		/* Is this the default architecture ? */
+  bfd_default_compatible,	/* Architecture comparison function */
+  bfd_default_scan,	   	/* String to architecture conversion */
+  NULL			   	/* Next in list */
+};
diff --git a/bfd/elf32-microblaze.c b/bfd/elf32-microblaze.c
new file mode 100644
index 0000000..1a324e5
--- /dev/null
+++ b/bfd/elf32-microblaze.c
@@ -0,0 +1,1184 @@
+/* Xilinx MicroBlaze specific support for 32-bit ELF
+   Copyright 1994, 1995, 1999 Free Software Foundation, Inc.
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/* This file is based on a preliminary RCE ELF ABI.  The
+   information may not match the final RCE ELF ABI.   */
+
+/*
+ * Copyright (c) 2001 Xilinx, Inc.  All rights reserved. 
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by Xilinx, Inc.  The name of the Company may not be used to endorse 
+ * or promote products derived from this software without specific prior 
+ * written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ *	Xilinx, Inc.
+ */
+
+
+#include "bfd.h"
+#include "sysdep.h"
+#include "bfdlink.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+#include "elf/microblaze.h"
+#include <assert.h>
+
+#define	USE_RELA	/* Only USE_REL is actually significant, but this is
+			   here are a reminder... */
+#define INST_WORD_SIZE 4
+
+static void microblaze_elf_howto_init
+  PARAMS ((void));
+static reloc_howto_type * microblaze_elf_reloc_type_lookup
+  PARAMS ((bfd *, bfd_reloc_code_real_type));
+static bfd_boolean microblaze_elf_relocate_section
+  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
+	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
+static bfd_boolean microblaze_elf_is_local_label_name
+  PARAMS ((bfd *, const char *));
+static void microblaze_elf_final_sdp 
+  PARAMS (( struct bfd_link_info * ));
+
+static int ro_small_data_pointer = 0;
+static int rw_small_data_pointer = 0;
+
+
+static reloc_howto_type * microblaze_elf_howto_table [(int) R_MICROBLAZE_max];
+
+static reloc_howto_type microblaze_elf_howto_raw[] =
+{
+  /* This reloc does nothing.  */
+  HOWTO (R_MICROBLAZE_NONE,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield,  /* complain_on_overflow */
+	 NULL,                  /* special_function */
+	 "R_MICROBLAZE_NONE", 	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A standard 32 bit relocation.  */
+  HOWTO (R_MICROBLAZE_32,     	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MICROBLAZE_32",   	/* name *//* For compatability with coff/pe port.  */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE), 		/* pcrel_offset */
+
+  /* A standard PCREL 32 bit relocation.  */
+  HOWTO (R_MICROBLAZE_32_PCREL,     	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MICROBLAZE_32_PCREL",   	/* name *//* For compatability with coff/pe port.  */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 TRUE), 		/* pcrel_offset */
+
+  /* A 64 bit PCREL relocation.  Table-entry not really used */
+  HOWTO (R_MICROBLAZE_64_PCREL,   	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MICROBLAZE_64_PCREL", 	/* name *//* For compatability with coff/pe port.  */
+	 FALSE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 TRUE), 		/* pcrel_offset */
+
+  /* The low half of a PCREL 32 bit relocation.  */
+  HOWTO (R_MICROBLAZE_32_PCREL_LO,   	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MICROBLAZE_32_PCREL_LO", 	/* name *//* For compatability with coff/pe port.  */
+	 FALSE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 TRUE), 		/* pcrel_offset */
+
+  /* A 64 bit relocation.  Table entry not really used */
+  HOWTO (R_MICROBLAZE_64,     	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MICROBLAZE_64",   	/* name *//* For compatability with coff/pe port.  */
+	 FALSE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE), 		/* pcrel_offset */
+
+  /* The low half of a 32 bit relocation.  */
+  HOWTO (R_MICROBLAZE_32_LO,   	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MICROBLAZE_32_LO", 	/* name *//* For compatability with coff/pe port.  */
+	 FALSE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE), 		/* pcrel_offset */
+
+  /* Read-only small data section relocation */
+  HOWTO (R_MICROBLAZE_SRO32,     	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MICROBLAZE_SRO32",   	/* name *//* For compatability with coff/pe port.  */
+	 FALSE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE), 		/* pcrel_offset */
+
+  /* Read-write small data area relocation */
+  HOWTO (R_MICROBLAZE_SRW32,     	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MICROBLAZE_SRW32",   	/* name *//* For compatability with coff/pe port.  */
+	 FALSE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE) 		/* pcrel_offset */
+};
+
+#ifndef NUM_ELEM
+#define NUM_ELEM(a) (sizeof (a) / sizeof (a)[0])
+#endif
+
+/* Initialize the microblaze_elf_howto_table, so that linear accesses can be done.  */
+static void
+microblaze_elf_howto_init ()
+{
+  unsigned int i;
+
+  for (i = NUM_ELEM (microblaze_elf_howto_raw); i--;)
+    {
+      unsigned int type;
+      
+      type = microblaze_elf_howto_raw[i].type;
+      
+      BFD_ASSERT (type < NUM_ELEM (microblaze_elf_howto_table));
+      
+      microblaze_elf_howto_table [type] = & microblaze_elf_howto_raw [i];
+    }
+}
+
+
+static reloc_howto_type *
+microblaze_elf_reloc_type_lookup (abfd, code)
+     bfd * abfd ATTRIBUTE_UNUSED;
+     bfd_reloc_code_real_type code;
+{
+  enum elf_microblaze_reloc_type microblaze_reloc = R_MICROBLAZE_NONE;
+
+  switch (code)
+    {
+    case BFD_RELOC_NONE:		    microblaze_reloc = R_MICROBLAZE_NONE; break;
+    case BFD_RELOC_32:                      microblaze_reloc = R_MICROBLAZE_32; break;
+      /* RVA is treated the same as 32 */
+    case BFD_RELOC_RVA:                     microblaze_reloc = R_MICROBLAZE_32; break;
+    case BFD_RELOC_32_PCREL:                microblaze_reloc = R_MICROBLAZE_32_PCREL; break;
+    case BFD_RELOC_64_PCREL:                microblaze_reloc = R_MICROBLAZE_64_PCREL; break;
+    case BFD_RELOC_MICROBLAZE_32_LO_PCREL:  microblaze_reloc = R_MICROBLAZE_32_PCREL_LO; break;
+    case BFD_RELOC_64:                      microblaze_reloc = R_MICROBLAZE_64; break;
+    case BFD_RELOC_MICROBLAZE_32_LO:        microblaze_reloc = R_MICROBLAZE_32_LO; break;
+    case BFD_RELOC_MICROBLAZE_32_ROSDA:     microblaze_reloc = R_MICROBLAZE_SRO32; break;
+    case BFD_RELOC_MICROBLAZE_32_RWSDA:     microblaze_reloc = R_MICROBLAZE_SRW32; break;
+    default:
+      return (reloc_howto_type *)NULL;
+    }
+
+  if (! microblaze_elf_howto_table [R_MICROBLAZE_32])	/* Initialize howto table if needed */
+    microblaze_elf_howto_init ();
+
+  return microblaze_elf_howto_table [(int) microblaze_reloc];
+};
+
+/* Set the howto pointer for a RCE ELF reloc.  */
+static void
+microblaze_elf_info_to_howto (
+     bfd * abfd ATTRIBUTE_UNUSED,
+     arelent * cache_ptr,
+     Elf_Internal_Rela * dst)
+{
+  if (! microblaze_elf_howto_table [R_MICROBLAZE_32])	/* Initialize howto table if needed */
+    microblaze_elf_howto_init ();
+
+  BFD_ASSERT (ELF32_R_TYPE (dst->r_info) < (unsigned int) R_MICROBLAZE_max);
+  
+  cache_ptr->howto = microblaze_elf_howto_table [ELF32_R_TYPE (dst->r_info)];
+}
+
+/* Microblaze ELF local labels start with 'L.' or '$L', not '.L'.  */
+
+/*ARGSUSED*/
+static bfd_boolean
+microblaze_elf_is_local_label_name (abfd, name)
+     bfd *abfd;
+     const char *name;
+{
+  if (name[0] == 'L' && name[1] == '.')
+    return TRUE;
+
+  if (name[0] == '$' && name[1] == 'L')
+    return TRUE;
+
+  /* With gcc, the labels go back to starting with '.', so we accept
+     the generic ELF local label syntax as well.  */
+  return _bfd_elf_is_local_label_name (abfd, name);
+}
+
+
+/* This code is taken from elf32-m32r.c
+   There is some attempt to make this function usable for many architectures,
+   both USE_REL and USE_RELA ['twould be nice if such a critter existed],
+   if only to serve as a learning tool.
+
+   The RELOCATE_SECTION function is called by the new ELF backend linker
+   to handle the relocations for a section.
+
+   The relocs are always passed as Rela structures; if the section
+   actually uses Rel structures, the r_addend field will always be
+   zero.
+
+   This function is responsible for adjust the section contents as
+   necessary, and (if using Rela relocs and generating a
+   relocatable output file) adjusting the reloc addend as
+   necessary.
+
+   This function does not have to worry about setting the reloc
+   address or the reloc symbol index.
+
+   LOCAL_SYMS is a pointer to the swapped in local symbols.
+
+   LOCAL_SECTIONS is an array giving the section in the input file
+   corresponding to the st_shndx field of each local symbol.
+
+   The global hash table entry for the global symbols can be found
+   via elf_sym_hashes (input_bfd).
+
+   When generating relocatable output, this function must handle
+   STB_LOCAL/STT_SECTION symbols specially.  The output symbol is
+   going to be the section symbol corresponding to the output
+   section, which means that the addend must be adjusted
+   accordingly.  */
+
+static bfd_boolean
+microblaze_elf_relocate_section (output_bfd, info, input_bfd, input_section,
+			   contents, relocs, local_syms, local_sections)
+     bfd *output_bfd ATTRIBUTE_UNUSED;
+     struct bfd_link_info *info;
+     bfd *input_bfd;
+     asection *input_section;
+     bfd_byte *contents;
+     Elf_Internal_Rela *relocs;
+     Elf_Internal_Sym *local_syms;
+     asection **local_sections;
+{
+  Elf_Internal_Shdr *symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (input_bfd);
+  Elf_Internal_Rela *rel, *relend;
+  /* Assume success.  */
+  bfd_boolean ret = TRUE;
+
+  if (!microblaze_elf_howto_table[R_MICROBLAZE_max-1])
+    microblaze_elf_howto_init();
+  rel = relocs;
+  relend = relocs + input_section->reloc_count;
+  for (; rel < relend; rel++)
+    {
+      int r_type;
+      reloc_howto_type *howto;
+      unsigned long r_symndx;
+      bfd_vma addend = rel->r_addend;
+      bfd_vma offset = rel->r_offset;
+      struct elf_link_hash_entry *h;
+      Elf_Internal_Sym *sym;
+      asection *sec;
+      const char *sym_name;
+      bfd_reloc_status_type r = bfd_reloc_ok;
+      const char *errmsg = NULL;
+
+      h = NULL;
+      r_type = ELF32_R_TYPE (rel->r_info);
+      if (r_type < 0 || r_type >= (int) R_MICROBLAZE_max)
+	{
+	  (*_bfd_error_handler) (_("%s: unknown relocation type %d"),
+				 bfd_get_filename (input_bfd),
+				 (int) r_type);
+	  bfd_set_error (bfd_error_bad_value);
+	  ret = FALSE;
+	  continue;
+	}
+
+      howto = microblaze_elf_howto_table[r_type];
+      r_symndx = ELF32_R_SYM (rel->r_info);
+
+      if (info->relocatable)
+	{
+	  /* This is a relocatable link.  We don't have to change
+	     anything, unless the reloc is against a section symbol,
+	     in which case we have to adjust according to where the
+	     section symbol winds up in the output section.  */
+	  sec = NULL;
+	  if (r_symndx >= symtab_hdr->sh_info)
+	    {
+	      /* External symbol.  */
+	      continue;
+	    }
+
+	  /* Local symbol.  */
+	  sym = local_syms + r_symndx;
+	  sym_name = "<local symbol>";
+	  /* STT_SECTION: symbol is associated with a section.  */
+	  if (ELF_ST_TYPE (sym->st_info) != STT_SECTION)
+	    {
+	      /* Symbol isn't associated with a section.  Nothing to do.  */
+	      continue;
+	    }
+
+	  sec = local_sections[r_symndx];
+	  addend += sec->output_offset + sym->st_value;
+#ifndef USE_REL
+	  /* This can't be done for USE_REL because it doesn't mean anything
+	     and elf_link_input_bfd asserts this stays zero.  */
+	  rel->r_addend = addend;
+#endif
+
+#ifndef USE_REL
+	  /* Addends are stored with relocs.  We're done.  */
+	  continue;
+#else /* USE_REL */
+	  /* If partial_inplace, we need to store any additional addend
+	     back in the section.  */
+	  if (! howto->partial_inplace)
+	    continue;
+	  /* ??? Here is a nice place to call a special_function
+	     like handler.  */
+	    r = _bfd_relocate_contents (howto, input_bfd,
+					addend, contents + offset);
+#endif /* USE_REL */
+	}
+      else
+	{
+	  bfd_vma relocation;
+
+	  /* This is a final link.  */
+	  sym = NULL;
+	  sec = NULL;
+
+	  if (r_symndx < symtab_hdr->sh_info)
+	    {
+	      /* Local symbol.  */
+	      sym = local_syms + r_symndx;
+	      sec = local_sections[r_symndx];
+	      sym_name = "<local symbol>";
+	      relocation = (sec->output_section->vma
+			    + sec->output_offset
+			    + sym->st_value);
+	    }
+	  else
+	    {
+	      /* External symbol.  */
+	      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
+	      while (h->root.type == bfd_link_hash_indirect
+		     || h->root.type == bfd_link_hash_warning)
+		h = (struct elf_link_hash_entry *) h->root.u.i.link;
+	      sym_name = h->root.root.string;
+
+	      if (h->root.type == bfd_link_hash_defined
+		  || h->root.type == bfd_link_hash_defweak)
+		{
+		  sec = h->root.u.def.section;
+		  if (sec->output_section == NULL)
+		    relocation = 0;
+		  else
+		    relocation = (h->root.u.def.value
+				  + sec->output_section->vma
+				  + sec->output_offset);
+		}
+	      else if (h->root.type == bfd_link_hash_undefweak)
+		relocation = 0;
+	      else
+		{
+		  if (! ((*info->callbacks->undefined_symbol)
+			 (info, h->root.root.string, input_bfd,
+			  input_section, offset, TRUE)))
+		    return FALSE;
+		  relocation = 0;
+		}
+	    }
+
+	  /* Sanity check the address.  */
+	  if (offset > input_section->rawsize)
+	    {
+	      r = bfd_reloc_outofrange;
+	      goto check_reloc;
+	    }
+
+	  switch ((int) r_type)
+	    {
+	    case (int) R_MICROBLAZE_SRO32 :
+	      {
+		const char *name;
+
+		BFD_ASSERT (sec != NULL);
+		name = bfd_get_section_name (abfd, sec);
+
+		if (strcmp (name, ".sdata2") == 0
+		    || strcmp (name, ".sbss2") == 0)
+		  {
+                    if (ro_small_data_pointer == 0)
+                       microblaze_elf_final_sdp (info);
+		    if (ro_small_data_pointer == 0)
+		      {
+			ret = FALSE;
+                        r = bfd_reloc_undefined;
+			goto check_reloc;
+		      }
+
+		    /* At this point `relocation' contains the object's
+		       address.  */
+		    relocation -= ro_small_data_pointer;
+		    /* Now it contains the offset from _SDA2_BASE_.  */
+                    r = _bfd_final_link_relocate (howto, input_bfd, input_section,
+					    contents, offset,
+					    relocation, addend);
+		  }
+		else
+		  {
+		    (*_bfd_error_handler) (_("%s: The target (%s) of an %s relocation is in the wrong section (%s)"),
+					   bfd_get_filename (input_bfd),
+					   sym_name,
+					   microblaze_elf_howto_table[(int) r_type]->name,
+					   bfd_get_section_name (abfd, sec));
+		    /*bfd_set_error (bfd_error_bad_value); ??? why? */
+		    ret = FALSE;
+		    continue;
+		  }
+	      }
+              break;
+
+	    case (int) R_MICROBLAZE_SRW32 :
+	      {
+		const char *name;
+
+		BFD_ASSERT (sec != NULL);
+		name = bfd_get_section_name (abfd, sec);
+
+		if (strcmp (name, ".sdata") == 0
+		    || strcmp (name, ".sbss") == 0)
+		  {
+                    if (rw_small_data_pointer == 0)
+                       microblaze_elf_final_sdp (info);
+		    if (rw_small_data_pointer == 0)
+		      {
+			ret = FALSE;
+                        r = bfd_reloc_undefined;
+			goto check_reloc;
+		      }
+
+		    /* At this point `relocation' contains the object's
+		       address.  */
+		    relocation -= rw_small_data_pointer;
+		    /* Now it contains the offset from _SDA_BASE_.  */
+                    r = _bfd_final_link_relocate (howto, input_bfd, input_section,
+					    contents, offset,
+					    relocation, addend);
+		  }
+		else
+		  {
+		    (*_bfd_error_handler) (_("%s: The target (%s) of an %s relocation is in the wrong section (%s)"),
+					   bfd_get_filename (input_bfd),
+					   sym_name,
+					   microblaze_elf_howto_table[(int) r_type]->name,
+					   bfd_get_section_name (abfd, sec));
+		    /*bfd_set_error (bfd_error_bad_value); ??? why? */
+		    ret = FALSE;
+		    continue;
+		  }
+	      }
+              break;
+
+	    case (int) R_MICROBLAZE_64_PCREL :
+		relocation -= (input_section->output_section->vma
+			       + input_section->output_offset
+			       + offset + INST_WORD_SIZE);
+		/* fall through */
+	    case (int) R_MICROBLAZE_64 :
+	      {
+		bfd_vma immediate;
+		unsigned short lo, high;
+		relocation += addend;
+		/* Write this value into correct location */
+		high = (unsigned short) bfd_get_16 ( input_bfd, contents + offset + 2);
+		lo = (unsigned short) bfd_get_16 ( input_bfd, contents + offset + INST_WORD_SIZE + 2);
+		immediate = (high << 16) & 0xffff0000;
+		immediate += lo & 0x0000ffff;
+		immediate += relocation;
+		lo = immediate & 0x0000ffff;
+		high = (immediate >> 16) & 0x0000ffff;
+		bfd_put_16 ( input_bfd, high, contents + offset + 2);
+		bfd_put_16 ( input_bfd, lo, contents + offset + INST_WORD_SIZE + 2);
+		break;
+	      }
+	    default :
+	      r = _bfd_final_link_relocate (howto, input_bfd, input_section,
+					    contents, offset,
+					    relocation, addend);
+	      break;
+	    }
+	}
+
+    check_reloc:
+
+      if (r != bfd_reloc_ok)
+	{
+	  /* FIXME: This should be generic enough to go in a utility.  */
+	  const char *name;
+
+	  if (h != NULL)
+	    name = h->root.root.string;
+	  else
+	    {
+	      name = (bfd_elf_string_from_elf_section
+		      (input_bfd, symtab_hdr->sh_link, sym->st_name));
+	      if (name == NULL || *name == '\0')
+		name = bfd_section_name (input_bfd, sec);
+	    }
+
+	  if (errmsg != NULL)
+	    goto common_error;
+
+	  switch (r)
+	    {
+	    case bfd_reloc_overflow:
+	      if (! ((*info->callbacks->reloc_overflow)
+		     (info, NULL, name, howto->name, (bfd_vma) 0,
+		      input_bfd, input_section, offset)))
+		return FALSE;
+	      break;
+
+	    case bfd_reloc_undefined:
+	      if (! ((*info->callbacks->undefined_symbol)
+		     (info, name, input_bfd, input_section,
+		      offset, TRUE)))
+		return FALSE;
+	      break;
+
+	    case bfd_reloc_outofrange:
+	      errmsg = _("internal error: out of range error");
+	      goto common_error;
+
+	    case bfd_reloc_notsupported:
+	      errmsg = _("internal error: unsupported relocation error");
+	      goto common_error;
+
+	    case bfd_reloc_dangerous:
+	      errmsg = _("internal error: dangerous error");
+	      goto common_error;
+
+	    default:
+	      errmsg = _("internal error: unknown error");
+	      /* fall through */
+
+	    common_error:
+	      if (!((*info->callbacks->warning)
+		    (info, errmsg, name, input_bfd, input_section,
+		     offset)))
+		return FALSE;
+	      break;
+	    }
+	}
+    }
+
+  return ret;
+}
+
+
+/* Set the values of the small data pointers */
+static void
+microblaze_elf_final_sdp (info)
+     struct bfd_link_info *info;
+{
+  struct bfd_link_hash_entry *h;
+
+  h = bfd_link_hash_lookup (info->hash, RO_SDA_ANCHOR_NAME, FALSE, FALSE, TRUE);
+  if (h != (struct bfd_link_hash_entry *) NULL
+      && h->type == bfd_link_hash_defined)
+    ro_small_data_pointer = (h->u.def.value
+			     + h->u.def.section->output_section->vma
+			     + h->u.def.section->output_offset);
+
+  h = bfd_link_hash_lookup (info->hash, RW_SDA_ANCHOR_NAME, FALSE, FALSE, TRUE);
+  if (h != (struct bfd_link_hash_entry *) NULL
+      && h->type == bfd_link_hash_defined)
+    rw_small_data_pointer = (h->u.def.value
+			     + h->u.def.section->output_section->vma
+			     + h->u.def.section->output_offset);
+
+}
+
+static bfd_boolean
+microblaze_elf_relax_section (
+    bfd *abfd,
+    asection *sec,
+    struct bfd_link_info *link_info,
+    bfd_boolean *again)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  Elf_Internal_Rela *internal_relocs;
+  Elf_Internal_Rela *free_relocs = NULL;
+  Elf_Internal_Rela *irel, *irelend;
+  bfd_byte *contents = NULL;
+  bfd_byte *free_contents = NULL;
+  Elf32_External_Sym *extsyms = NULL;
+  Elf32_External_Sym *free_extsyms = NULL;
+  bfd_vma *deleted_addresses = NULL;
+  int delete_count;
+  int *changed_relocs = NULL;
+  int rel_count;
+  unsigned int sec_shndx;
+  Elf_External_Sym_Shndx * shndx;
+  Elf_Internal_Shdr *	shndx_hdr;
+  int handled_relocs;
+  int i,j,index;
+  asection *o;
+  Elf32_External_Sym *esym, *esymend;
+  struct elf_link_hash_entry *sym_hash;
+
+  /* We only do this once per section.  We may be able to delete some code 
+     by running multiple passes, but it is not worth it */
+  *again = FALSE;
+
+  /* Only do this for a text section */
+  if (link_info->relocatable
+      || (sec->flags & SEC_RELOC) == 0
+      || sec->reloc_count == 0
+      || (sec->flags & SEC_CODE) == 0)
+    return TRUE;
+
+  
+  /* If this is the first time we have been called for this section,
+     initialize the cooked size.  */
+  if (sec->size == 0)
+    sec->size = sec->rawsize;
+
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+
+  internal_relocs = (_bfd_elf_link_read_relocs
+		     (abfd, sec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
+		      link_info->keep_memory));
+  if (internal_relocs == NULL)
+    goto error_return;
+  if (! link_info->keep_memory)
+    free_relocs = internal_relocs;
+
+  deleted_addresses = (bfd_vma *) bfd_malloc((sec->reloc_count+1) * sizeof(bfd_vma));
+  if (deleted_addresses == NULL)
+    goto error_return;
+  changed_relocs = (int *) bfd_malloc(sec->reloc_count * sizeof(int));
+  if (changed_relocs == NULL)
+    goto error_return;
+  delete_count = 0;
+
+  irelend = internal_relocs + sec->reloc_count;
+  rel_count = 0;
+
+  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
+  shndx = (Elf_External_Sym_Shndx *) shndx_hdr->contents;
+
+  for (irel = internal_relocs; irel < irelend; irel++, rel_count++)
+    {
+      bfd_vma symval;
+      bfd_vma immediate_val;
+
+      if ((ELF32_R_TYPE (irel->r_info) != (int) R_MICROBLAZE_64_PCREL)
+	  && (ELF32_R_TYPE (irel->r_info) != (int) R_MICROBLAZE_64 ))
+	continue; /* Can't delete this reloc */
+
+      /* Read this BFD's symbols if we haven't done so already.  */
+      if (extsyms == NULL)
+	{
+	  if (symtab_hdr->contents != NULL)
+	    extsyms = (Elf32_External_Sym *) symtab_hdr->contents;
+	  else
+	    {
+	      extsyms = ((Elf32_External_Sym *)
+			 bfd_malloc (symtab_hdr->sh_size));
+	      if (extsyms == NULL)
+		goto error_return;
+	      free_extsyms = extsyms;
+	      if (bfd_seek (abfd, symtab_hdr->sh_offset, SEEK_SET) != 0
+		  || (bfd_read (extsyms, 1, symtab_hdr->sh_size, abfd)
+		      != symtab_hdr->sh_size))
+		goto error_return;
+	    }
+	}
+
+      /* Get the section contents.  */
+      if (contents == NULL)
+	{
+	  if (elf_section_data (sec)->this_hdr.contents != NULL)
+	    contents = elf_section_data (sec)->this_hdr.contents;
+	  else
+	    {
+	      contents = (bfd_byte *) bfd_malloc (sec->rawsize);
+	      if (contents == NULL)
+		goto error_return;
+	      free_contents = contents;
+
+	      if (! bfd_get_section_contents (abfd, sec, contents,
+					      (file_ptr) 0, sec->rawsize))
+		goto error_return;
+	    }
+	}
+
+      /* Get the value of the symbol referred to by the reloc.  */
+      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
+	{
+	  Elf_Internal_Sym isym;
+	  asection *sym_sec;
+
+	  /* A local symbol.  */
+	  bfd_elf32_swap_symbol_in (abfd,
+				    extsyms + ELF32_R_SYM (irel->r_info),
+				    shndx ? shndx + ELF32_R_SYM(irel->r_info):NULL,
+				    &isym);
+
+	  /*
+	  if (isym.st_shndx != _bfd_elf_section_from_bfd_section (abfd, sec))
+	    {
+	      ((*_bfd_error_handler)
+	       (_("%s:  warning: symbol in unexpected section"),
+		bfd_get_filename (abfd)));
+	      continue;
+	    }
+	  */
+
+	  sym_sec = bfd_section_from_elf_index (abfd, isym.st_shndx);
+	  symval = (isym.st_value
+		    + sym_sec->output_section->vma
+		    + sym_sec->output_offset);
+	}
+      else
+	{
+	  unsigned long indx;
+	  struct elf_link_hash_entry *h;
+
+	  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
+	  h = elf_sym_hashes (abfd)[indx];
+	  BFD_ASSERT (h != NULL);
+	  if (h->root.type != bfd_link_hash_defined
+	      && h->root.type != bfd_link_hash_defweak)
+	    {
+	      /* This appears to be a reference to an undefined
+                 symbol.  Just ignore it--it will be caught by the
+                 regular reloc processing.  */
+	      continue;
+	    }
+
+	  symval = (h->root.u.def.value
+		    + h->root.u.def.section->output_section->vma
+		    + h->root.u.def.section->output_offset);
+	}
+
+      immediate_val = (unsigned short) bfd_get_16 (abfd, contents + irel->r_offset + 2) << 16;
+      immediate_val += (unsigned short) bfd_get_16 (abfd, contents + irel->r_offset + INST_WORD_SIZE + 2);
+
+      /* If this is a PC-relative reloc, subtract the instr offset from the symbol value */
+      if (ELF32_R_TYPE (irel->r_info) == (int) R_MICROBLAZE_64_PCREL) {
+	symval -= irel->r_offset
+		 + sec->output_section->vma
+		 + sec->output_offset 
+	         + irel->r_addend
+	         + immediate_val;
+      } else {
+	symval += irel->r_addend + immediate_val;
+      }
+
+      if ((symval & 0xffff8000) == 0 
+	  || (symval & 0xffff8000) == 0xffff8000) {
+	/* We can delete this instruction */
+	deleted_addresses[delete_count] = irel->r_offset;
+	/* Save the reloc number */
+	changed_relocs[delete_count] = rel_count;
+	delete_count++;
+      }
+    } /* Loop through all relocations */
+
+  /* Loop through the relocs again, and see if anything needs to change */
+  if (delete_count > 0) {
+    sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);
+    rel_count = 0;
+    handled_relocs = 0;
+    deleted_addresses[delete_count] = sec->size;
+    for (irel = internal_relocs; irel < irelend; irel++, rel_count++)
+      {
+	bfd_vma nraddr;
+	/* Get the new reloc address.  */
+	nraddr = irel->r_offset;
+	for (i = 0; i <= delete_count; i++) {
+	  if (deleted_addresses[i] >= nraddr)
+	    break;
+	}
+	nraddr -= INST_WORD_SIZE * i;
+	switch ((enum elf_microblaze_reloc_type) ELF32_R_TYPE (irel->r_info)) 
+	  {
+	  default:
+	    break;
+	  case R_MICROBLAZE_64_PCREL:
+	    /* Check if this is the deleted reloc */
+	    if (handled_relocs < delete_count && 
+		rel_count == changed_relocs[handled_relocs]) {
+	      /* Change the reloc type */
+	      irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
+					   (int) R_MICROBLAZE_32_PCREL_LO);
+	      handled_relocs++;
+	    }
+	    break;
+	  case R_MICROBLAZE_64:
+	    /* Check if this is the deleted reloc */
+	    if (handled_relocs < delete_count && 
+		rel_count == changed_relocs[handled_relocs]) {
+	      /* Change the reloc type */
+	      irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
+					   (int) R_MICROBLAZE_32_LO);
+	      handled_relocs++;
+	    }
+	    /* If this reloc is against a symbol defined in this
+	       section, we
+	       must check the addend to see it will put the value in
+	       range to be adjusted, and hence must be changed.  */
+	    if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
+	      {
+		Elf_Internal_Sym sym;
+		bfd_elf32_swap_symbol_in (abfd,
+					  extsyms + ELF32_R_SYM (irel->r_info),
+				    shndx ? shndx + ELF32_R_SYM(irel->r_info):NULL,
+					  &sym);
+		/* Only handle relocs against .text */
+		if (sym.st_shndx == sec_shndx &&
+		    ELF32_ST_TYPE ( sym.st_info) == STT_SECTION) {
+		  bfd_vma immediate;
+		  immediate = (unsigned short) bfd_get_16 (abfd, contents + irel->r_offset + 2) << 16;
+		  immediate += (unsigned short) bfd_get_16 (abfd, contents + irel->r_offset + INST_WORD_SIZE + 2);
+		  for (i = 0; i <= delete_count; i++) {
+		    if (deleted_addresses[i] >= immediate)
+		      break;
+		  }
+		  if (i > 0) {
+		    immediate -= i * INST_WORD_SIZE;
+		    bfd_put_16 (abfd, (immediate & 0xffff0000) >> 16, contents + irel->r_offset + 2);
+		    bfd_put_16 (abfd, (immediate & 0x0000ffff), contents + irel->r_offset + INST_WORD_SIZE + 2);
+		  }
+		}
+	    }
+	    break;
+	  case R_MICROBLAZE_NONE:
+	    {
+	      /* This was a PC-relative instruction that was completely resolved. */
+	      short immediate;
+	      bfd_vma target_address;
+	      immediate = (short) bfd_get_16 (abfd, contents + irel->r_offset + 2);
+	      target_address = immediate + irel->r_offset;
+	      for (i = 0; i <= delete_count; i++) {
+		if (deleted_addresses[i] >= irel->r_offset)
+		  break;
+	      }
+	      for (j = 0; j <= delete_count; j++) {
+		if (deleted_addresses[j] >= target_address)
+		  break;
+	      }
+	      i = j-i;
+	      if (i != 0) {
+		immediate -= i * INST_WORD_SIZE;
+		bfd_put_16 (abfd, immediate, contents + irel->r_offset + 2);
+	      }
+	    }
+	    break;
+	  }
+	irel->r_offset = nraddr;
+      } /* Change all relocs in this section */
+
+    /* Look through all other sections */
+    for (o = abfd->sections; o != NULL; o = o->next)
+      {
+	Elf_Internal_Rela *internal_relocs;
+	Elf_Internal_Rela *irelscan, *irelscanend;
+	bfd_byte *ocontents;
+
+	if (o == sec
+	    || (o->flags & SEC_RELOC) == 0
+	    || o->reloc_count == 0)
+	  continue;
+
+	/* We always cache the relocs.  Perhaps, if info->keep_memory is
+	   FALSE, we should free them, if we are permitted to. */
+
+	internal_relocs = (_bfd_elf_link_read_relocs
+			   (abfd, o, (PTR) NULL, (Elf_Internal_Rela *) NULL,
+			    TRUE));
+	if (internal_relocs == NULL)
+	  goto error_return;
+
+	ocontents = NULL;
+	irelscanend = internal_relocs + o->reloc_count;
+	for (irelscan = internal_relocs; irelscan < irelscanend; irelscan++)
+	  {
+	    Elf_Internal_Sym sym;
+
+	    if (ELF32_R_TYPE (irelscan->r_info) == (int) R_MICROBLAZE_32)
+	      {
+		bfd_elf32_swap_symbol_in (abfd,
+					  extsyms + ELF32_R_SYM (irelscan->r_info),
+				    shndx ? shndx + ELF32_R_SYM(irelscan->r_info):NULL,
+					  &sym);
+
+		/* Look at the reloc only if the value has been resolved */
+		if (sym.st_shndx == sec_shndx 
+		&& (ELF32_ST_TYPE(sym.st_info) == STT_SECTION))
+		  {
+		    bfd_vma immediate;
+
+		    if (ocontents == NULL)
+		      {
+			if (elf_section_data (o)->this_hdr.contents != NULL)
+			  ocontents = elf_section_data (o)->this_hdr.contents;
+			else
+			  {
+			    /* We always cache the section contents.
+			       Perhaps, if info->keep_memory is FALSE, we
+			       should free them, if we are permitted to. */
+
+			    ocontents = (bfd_byte *) bfd_malloc (o->rawsize);
+			    if (ocontents == NULL)
+			      goto error_return;
+			    if (! bfd_get_section_contents (abfd, o, ocontents,
+							    (file_ptr) 0,
+							    o->rawsize))
+			      goto error_return;
+			    elf_section_data (o)->this_hdr.contents = ocontents;
+			  }
+		      }
+
+		    immediate = bfd_get_32 (abfd, ocontents + irelscan->r_offset);
+		    for (i = 0; i <= delete_count; i++) {
+		      if (deleted_addresses[i] >= immediate)
+			break;
+		    }
+		    if (i > 0) {
+		      immediate -= i * INST_WORD_SIZE;
+		      bfd_put_32 (abfd, immediate, ocontents + irelscan->r_offset);
+		    }
+
+		  }
+	      }
+	  }
+      } /* Look through all other sections */
+
+    /* Adjust the local symbols defined in this section.  */
+    esym = extsyms;
+    esymend = esym + symtab_hdr->sh_info;
+    for (; esym < esymend; esym++)
+      {
+	Elf_Internal_Sym isym;
+
+	bfd_elf32_swap_symbol_in (abfd, esym, shndx!=NULL?shndx++:NULL, &isym);
+
+	if (isym.st_shndx == sec_shndx) {
+	  for (i = 0; i <= delete_count; i++) {
+	    if (deleted_addresses[i] >= isym.st_value)
+	      break;
+	  }
+	  if (i > 0) 
+	    {
+	      isym.st_value -= INST_WORD_SIZE * i;
+	      bfd_elf32_swap_symbol_out (abfd, &isym, shndx, esym);
+	    }
+	}
+      }
+
+    /* Now adjust the global symbols defined in this section.  */
+    esym = extsyms + symtab_hdr->sh_info;
+    esymend = extsyms + (symtab_hdr->sh_size / sizeof (Elf32_External_Sym));
+    for (index = 0; esym < esymend; esym++, index++)
+      {
+	Elf_Internal_Sym isym;
+
+	bfd_elf32_swap_symbol_in (abfd, esym, shndx!=NULL?shndx++:NULL, &isym);
+	sym_hash = elf_sym_hashes (abfd)[index];
+	if (isym.st_shndx == sec_shndx
+	    && ((sym_hash)->root.type == bfd_link_hash_defined
+		|| (sym_hash)->root.type == bfd_link_hash_defweak)
+	    && (sym_hash)->root.u.def.section == sec)
+	  {
+	    for (i = 0; i <= delete_count; i++) {
+	      if (deleted_addresses[i] >= (sym_hash)->root.u.def.value)
+		break;
+	    }
+	    if (i > 0) {
+	      (sym_hash)->root.u.def.value -= i * INST_WORD_SIZE;
+	    }
+	  }
+      }
+
+    /* Physically move the code and change the cooked size */
+    for (i = 0, index=deleted_addresses[0]; i < delete_count; i++) {
+      memmove (contents + index, 
+	       contents + deleted_addresses[i] + INST_WORD_SIZE,
+	       deleted_addresses[i+1] - deleted_addresses[i] - INST_WORD_SIZE);
+      index += deleted_addresses[i+1] - deleted_addresses[i] - INST_WORD_SIZE;
+    }
+    sec->size -= INST_WORD_SIZE*delete_count;
+
+    elf_section_data (sec)->relocs = internal_relocs;
+    free_relocs = NULL;
+    
+    elf_section_data (sec)->this_hdr.contents = contents;
+    free_contents = NULL;
+
+    symtab_hdr->contents = (bfd_byte *) extsyms;
+    free_extsyms = NULL;
+  } /* delete_count > 0 */
+
+
+  if (free_relocs != NULL)
+    {
+      free (free_relocs);
+      free_relocs = NULL;
+    }
+
+  if (free_contents != NULL)
+    {
+      if (! link_info->keep_memory)
+	free (free_contents);
+      else
+	{
+	  /* Cache the section contents for elf_link_input_bfd.  */
+	  elf_section_data (sec)->this_hdr.contents = contents;
+	}
+      free_contents = NULL;
+    }
+
+  if (free_extsyms != NULL)
+    {
+      if (! link_info->keep_memory)
+	free (free_extsyms);
+      else
+	{
+	  /* Cache the symbols for elf_link_input_bfd.  */
+	  symtab_hdr->contents = (bfd_byte *)extsyms;
+	}
+      free_extsyms = NULL;
+    }
+
+  if (deleted_addresses != NULL) {
+    free(deleted_addresses);
+    deleted_addresses = NULL;
+  }
+  if (changed_relocs != NULL) {
+    free(changed_relocs);
+    changed_relocs = NULL;
+  }
+  return TRUE;
+
+ error_return:
+  if (free_relocs != NULL)
+    free (free_relocs);
+  if (free_contents != NULL)
+    free (free_contents);
+  if (free_extsyms != NULL)
+    free (free_extsyms);
+  if (deleted_addresses != NULL)
+    free(deleted_addresses);
+  if (changed_relocs != NULL)
+    free(changed_relocs);
+  return FALSE;
+}
+
+
+
+#define TARGET_BIG_SYM          bfd_elf32_microblaze_vec
+#define TARGET_BIG_NAME		"elf32-microblaze"
+
+#define ELF_ARCH		bfd_arch_microblaze
+#define ELF_MACHINE_CODE	EM_MICROBLAZE
+#define ELF_MAXPAGESIZE		0x1		/* 4k, if we ever have 'em */
+#define elf_info_to_howto	microblaze_elf_info_to_howto
+#define elf_info_to_howto_rel	NULL
+
+#define bfd_elf32_bfd_reloc_type_lookup		microblaze_elf_reloc_type_lookup
+#define bfd_elf32_bfd_is_local_label_name       microblaze_elf_is_local_label_name
+#define elf_backend_relocate_section		microblaze_elf_relocate_section
+#define bfd_elf32_bfd_relax_section             microblaze_elf_relax_section
+
+/*#define bfd_elf32_bfd_set_private_flags		microblaze_elf_set_private_flags*/
+
+#include "elf32-target.h"
diff --git a/bfd/targets.c b/bfd/targets.c
index 849eb94..14cb266 100644
--- a/bfd/targets.c
+++ b/bfd/targets.c
@@ -604,6 +604,7 @@ extern const bfd_target bfd_elf32_m68k_vec;
 extern const bfd_target bfd_elf32_m88k_vec;
 extern const bfd_target bfd_elf32_mcore_big_vec;
 extern const bfd_target bfd_elf32_mcore_little_vec;
+extern const bfd_target bfd_elf32_microblaze_vec;
 extern const bfd_target bfd_elf32_mn10200_vec;
 extern const bfd_target bfd_elf32_mn10300_vec;
 extern const bfd_target bfd_elf32_mt_vec;
diff --git a/config.sub b/config.sub
index 4d936e2..275f398 100755
--- a/config.sub
+++ b/config.sub
@@ -331,6 +331,7 @@ case $basic_machine in
 	| m32c-* | m32r-* | m32rle-* \
 	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
 	| m88110-* | m88k-* | maxq-* | mcore-* \
+        | microblaze-* \
 	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
 	| mips16-* \
 	| mips64-* | mips64el-* \
diff --git a/configure b/configure
index 9a54f72..0562166 100755
--- a/configure
+++ b/configure
@@ -3648,7 +3648,7 @@ case " $build_configdirs " in
     # For an installed makeinfo, we require it to be from texinfo 4.4 or
     # higher, else we use the "missing" dummy.
     if ${MAKEINFO} --version \
-       | egrep 'texinfo[^0-9]*([1-3][0-9]|4\.[4-9]|[5-9])' >/dev/null 2>&1; then
+       | egrep 'texinfo[^0-9]*(4\.([4-9]|[1-9][0-9])|[5-9]|[1-9][0-9])' >/dev/null 2>&1; then
       :
     else
       MAKEINFO="$MISSING makeinfo"
diff --git a/gdb/Makefile.in b/gdb/Makefile.in
index e8cd87a..48a82a0 100644
--- a/gdb/Makefile.in
+++ b/gdb/Makefile.in
@@ -1433,6 +1433,7 @@ ALLDEPFILES = \
 	m68kbsd-nat.c m68kbsd-tdep.c \
 	m68klinux-nat.c m68klinux-tdep.c \
 	m88k-tdep.c m88kbsd-nat.c \
+	microblaze-tdep.c microblaze-linux-tdep.c \
 	mingw-hdep.c \
 	mips-linux-nat.c mips-linux-tdep.c \
 	mips-irix-tdep.c \
@@ -2298,6 +2299,15 @@ memattr.o: memattr.c $(defs_h) $(command_h) $(gdbcmd_h) $(memattr_h) \
 	$(target_h) $(value_h) $(language_h) $(gdb_string_h)
 mem-break.o: mem-break.c $(defs_h) $(symtab_h) $(breakpoint_h) $(inferior_h) \
 	$(target_h)
+microblaze-tdep.o: microblaze-tdep.c $(defs_h) $(frame_h) $(gdbcmd_h) \
+	$(value_h) $(symtab_h) $(symfile_h) $(gdbcore_h) $(inferior_h)
+microblaze-rom.o: microblaze-rom.c $(defs_h) $(gdbcore_h) $(target_h) \
+	$(monitor_h) $(gdb_string_h) $(regcache_h)
+microblaze-linux-tdep.o: microblaze-linux-tdep.c $(defs_h) $(frame_h) \
+	$(inferior_h) $(symtab_h) $(target_h) $(gdbcore_h) $(gdbcmd_h) \
+	$(symfile_h) $(objfiles_h) $(regcache_h) $(value_h) $(osabi_h) \
+	$(regset_h) $(solib_svr4_h) $(microblaze_tdep_h) $(trad_frame_h) \
+	$(frame_unwind_h) $(tramp_frame_h)
 mingw-hdep.o: mingw-hdep.c $(defs_h) $(serial_h) $(gdb_assert_h) \
 	$(gdb_select_h) $(gdb_string_h)
 minsyms.o: minsyms.c $(defs_h) $(gdb_string_h) $(symtab_h) $(bfd_h) \
diff --git a/gdb/breakpoint.c b/gdb/breakpoint.c
index fd231de..61ef67d 100644
--- a/gdb/breakpoint.c
+++ b/gdb/breakpoint.c
@@ -2788,6 +2788,12 @@ bpstat_stop_status (CORE_ADDR bp_addr, ptid_t ptid, int stopped_by_watchpoint)
 		/* Stop.  */
 		break;
 	      case WP_VALUE_CHANGED:
+#if 0
+		/* microblaze supports true read watchpoints. gdb does not support
+		   such watchpoints due to compatibility requirements for x86.
+		   More info @ http://sources.redhat.com/ml/gdb/2005-11/msg00251.html
+		   To work around this, we'll just comment out this section
+		 */
 		if (b->type == bp_read_watchpoint)
 		  {
 		    /* Don't stop: read watchpoints shouldn't fire if
@@ -2797,6 +2803,7 @@ bpstat_stop_status (CORE_ADDR bp_addr, ptid_t ptid, int stopped_by_watchpoint)
 		    bs->stop = 0;
 		    continue;
 		  }
+#endif
 		++(b->hit_count);
 		break;
 	      case WP_VALUE_NOT_CHANGED:
diff --git a/gdb/config/microblaze/linux.mt b/gdb/config/microblaze/linux.mt
new file mode 100644
index 0000000..c2892cb
--- /dev/null
+++ b/gdb/config/microblaze/linux.mt
@@ -0,0 +1,4 @@
+# Target: Xilinx microblaze processor on Linux
+TDEPFILES= microblaze-tdep.o microblaze-linux-tdep.o microblaze-rom.o \
+ monitor.o dsrec.o solib.o solib-svr4.o solib-legacy.o corelow.o symfile-mem.o
+DEPRECATED_TM_FILE= tm-linux.h
diff --git a/gdb/config/microblaze/microblaze.mt b/gdb/config/microblaze/microblaze.mt
new file mode 100644
index 0000000..f3e4798
--- /dev/null
+++ b/gdb/config/microblaze/microblaze.mt
@@ -0,0 +1,5 @@
+# Target: Xilinx microblaze processor
+TDEPFILES= microblaze-tdep.o  microblaze-rom.o monitor.o dsrec.o
+DEPRECATED_TM_FILE= tm-microblaze.h
+#SIM_OBS = remote-sim.o
+#SIM = ../sim/microblaze/libsim.a
diff --git a/gdb/config/microblaze/tm-linux.h b/gdb/config/microblaze/tm-linux.h
new file mode 100644
index 0000000..e74fd7e
--- /dev/null
+++ b/gdb/config/microblaze/tm-linux.h
@@ -0,0 +1,41 @@
+/* Definitions to target GDB to GNU/Linux on PowerPC.
+
+   Copyright 1992, 1993, 2000, 2002 Free Software Foundation, Inc.
+
+This file is part of GDB.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#ifndef TM_LINUX_H
+#define TM_LINUX_H
+
+#include "microblaze/tm-microblaze.h"
+/* Avoid warning from redefinition in tm-sysv4.h (included from tm-linux.h) */
+#undef SKIP_TRAMPOLINE_CODE
+#include "config/tm-linux.h"
+
+/* Enable software single-stepping for Linux. */
+#undef SOFTWARE_SINGLE_STEP_P
+#undef SOFTWARE_SINGLE_STEP
+
+/* We've multi-arched these.  (Note that this completely undoes the
+   effect of config/tm-linux.h #including config/tm-sysv4.h.)  */
+#undef SKIP_TRAMPOLINE_CODE
+
+/* N_FUN symbols in shared libaries have 0 for their values and need
+   to be relocated. */
+#define SOFUN_ADDRESS_MAYBE_MISSING
+
+#endif  /* #ifndef TM_LINUX_H */
diff --git a/gdb/config/microblaze/tm-microblaze.h b/gdb/config/microblaze/tm-microblaze.h
new file mode 100644
index 0000000..d9e4851
--- /dev/null
+++ b/gdb/config/microblaze/tm-microblaze.h
@@ -0,0 +1,251 @@
+/* Parameters for execution on a Xilinx microblaze.
+   Copyright (C) 1995 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA. */
+
+/*
+ * Copyright (c) 2001 Xilinx, Inc.  All rights reserved. 
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by Xilinx, Inc.  The name of the Company may not be used to endorse 
+ * or promote products derived from this software without specific prior 
+ * written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ *	Xilinx, Inc.
+ */
+
+#ifndef TM_MICROBLAZE_H
+#define TM_MICROBLAZE_H
+
+/* The microblaze is big endian (by default) */
+#define TARGET_BYTE_ORDER_DEFAULT BIG_ENDIAN
+
+/* All registers are 32 bits */
+#define REGISTER_SIZE 4
+#define MAX_REGISTER_RAW_SIZE 4
+
+#define REGISTER_VIRTUAL_TYPE(REG) builtin_type_int
+
+#define REGISTER_BYTE(REG) ((REG) * REGISTER_SIZE)
+#define REGISTER_VIRTUAL_SIZE(REG) 4
+#define REGISTER_RAW_SIZE(REG) 4
+
+#define MAX_REGISTER_VIRTUAL_SIZE 4
+
+#define REGISTER_BYTES (NUM_REGS * REGISTER_SIZE)
+
+/* #define REGISTER_NAME(I) microblaze_register_names[I] FIXME */
+
+
+/* Registers. The Xilinx microblaze contains:
+
+   32 32-bit general purpose registers (r0-r31)
+    6 32-bit special registers (pc, msr, ear, esr, fsr, btr)
+   12 32-bit PVR
+    5 32-bit MMU Regs
+   ------
+   55 registers */
+#define NUM_REGS 55
+#define PC_REGNUM 32
+#define MSR_REGNUM 33
+#define EAR_REGNUM 34
+#define ESR_REGNUM 35
+#define FSR_REGNUM 36
+#define ROSDP_REGNUM 2
+#define SP_REGNUM 1
+
+#ifndef TARGET_HAS_HARDWARE_WATCHPOINTS
+
+#define TARGET_HAS_HARDWARE_WATCHPOINTS
+
+#define TARGET_CAN_USE_HARDWARE_WATCHPOINT(type, count, ot) \
+	microblaze_can_use_hardware_watchpoints(type, count, ot)
+#endif
+
+/*
+#ifndef WIN
+#define FP_REGNUM 35 
+#endif
+*/
+
+#define RWSDP_REGNUM 13
+#define LINK_REGNUM 15
+#define PR_REGNUM 15
+#define FIRST_ARGREG 5
+#define LAST_ARGREG 10
+#define RETVAL_REGNUM 3
+
+/*
+#ifdef WIN
+*/
+extern CORE_ADDR microblaze_target_read_fp();
+#define TARGET_READ_FP() microblaze_target_read_fp()
+
+extern void microblaze_target_write_fp(CORE_ADDR val);
+#define TARGET_WRITE_FP(val) microblaze_target_write_fp(val)
+/*
+#endif
+*/
+
+/* Offset from address of function to start of its code.
+   Zero on most machines.  */
+#define FUNCTION_START_OFFSET 0
+
+#define DECR_PC_AFTER_BREAK 0
+
+
+/* BREAKPOINT_FROM_PC uses the program counter value to determine
+   the breakpoint that should be used. microblaze breakpoint does not depend on PC*/
+/* BIG_BREAKPOINT defines the big-endian breakpoint that should be used */
+#ifdef __MICROBLAZE_UCLINUX__
+#define BIG_BREAKPOINT {0xb9, 0xcc, 0x00, 0x60}
+#define LITTLE_BREAKPOINT {0x60, 0x00, 0xcc, 0xb9}
+#else
+#define BIG_BREAKPOINT {0x98, 0x0c, 0x00, 0x00}
+#define LITTLE_BREAKPOINT {0x00, 0x00, 0xc0, 0x89}
+#endif
+
+
+/* Stack grows downward in memory */
+#define INNER_THAN(LHS,RHS) ((LHS) < (RHS))
+
+/* usha #define SAVED_PC_AFTER_CALL(FRAME)  read_register (PR_REGNUM)*/
+extern CORE_ADDR microblaze_saved_pc_after_call(int call_pc);
+#define SAVED_PC_AFTER_CALL(FRAME)  microblaze_saved_pc_after_call (read_register(LINK_REGNUM))
+
+
+struct frame_info;
+struct type;
+struct value;
+
+extern void microblaze_init_extra_frame_info (struct frame_info *fi);
+#define INIT_EXTRA_FRAME_INFO(FROMLEAF, FI) microblaze_init_extra_frame_info ((FI))
+#define INIT_FRAME_PC		/* Not necessary */
+#define FRAME_INIT_SAVED_REGS(FI)	/* handled by init_extra_frame_info */
+
+extern CORE_ADDR microblaze_frame_chain (struct frame_info *fi);
+#define FRAME_CHAIN(FI) microblaze_frame_chain ((FI))
+#define FRAME_CHAIN_VALID(FP, FI) generic_file_frame_chain_valid ((FP), (FI))
+
+extern CORE_ADDR microblaze_frame_saved_pc (struct frame_info *);
+#define FRAME_SAVED_PC(FI) (microblaze_frame_saved_pc ((FI)))
+
+/* Extracting/storing return values. */
+#define STORE_STRUCT_RETURN(ADDR, SP)	/* handled by microblaze_push_arguments */
+
+extern CORE_ADDR microblaze_extract_struct_value_address (char *regbuf);
+#define DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS(REGBUF) \
+    microblaze_extract_struct_value_address (REGBUF)
+
+#define SKIP_PROLOGUE(PC) (microblaze_skip_prologue (PC))
+
+#define FRAME_ARGS_SKIP 0
+extern CORE_ADDR microblaze_frame_args_address (struct frame_info *fi);
+#define FRAME_ARGS_ADDRESS(FI) microblaze_frame_args_address ((FI))
+extern CORE_ADDR microblaze_frame_locals_address (struct frame_info *fi);
+#define FRAME_LOCALS_ADDRESS(FI) microblaze_frame_locals_address ((FI))
+#define FRAME_NUM_ARGS(FI) (-1)
+
+
+extern void microblaze_pop_frame (struct frame_info *fi);
+#define POP_FRAME microblaze_pop_frame (get_current_frame ())
+
+#define USE_GENERIC_DUMMY_FRAMES 1 
+#define CALL_DUMMY                   {0}
+#define CALL_DUMMY_START_OFFSET      (0)
+/*#define CALL_DUMMY_BREAKPOINT_OFFSET (0)*/
+#define CALL_DUMMY_LOCATION          AT_ENTRY_POINT
+/* #define FIX_CALL_DUMMY(DUMMY, START, FUNADDR, NARGS, ARGS, TYPE, GCCP)*/
+#define CALL_DUMMY_ADDRESS()         entry_point_address ()
+#define SIZEOF_CALL_DUMMY_WORDS      0
+#define SAVE_DUMMY_FRAME_TOS(SP)     generic_save_dummy_frame_tos (SP)
+
+extern void microblaze_fix_call_dummy PARAMS ((char*, CORE_ADDR, CORE_ADDR, int, struct value **, struct type *, int));
+#define FIX_CALL_DUMMY(DUMMY, START, FUNADDR, NARGS, ARGS, TYPE, GCCP) \
+  microblaze_fix_call_dummy(DUMMY, START, FUNADDR, NARGS, ARGS, TYPE, GCCP)
+
+extern CORE_ADDR microblaze_push_return_address PARAMS ((CORE_ADDR, CORE_ADDR));
+#define PUSH_RETURN_ADDRESS(PC, SP)  microblaze_push_return_address (PC, SP)
+
+#define PUSH_DUMMY_FRAME	generic_push_dummy_frame ()
+
+extern CORE_ADDR microblaze_push_arguments PARAMS ((int, struct value **, CORE_ADDR,
+					       unsigned char, CORE_ADDR));
+#define PUSH_ARGUMENTS(NARGS, ARGS, SP, STRUCT_RETURN, STRUCT_ADDR) \
+  (SP) = microblaze_push_arguments (NARGS, ARGS, SP, STRUCT_RETURN, STRUCT_ADDR)
+
+/*#define PC_IN_CALL_DUMMY(PC, SP, FP) generic_pc_in_call_dummy (PC, SP, FP)*/
+#define PC_IN_CALL_DUMMY(PC, SP, FP) \
+  (PC == entry_point_address()+4 || PC == entry_point_address()+8)
+
+/* Microblaze will never pass a sturcture by reference. It will always be split
+   between registers and stack. */
+#define REG_STRUCT_HAS_ADDR(GCC_P, TYPE) 0
+
+extern use_struct_convention_fn microblaze_use_struct_convention;
+#define USE_STRUCT_CONVENTION(GCC_P, TYPE) microblaze_use_struct_convention (GCC_P, TYPE)
+
+/* override the default get_saved_register function with
+   one that takes account of generic CALL_DUMMY frames */
+#define GET_SAVED_REGISTER(raw_buffer, optimized, addrp, frame, regnum, lval) \
+    generic_get_saved_register (raw_buffer, optimized, addrp, frame, regnum, lval)
+
+#if FIXME
+/* Cons up virtual frame pointer for trace */
+extern void microblaze_virtual_frame_pointer PARAMS ((CORE_ADDR, long *, long *));
+#define TARGET_VIRTUAL_FRAME_POINTER(PC, REGP, OFFP) \
+	microblaze_virtual_frame_pointer ((PC), (REGP), (OFFP))
+#endif
+
+/* microblaze cannot be bi-endian. */
+#define TARGET_BYTE_ORDER_SELECTABLE_P 0
+
+/* For PE, gcc will tell us what th real type of
+   arguments are when it promotes arguments. */
+#define BELIEVE_PCC_PROMOTION 1
+
+/* All .stabs information is absolute */
+#define BLOCK_ADDRESS_ABSOLUTE 1
+
+/* Hook which will be called after $HOME/.gdbinit and $(PWD)/.gdbinit */
+#define BEFORE_MAIN_LOOP_HOOK microblaze_before_main_loop();
+
+/* Hook which will be called after $HOME/.gdbinit and $(PWD)/.gdbinit */
+extern void microblaze_before_main_loop(); /* in microblaze-tdep.c */
+
+/* Disable software single stepping for native debugging */
+#define SOFTWARE_SINGLE_STEP_P()    (0)
+
+/* siva/9/16/05: default_coerce_float_to_double does not work for us  */
+#define COERCE_FLOAT_TO_DOUBLE(formal, actual) (1)
+
+/* Instruction word size */
+#define INST_WORD_SIZE 4
+
+/* FIXME:  Not yet multiarched FRAME_NUM_ARGS */
+#define FRAME_NUM_ARGS_P microblaze_frame_num_args_p
+
+#endif
+
diff --git a/gdb/configure.tgt b/gdb/configure.tgt
index f6e1ad8..8d26d4a 100644
--- a/gdb/configure.tgt
+++ b/gdb/configure.tgt
@@ -19,6 +19,7 @@ i[34567]86*)		gdb_target_cpu=i386 ;;
 m68hc11*|m6811*)	gdb_target_cpu=m68hc11 ;;
 m68*)			gdb_target_cpu=m68k ;;
 m88*)			gdb_target_cpu=m88k ;;
+microblaze*)		gdb_target_cpu=microblaze ;;
 mips*)			gdb_target_cpu=mips ;;
 powerpc*)		gdb_target_cpu=powerpc ;;
 sparc*)			gdb_target_cpu=sparc ;;
@@ -131,6 +132,9 @@ m68*-*-uclinux*)	gdb_target=monitor ;;
 
 m88*-*-openbsd*)	gdb_target=obsd ;;
 
+microblaze*-linux-gnu)	gdb_target=linux ;;
+microblaze-xilinx-*)	gdb_target=microblaze ;;
+
 mips*-*-pe)		gdb_target=wince ;;
 mips*-sgi-irix5*)	gdb_target=irix5 ;;
 mips*-sgi-irix6*)	gdb_target=irix6 ;;
diff --git a/gdb/frame.c b/gdb/frame.c
index 64e1baf..0b62ae5 100644
--- a/gdb/frame.c
+++ b/gdb/frame.c
@@ -1556,6 +1556,12 @@ frame_sp_unwind (struct frame_info *next_frame)
   internal_error (__FILE__, __LINE__, _("Missing unwind SP method"));
 }
 
+int 
+frame_level (struct frame_info *frame)
+{
+  return frame->level;
+}
+
 extern initialize_file_ftype _initialize_frame; /* -Wmissing-prototypes */
 
 static struct cmd_list_element *set_backtrace_cmdlist;
diff --git a/gdb/frame.h b/gdb/frame.h
index 800cbfb..1675581 100644
--- a/gdb/frame.h
+++ b/gdb/frame.h
@@ -666,4 +666,7 @@ extern void deprecated_update_frame_pc_hack (struct frame_info *frame,
 extern void deprecated_update_frame_base_hack (struct frame_info *frame,
 					       CORE_ADDR base);
 
+/* Return the level of the frame. */
+extern int frame_level (struct frame_info *);
+
 #endif /* !defined (FRAME_H)  */
diff --git a/gdb/microblaze-linux-tdep.c b/gdb/microblaze-linux-tdep.c
new file mode 100644
index 0000000..71528c7
--- /dev/null
+++ b/gdb/microblaze-linux-tdep.c
@@ -0,0 +1,148 @@
+/* Target-dependent code for GDB, the GNU debugger.
+
+   Copyright (C) 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996,
+   1997, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+#include "defs.h"
+#include "frame.h"
+#include "inferior.h"
+#include "symtab.h"
+#include "target.h"
+#include "gdbcore.h"
+#include "gdbcmd.h"
+#include "symfile.h"
+#include "objfiles.h"
+#include "regcache.h"
+#include "value.h"
+#include "osabi.h"
+#include "regset.h"
+#include "solib-svr4.h"
+#include "microblaze-tdep.h"
+#include "trad-frame.h"
+#include "frame-unwind.h"
+#include "tramp-frame.h"
+
+
+/* See ppc_linux_memory_remove_breakpoints for description. */
+int
+microblaze_linux_memory_remove_breakpoint (struct bp_target_info *bp_tgt)
+{
+  CORE_ADDR addr = bp_tgt->placed_address;
+  const unsigned char *bp;
+  int val;
+  int bplen;
+  gdb_byte old_contents[BREAKPOINT_MAX];
+
+  /* Determine appropriate breakpoint contents and size for this address.  */
+  bp = BREAKPOINT_FROM_PC (&addr, &bplen);
+  if (bp == NULL)
+    error (_("Software breakpoints not implemented for this target."));
+
+  val = target_read_memory (addr, old_contents, bplen);
+
+  /* If our breakpoint is no longer at the address, this means that the
+     program modified the code on us, so it is wrong to put back the
+     old value */
+  if (val == 0 && memcmp (bp, old_contents, bplen) == 0)
+    val = target_write_memory (addr, bp_tgt->shadow_contents, bplen);
+
+  return val;
+}
+
+
+static void
+microblaze_linux_sigtramp_cache (struct frame_info *next_frame,
+			  	 struct trad_frame_cache *this_cache,
+			  	 CORE_ADDR func, LONGEST offset,
+			  	 int bias)
+{
+  CORE_ADDR base;
+  CORE_ADDR gpregs;
+  int regnum;
+  struct gdbarch *gdbarch = get_frame_arch (next_frame);
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+  base = frame_unwind_register_unsigned (next_frame, SP_REGNUM);
+  if (bias > 0 && frame_pc_unwind (next_frame) != func)
+    /* See below, some signal trampolines increment the stack as their
+       first instruction, need to compensate for that.  */
+    base -= bias;
+
+  /* Find the address of the register buffer.  */
+  gpregs = base + offset;
+
+  /* Registers saved on stack.  */
+  for (regnum = 0; regnum < MICROBLAZE_BTR_REGNUM; regnum++)
+    {
+      trad_frame_set_reg_addr (this_cache, regnum, 
+	  		       gpregs + regnum * REGISTER_SIZE);
+    }
+  trad_frame_set_id (this_cache, frame_id_build (base, func));
+}
+
+
+static void
+microblaze_linux_sighandler_cache_init (const struct tramp_frame *self,
+				   struct frame_info *next_frame,
+				   struct trad_frame_cache *this_cache,
+				   CORE_ADDR func)
+{
+  microblaze_linux_sigtramp_cache (next_frame, this_cache, func,
+				   0 /* Offset to ucontext_t.  */
+				   + 24 /* Offset to .reg.  */,
+				   0);
+}
+
+static struct tramp_frame microblaze_linux_sighandler_tramp_frame = {
+  SIGTRAMP_FRAME,
+  4,
+  { 
+    { 0x31800077, -1 }, /* addik R12,R0,119 */
+    { 0xb9cc0008, -1 }, /* brki R14,8 */
+    { TRAMP_SENTINEL_INSN },
+  },
+  microblaze_linux_sighandler_cache_init
+};
+
+
+static void
+microblaze_linux_init_abi (struct gdbarch_info info,
+                           struct gdbarch *gdbarch)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+  set_gdbarch_memory_remove_breakpoint (gdbarch,
+                        microblaze_linux_memory_remove_breakpoint);
+
+  /* Shared library handling.  */
+  set_solib_svr4_fetch_link_map_offsets (gdbarch, 
+      					 svr4_ilp32_fetch_link_map_offsets);
+
+  /* Trampolines.  */
+  tramp_frame_prepend_unwinder (gdbarch, &microblaze_linux_sighandler_tramp_frame);
+}
+
+void
+_initialize_microblaze_linux_tdep (void)
+{
+  gdbarch_register_osabi (bfd_arch_microblaze, 0, 
+      GDB_OSABI_LINUX, microblaze_linux_init_abi);
+}
diff --git a/gdb/microblaze-rom.c b/gdb/microblaze-rom.c
new file mode 100644
index 0000000..2db3eaa
--- /dev/null
+++ b/gdb/microblaze-rom.c
@@ -0,0 +1,225 @@
+/* Remote debugging interface to Xilinx MicroBlaze for gdb,
+   the GNU debugger.
+   Copyright 1999 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/*
+ * Copyright (c) 2001 Xilinx, Inc.  All rights reserved. 
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by Xilinx, Inc.  The name of the Company may not be used to endorse 
+ * or promote products derived from this software without specific prior 
+ * written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ *	Xilinx, Inc.
+ */
+
+#include "defs.h"
+#include "gdbcore.h"
+#include "target.h"
+#include "monitor.h"
+#include "gdb_string.h"
+#include "serial.h"
+
+/* Functions used only in this file. */
+
+static void init_picobug_cmds (void);
+
+
+/* Functions exported from this file. */
+
+void _initialize_picobug_rom (void);
+
+void picobug_open (char *args, int from_tty);
+
+int picobug_dumpregs (void);
+
+
+static char *picobug_inits[] =
+{"\r", NULL};
+
+static struct target_ops picobug_ops;
+static struct monitor_ops picobug_cmds;
+
+/* Picobug only supports a subset of registers from MCore. In reality,
+   it doesn't support ss1, either. */
+/* *INDENT-OFF* */
+static char *picobug_regnames[] = {
+  "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",
+  "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",
+  0,      0,      0,      0,      0,      0,      0,      0,
+  0,      0,      0,      0,      0,      0,      0,      0,
+  "psr",  "vbr",  "epsr", "fpsr", "epc",  "fpc",  0,      "ss1",
+  "ss2",  "ss3",  "ss4",  0,      0,      0,      0,      0,
+  0,      0,      0,      0,      0,      0,      0,      0,
+  0,      0,      0,      0,      0,      0,      0,      0,
+  "pc" };
+/* *INDENT-ON* */
+
+
+
+void
+picobug_open (char *args, int from_tty)
+{
+  monitor_open (args, &picobug_cmds, from_tty);
+}
+/* *INDENT-OFF* */
+/* We choose to write our own dumpregs routine, since the output of
+   the register dumping is rather difficult to encapsulate in a
+   regexp:
+
+picobug> rd                                                                 
+     pc 2f00031e      epc 2f00031e      fpc 00000000
+    psr 80000101     epsr 80000101     fpsr 00000000
+ss0-ss4 bad0beef 00000000 00000000 00000000 00000000      vbr 30005c00
+  r0-r7 2f0fff4c 00000090 00000001 00000002 00000003 00000004 00000005 00000006
+ r8-r15 2f0fff64 00000000 00000000 00000000 00000000 00000000 00000000 2f00031e */
+/* *INDENT-ON* */
+
+
+
+int
+picobug_dumpregs ()
+{
+  char buf[1024];
+  int resp_len;
+  char *p;
+
+  /* Send the dump register command to the monitor and
+     get the reply. */
+  monitor_printf (picobug_cmds.dump_registers);
+  resp_len = monitor_expect_prompt (buf, sizeof (buf));
+
+  p = strtok (buf, " \t\r\n");
+  while (p)
+    {
+      if (strchr (p, '-'))
+	{
+	  /* got a range. either r0-r7, r8-r15 or ss0-ss4 */
+	  if (strncmp (p, "r0", 2) == 0 || strncmp (p, "r8", 2) == 0)
+	    {
+	      int rn = (p[1] == '0' ? 0 : 8);
+	      int i = 0;
+
+	      /* Get the next 8 values and record them. */
+	      while (i < 8)
+		{
+		  p = strtok (NULL, " \t\r\n");
+		  if (p)
+		    monitor_supply_register (rn + i, p);
+		  i++;
+		}
+	    }
+	  else if (strncmp (p, "ss", 2) == 0)
+	    {
+	      /* get the next five values, ignoring the first */
+	      int rn;
+	      p = strtok (NULL, " \t\r\n");
+	      for (rn = 39; rn < 43; rn++)
+		{
+		  p = strtok (NULL, " \t\r\n");
+		  if (p)
+		    monitor_supply_register (rn, p);
+		}
+	    }
+	  else
+	    {
+	      break;
+	    }
+	}
+      else
+	{
+	  /* Simple register type, paired */
+	  char *name = p;
+	  int i;
+
+	  /* Get and record value */
+	  p = strtok (NULL, " \t\r\n");
+	  if (p)
+	    {
+	      for (i = 0; i < NUM_REGS; i++)
+		{
+		  if (picobug_regnames[i] && strcmp (picobug_regnames[i], name) == 0)
+		    break;
+		}
+
+	      if (i <= NUM_REGS)
+		monitor_supply_register (i, p);
+	    }
+	}
+      p = strtok (NULL, " \t\r\n");
+    }
+
+  return 0;
+}
+
+static void
+init_picobug_cmds (void)
+{
+  picobug_cmds.flags = MO_GETMEM_NEEDS_RANGE | MO_CLR_BREAK_USES_ADDR | MO_PRINT_PROGRAM_OUTPUT;
+
+  picobug_cmds.init = picobug_inits;	/* Init strings                       */
+  picobug_cmds.cont = "g\n";	/* continue command                   */
+  picobug_cmds.step = "s\n";	/* single step                        */
+  picobug_cmds.set_break = "br %x\n";	/* set a breakpoint                   */
+  picobug_cmds.clr_break = "nobr %x\n";		/* clear a breakpoint                 */
+  picobug_cmds.clr_all_break = "nobr\n";	/* clear all breakpoints              */
+  picobug_cmds.setmem.cmdb = "mm %x %x ;b\n";	/* setmem.cmdb (addr, value)          */
+  picobug_cmds.setmem.cmdw = "mm %x %x ;h\n";	/* setmem.cmdw (addr, value)          */
+  picobug_cmds.setmem.cmdl = "mm %x %x ;w\n";	/* setmem.cmdl (addr, value)          */
+  picobug_cmds.getmem.cmdb = "md %x %x\n";	/* getmem.cmdb (start addr, end addr) */
+  picobug_cmds.getmem.resp_delim = ":";		/* getmem.resp_delim                  */
+  picobug_cmds.setreg.cmd = "rm %s %x\n";	/* setreg.cmd (name, value)           */
+  picobug_cmds.getreg.cmd = "rd %s\n";	/* getreg.cmd (name)                  */
+  picobug_cmds.getreg.resp_delim = ":";		/* getreg.resp_delim                  */
+  picobug_cmds.dump_registers = "rd\n";		/* dump_registers                     */
+  picobug_cmds.dumpregs = picobug_dumpregs;	/* dump registers parser              */
+  picobug_cmds.load = "lo\n";	/* download command                   */
+  picobug_cmds.prompt = "picobug> ";	/* monitor command prompt             */
+  picobug_cmds.line_term = "\n";	/* end-of-line terminator             */
+  picobug_cmds.target = &picobug_ops;	/* target operations                  */
+  picobug_cmds.stopbits = SERIAL_1_STOPBITS;	/* number of stop bits                */
+  picobug_cmds.regnames = picobug_regnames;	/* registers names                    */
+  picobug_cmds.num_breakpoints = 20;	/* number of breakpoints              */
+  picobug_cmds.magic = MONITOR_OPS_MAGIC;	/* magic                              */
+}
+
+void
+_initialize_picobug_rom ()
+{
+  int i;
+
+  /* Initialize m32r RevC monitor target */
+  init_picobug_cmds ();
+  init_monitor_ops (&picobug_ops);
+  picobug_ops.to_shortname = "picobug";
+  picobug_ops.to_longname = "picobug monitor";
+  picobug_ops.to_doc = "Debug via the picobug monitor.\n\
+Specify the serial device it is connected to (e.g. /dev/ttya).";
+  picobug_ops.to_open = picobug_open;
+
+  add_target (&picobug_ops);
+}
diff --git a/gdb/microblaze-tdep.c b/gdb/microblaze-tdep.c
new file mode 100644
index 0000000..7254b42
--- /dev/null
+++ b/gdb/microblaze-tdep.c
@@ -0,0 +1,1041 @@
+/* Target-dependent code for Xilinx MicroBlaze.
+   
+   Copyright (C) 2007 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/*
+ * Copyright (c) 2007 Xilinx, Inc.  All rights reserved. 
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by Xilinx, Inc.  The name of the Company may not be used to endorse 
+ * or promote products derived from this software without specific prior 
+ * written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ *	Xilinx, Inc.
+ */
+
+#include "defs.h"
+#include "arch-utils.h"
+#include "dis-asm.h"
+#include "frame.h"
+#include "trad-frame.h"
+#include "symtab.h"
+#include "value.h"
+#include "gdbcmd.h"
+#include "breakpoint.h"
+#include "inferior.h"
+#include "regcache.h"
+#include "target.h"
+#include "frame.h"
+#include "frame-base.h"
+#include "frame-unwind.h"
+#include "dwarf2-frame.h"
+#include "osabi.h"
+
+#include "gdb_assert.h"
+#include "gdb_string.h"
+
+
+/* FIXME - this shouldn't be here */
+#include "../opcodes/microblaze-opcm.h"
+
+#include "microblaze-tdep.h"
+
+extern enum microblaze_instr get_insn_microblaze (long, bfd_boolean *, 
+		enum microblaze_instr_type *, short *);
+
+
+/* The registers of the Xilinx microblaze processor */
+
+static const char *microblaze_register_names[] =
+{ 
+  "r0",   "r1",  "r2",    "r3",   "r4",   "r5",   "r6",   "r7",
+  "r8",   "r9",  "r10",   "r11",  "r12",  "r13",  "r14",  "r15",
+  "r16",  "r17", "r18",   "r19",  "r20",  "r21",  "r22",  "r23",
+  "r24",  "r25", "r26",   "r27",  "r28",  "r29",  "r30",  "r31",
+  "rpc",  "rmsr", "rear", "resr", "rfsr", "rbtr", 
+  "rpvr0", "rpvr1", "rpvr2", "rpvr3", "rpvr4", "rpvr5", "rpvr6",
+  "rpvr7", "rpvr8", "rpvr9", "rpvr10", "rpvr11",
+  "redr", "rpid", "rzpr", "rtlbx", "rtlbsx"
+};
+
+#define MICROBLAZE_NUM_REGS ARRAY_SIZE (microblaze_register_names)
+
+#define mb_error(msg) internal_error (__FILE__, __LINE__, _(msg))
+
+extern enum microblaze_instr microblaze_decode_insn (long, int *, int *, int *, int *);
+
+#ifdef MICROBLAZE_DEBUG
+static void
+microblaze_dump_insn (char *commnt, CORE_ADDR pc, int insn)
+{
+  if (microblaze_debug)
+    {
+      printf_filtered ("MICROBLAZE:  %s %08x %08x ",
+		       commnt, (unsigned int) pc, (unsigned int) insn);
+      // print_insn_microblaze (pc, &tm_print_insn_info);
+      printf_filtered ("\n");
+    }
+}
+#define microblaze_insn_debug(args) { if (microblaze_debug) printf_filtered args; }
+#define mb_warn(msg) printf ("mb_warning: %s:%d %s\n", __FILE__, __LINE__, _(msg))
+#else /* !MICROBLAZE_DEBUG */
+#define microblaze_dump_insn(a,b,c) {}
+#define microblaze_insn_debug(args) {}
+#define mb_warn(msg) 
+#endif
+
+/* Return the name of register REGNUM.  */
+
+static const char *
+microblaze_register_name (int regnum)
+{
+  if (regnum >= 0 && regnum < MICROBLAZE_NUM_REGS)
+    return microblaze_register_names[regnum];
+  return NULL;
+}
+
+static struct type *
+microblaze_register_type (struct gdbarch *gdbarch, int regnum)
+{
+  if (regnum == MICROBLAZE_SP_REGNUM)
+    return builtin_type_void_data_ptr;
+
+  if (regnum == MICROBLAZE_PC_REGNUM)
+    return builtin_type_void_func_ptr;
+
+  return builtin_type_int32;
+}
+
+
+/* Fetch the instruction at PC.  */
+
+unsigned long
+microblaze_fetch_instruction (CORE_ADDR pc)
+{
+  gdb_byte buf[4];
+  unsigned long insn;
+  int i;
+
+  /* If we can't read the instruction at PC, return zero.  */
+  if (target_read_memory (pc, buf, sizeof (buf)))
+    return 0;
+
+  insn = 0;
+  for (i = 0; i < sizeof (buf); i++)
+    insn = (insn << 8) | buf[i];
+  return insn;
+}
+
+/* Return the contents if register REGNUM as an address.  */
+
+CORE_ADDR
+microblaze_address_from_register (int regnum)
+{
+  ULONGEST addr;
+
+  regcache_cooked_read_unsigned (current_regcache, regnum, &addr);
+  return addr;
+}
+
+
+static CORE_ADDR
+microblaze_push_dummy_code (struct gdbarch *gdbarch, CORE_ADDR sp,
+			    CORE_ADDR funcaddr, int using_gcc,
+			    struct value **args, int nargs,
+			    struct type *value_type,
+			    CORE_ADDR *real_pc, CORE_ADDR *bp_addr)
+{
+  mb_warn ("push_dummy_code not implemented");
+  return sp;
+}
+
+static CORE_ADDR
+microblaze_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
+			    struct regcache *regcache, CORE_ADDR bp_addr,
+			    int nargs, struct value **args, CORE_ADDR sp,
+			    int struct_return, CORE_ADDR struct_addr)
+{
+  mb_warn ("store_arguments not implemented");
+  return sp;
+}
+
+/* Use the program counter to determine the contents and size of a
+   breakpoint instruction.  Return a pointer to a string of bytes that
+   encode a breakpoint instruction, store the length of the string in
+   *LEN and optionally adjust *PC to point to the correct memory
+   location for inserting the breakpoint.  */
+   
+static const gdb_byte *
+microblaze_breakpoint_from_pc (CORE_ADDR *pc, int *len)
+{
+  static const gdb_byte break_insn[] = BIG_BREAKPOINT;
+
+  //mb_warn ("breakpoint_from_pc doesn't check for delay slot");
+  *len = sizeof (break_insn);
+  return break_insn;
+}
+
+/* Allocate and initialize a frame cache.  */
+
+static struct microblaze_frame_cache *
+microblaze_alloc_frame_cache (void)
+{
+  struct microblaze_frame_cache *cache;
+  int i;
+
+  cache = FRAME_OBSTACK_ZALLOC (struct microblaze_frame_cache);
+
+  /* Base address.  */
+  cache->base = 0;
+  cache->pc = 0;
+
+  /* Frameless until proven otherwise.  */
+  cache->frameless_p = 1;
+
+  return cache;
+}
+
+/* Function prologues on the Xilinx microblaze processors consist of:
+
+   - adjustments to the stack pointer (r1) (addi r1, r1, imm)
+   - making a copy of r1 into another register (a "frame" pointer) (add r?, r1, r0)
+   - store word/multiples that use r1 or the frame pointer as the base address (swi r?, r1, imm OR swi r?, fp, imm)
+
+   Note that microblaze really doesn't have a real frame pointer.
+   Instead, the compiler may copy the SP into a register (usually
+   r19) to act as an arg pointer.  For our target-dependent purposes,
+   the frame info's "frame" member will be the beginning of the
+   frame. The SP could, in fact, point below this.
+
+   The prologue ends when an instruction fails to meet either of
+   these criteria. */
+
+/* Analyze the prologue to determine where registers are saved,
+   the end of the prologue, etc. Return the address of the first line
+   of "real" code (i.e., the end of the prologue). */
+
+CORE_ADDR
+microblaze_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
+			     struct microblaze_frame_cache *cache)
+{
+  char *name;
+  CORE_ADDR func_addr, func_end, addr, stop, prologue_end_addr = 0;
+  unsigned long insn;
+  int rn, rd, ra, rb, imm;
+  enum microblaze_instr op;
+  int flags = 0;
+  bfd_boolean save_hidden_pointer_found = FALSE;
+  bfd_boolean non_stack_instruction_found = FALSE;
+
+  // printf("microblaze_analyze_prologue (pc = 0x%8.8x, current_pc = 0x%8.8x, cache = 0x%8.8x)\n",
+  //	(int) pc, (int) current_pc, (int) cache);
+
+  /* Find the start of this function. */
+  find_pc_partial_function (pc, &name, &func_addr, &func_end);
+  if (func_addr < pc) 
+    pc = func_addr;
+
+  if (current_pc < pc)
+    return current_pc;
+
+   /* Initialize info about frame */
+   cache->framesize = 0;
+   cache->fp_regnum = MICROBLAZE_SP_REGNUM;
+   cache->frameless_p = 1;
+
+  /* Start decoding the prologue.  We start by checking two special cases:
+
+     1. We're about to return
+     2. We're at the first insn of the prologue.
+
+     If we're about to return, our frame has already been deallocated.
+     If we are stopped at the first instruction of a prologue,
+     then our frame has not yet been set up. */
+
+  /* Get the first insn from memory */
+
+  insn = microblaze_fetch_instruction (pc);
+  op = microblaze_decode_insn (insn, &rd, &ra, &rb, &imm);
+
+  if (IS_RETURN(op)) 
+    return pc;
+
+#if 0
+  /* Check for first insn of prologue */
+  if (pc == func_addr)
+    return pc;
+#endif
+
+  /* Start at beginning of function and analyze until we get to the
+     current pc, or the end of the function, whichever is first. */
+  stop = (current_pc < func_end ? current_pc : func_end);
+
+  microblaze_insn_debug(("MICROBLAZE: Scanning prologue: name=%s, func_addr=0x%x, stop=0x%x\n",
+		     name, (unsigned int) func_addr, (unsigned int) stop));
+
+  for (addr = func_addr; addr < stop; addr += INST_WORD_SIZE)
+    {
+      insn = microblaze_fetch_instruction (addr);
+      op = microblaze_decode_insn (insn, &rd, &ra, &rb, &imm);
+      microblaze_dump_insn ("got 2: ", addr, insn);
+
+      /* This code is very sensitive to what functions are present in the prologue. 
+         It assumes that the (addi, addik, swi, sw) can be the only instructions 
+         in the prologue.  */
+      if (IS_UPDATE_SP(op, rd, ra))
+	{
+	  microblaze_insn_debug (("MICROBLAZE: got addi r1,r1,%d; contnuing\n", imm));
+	  if (cache->framesize) break;	/* break if framesize already computed */
+	  cache->framesize = -1 * imm; /* Since stack grows towards low memory */
+	  cache->frameless_p = 0; /* Frame found. */
+	  save_hidden_pointer_found = FALSE;
+	  non_stack_instruction_found = FALSE;
+	  continue;
+	}
+      else if (IS_SPILL_SP(op, rd, ra))
+	{
+	  /* Spill stack pointer */
+	  cache->register_offsets[rd] = imm; /* SP spilled before updating */
+
+	  microblaze_insn_debug (("MICROBLAZE: swi r1 r1 %d, continuing\n", imm));
+	  save_hidden_pointer_found = FALSE;
+	  if (!cache->framesize)
+	  	non_stack_instruction_found = FALSE;
+	  continue;
+	}
+      else if (IS_SPILL_REG(op, rd, ra))
+	{
+	  /* Spill register */
+	  cache->register_offsets[rd] = imm - cache->framesize; /* reg spilled after updating */
+
+	  microblaze_insn_debug (("MICROBLAZE: swi %d r1 %d, continuing\n", rd, imm));
+	  save_hidden_pointer_found = FALSE;
+	  if (!cache->framesize)
+	  	non_stack_instruction_found = FALSE;
+	  continue;
+	}
+      else if (IS_ALSO_SPILL_REG(op, rd, ra, rb))
+	{
+	  /* Spill register */
+	  cache->register_offsets[rd] = 0 - cache->framesize; /* reg spilled after updating */
+
+	  microblaze_insn_debug (("MICROBLAZE: sw %d r0 r1, continuing\n", rd));
+	  save_hidden_pointer_found = FALSE;
+	  if (!cache->framesize)
+	  	non_stack_instruction_found = FALSE;
+	  continue;
+	}
+      else if (IS_SETUP_FP(op, ra, rb))
+	{
+	  /* We have a frame pointer.  Note
+	     the register which is acting as the frame pointer. */
+	  flags |= MY_FRAME_IN_FP;
+	  flags &= ~MY_FRAME_IN_SP;
+	  cache->fp_regnum = rd;
+	  microblaze_insn_debug (("MICROBLAZE: Found a frame pointer: r%d\n", cache->fp_regnum));
+	  save_hidden_pointer_found = FALSE;
+	  if (!cache->framesize)
+	  	non_stack_instruction_found = FALSE;
+	  continue;
+	}
+      else if (IS_SPILL_REG_FP(op, rd, ra, cache->fp_regnum))
+	{
+	  cache->register_offsets[rd] = imm - cache->framesize; /* reg spilled after updating */
+
+	  microblaze_insn_debug (("MICROBLAZE: swi %d %d %d, continuing\n", rd, ra, imm));
+	  save_hidden_pointer_found = FALSE;
+	  if (!cache->framesize)
+	  	non_stack_instruction_found = FALSE;
+	  continue;
+	}
+      else if (IS_SAVE_HIDDEN_PTR(op, rd, ra, rb))
+	{
+	  /* If the first argument is a hidden pointer to the area where the 
+	     return structure is to be saved, then it is saved as part of the 
+	     prologue */
+
+	  microblaze_insn_debug (("MICROBLAZE: add %d %d %d, continuing\n", rd, ra, rb));
+	  save_hidden_pointer_found = TRUE;
+	  if (!cache->framesize)
+	  	non_stack_instruction_found = FALSE;
+	  continue;
+	}
+
+      /* as a result of the modification in the next step where we continue to analyze the 
+	 prologue till we reach a control flow instruction, we need another variable to store
+	 when exactly a non-stack instruction was encountered, which is the current definition
+	 of a prologue
+       */
+      if (!non_stack_instruction_found)
+      		prologue_end_addr = addr;
+      non_stack_instruction_found = TRUE;
+
+      /* When optimizations are enabled, it is not guaranteed that prologue instructions
+	 are not mixed in with other instructions from the program. Some programs show this 
+	 behavior at -O2. This can be avoided by adding -fno-schedule-insns2 switch as of now (edk 8.1)
+	 In such cases, we scan the function until we see the first control instruction.
+       */
+
+	   
+      {
+	      unsigned op = (unsigned)insn >> 26;
+
+	      if (!(op == 0x26 || op == 0x27 || op == 0x2d || op == 0x2e || op == 0x2f))
+		      continue;    /* continue if not control flow (branch, return) */
+	      else if (op == 0x2c)
+		      continue;    /* continue if imm */
+      }
+
+      /* This is not a prologue insn, so stop here. */
+      microblaze_insn_debug (("microblaze: insn is not a prologue insn -- ending scan\n"));
+      break;
+    }
+
+  microblaze_insn_debug (("microblaze: done analyzing prologue\n"));
+  microblaze_insn_debug (("microblaze: prologue end = 0x%x\n", (int) addr));
+
+  /* If the last instruction was an add rd, r5, r0 then don't count it as part of
+     the prologue */
+  if (save_hidden_pointer_found) {
+    prologue_end_addr -= INST_WORD_SIZE;
+  }
+
+  return prologue_end_addr;
+}
+
+static CORE_ADDR
+microblaze_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
+{
+  gdb_byte buf[4];
+  CORE_ADDR pc;
+  // struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  // printf ("microblaze_unwind_pc (next_frame = {level=%d, prev_pc=0x%8.8x})\n",
+// 	next_frame->level, next_frame->prev_pc.value);
+ // debug_frame ("microblaze_unwind_pc", next_frame);
+  frame_unwind_register (next_frame, MICROBLAZE_PC_REGNUM, buf);
+  pc = extract_typed_address (buf, builtin_type_void_func_ptr);
+  /* For sentinel frame, return address is actual PC.  For other frames,
+     return address is pc+8.  This is a workaround because gcc does not
+     generate correct return address in CIE. */
+  if (frame_level(next_frame) >= 0)
+    pc += 8;
+  return pc;
+}
+
+/* Return PC of first real instruction of the function starting at
+   START_PC.  */
+
+CORE_ADDR
+microblaze_skip_prologue (CORE_ADDR start_pc)
+{
+  struct symtab_and_line sal;
+  CORE_ADDR func_start, func_end, ostart_pc;
+  struct microblaze_frame_cache cache;
+
+  /* This is the preferred method, find the end of the prologue by
+     using the debugging information. 
+     Debugging info does not always give the right answer since 
+     parameters are stored on stack after this.  Always analyze the prologue.  */
+  if (find_pc_partial_function (start_pc, NULL, &func_start, &func_end))
+    {
+      sal = find_pc_line (func_start, 0);
+
+      if (sal.end < func_end
+	  && start_pc <= sal.end)
+	start_pc = sal.end;
+    }
+
+  ostart_pc = microblaze_analyze_prologue (func_start, 0xffffffffUL, &cache);
+
+  if (ostart_pc > start_pc)
+    return ostart_pc;
+  return start_pc;
+}
+
+/* Normal frames.  */
+
+struct microblaze_frame_cache *
+microblaze_frame_cache (struct frame_info *next_frame, void **this_cache)
+{
+  struct microblaze_frame_cache *cache;
+  CORE_ADDR func, pc, fp;
+  int rn;
+
+  // printf ("microblaze_frame_cache (next_frame = 0x%8.8x, this_cache = 0x%8.8x)\n",
+  //	(int) next_frame, (int) this_cache);
+  if (*this_cache)
+    return *this_cache;
+
+  cache = microblaze_alloc_frame_cache ();
+  *this_cache = cache;
+  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);
+
+  /* Clear offsets to saved regs in frame. */
+  for (rn = 0; rn < NUM_REGS; rn++)
+    cache->register_offsets[rn] = -1;
+
+  func = frame_func_unwind (next_frame);
+  cache->pc = frame_pc_unwind (next_frame);
+
+  if (cache->pc != 0)
+    {
+      CORE_ADDR addr_in_block = frame_unwind_address_in_block (next_frame);
+      microblaze_analyze_prologue (cache->pc, addr_in_block, cache);
+      fp = frame_unwind_register_unsigned (next_frame, cache->fp_regnum);
+      cache->base = fp + cache->framesize;
+    }
+  else 
+  {
+    // printf ("microblaze_frame_cache:  pc == 0\n");
+    /* FIXME:  What do we do now? */
+  }
+
+  if (cache->frameless_p)
+    {
+      /* FIXME:  What do we do here? */
+      // printf ("\tframeless function\n");
+    }
+  else
+    {
+      /* FIXME:  Find register for current frame. */
+      // printf ("\tfunction with frame\n");
+    }
+
+  return cache;
+}
+
+static void
+microblaze_frame_this_id (struct frame_info *next_frame, void **this_cache,
+		       struct frame_id *this_id)
+{
+  struct microblaze_frame_cache *cache =
+    microblaze_frame_cache (next_frame, this_cache);
+
+  // printf("microblaze_frame_this_id (next_frame = 0x%.8x, this_cache = 0x%.8x, this_id = 0x%.8x)\n",
+  //	(int) next_frame, (int) this_cache, (int) this_id);
+  /* This marks the outermost frame.  */
+  if (cache->base == 0)
+    return;
+
+  (*this_id) = frame_id_build (cache->base, cache->pc);
+}
+
+static void
+microblaze_frame_prev_register (struct frame_info *next_frame, void **this_cache,
+			        int regnum, int *optimizedp,
+			        enum lval_type *lvalp, CORE_ADDR *addrp,
+			        int *realnump, gdb_byte *valuep)
+{
+  struct microblaze_frame_cache *cache =
+    microblaze_frame_cache (next_frame, this_cache);
+
+  // printf("microblaze_frame_prev_register (next_frame = 0x%8.8x (level = %d),\n"
+  //		  "\t*this_cache = 0x%8.8x, frameless_p = %d, regnum = %d)\n", 
+  //   (int) next_frame, frame_level(next_frame), (int) cache, cache->frameless_p, regnum);
+
+  /* FIXME:  Rework this code and add comments. */
+  if (cache->frameless_p) 
+  {
+    if (regnum == MICROBLAZE_PC_REGNUM) regnum = 15;
+    if (regnum == MICROBLAZE_SP_REGNUM) regnum = 1;
+    trad_frame_get_prev_register (next_frame, cache->saved_regs, regnum,
+				  optimizedp, lvalp, addrp, realnump, valuep);
+  } 
+  else if (regnum == MICROBLAZE_PC_REGNUM && !cache->frameless_p)
+    {
+      *optimizedp = 0;
+      *lvalp = not_lval;
+      *addrp = 0;
+      *realnump = -1;
+      if (valuep)
+	/* FIXME:  use symbolic values */
+	get_frame_memory (next_frame, cache->base + cache->register_offsets[15], valuep, 4);
+    }
+  else
+    trad_frame_get_prev_register (next_frame, cache->saved_regs, regnum,
+				  optimizedp, lvalp, addrp, realnump, valuep);
+
+}
+
+static const struct frame_unwind microblaze_frame_unwind =
+{
+  NORMAL_FRAME,
+  microblaze_frame_this_id,
+  microblaze_frame_prev_register
+};
+
+static const struct frame_unwind *
+microblaze_frame_sniffer (struct frame_info *next_frame)
+{
+  return &microblaze_frame_unwind;
+}
+
+static CORE_ADDR
+microblaze_frame_base_address (struct frame_info *next_frame, void **this_cache)
+{
+  struct microblaze_frame_cache *cache =
+    microblaze_frame_cache (next_frame, this_cache);
+
+  // printf ("microblaze_frame_base_address (next_frame = 0x%8.8x, this_cache = 0x%8.8x)\n",
+  //	(int) next_frame, (int) this_cache);
+  return cache->base;
+}
+
+static const struct frame_base microblaze_frame_base =
+{
+  &microblaze_frame_unwind,
+  microblaze_frame_base_address,
+  microblaze_frame_base_address,
+  microblaze_frame_base_address
+};
+
+static struct frame_id
+microblaze_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
+{
+  CORE_ADDR sp;
+
+  // printf("microblaze_unwind_dummy_id (gdbarch = 0x%8.8x, next_frame = 0x%8.8x)\n",
+  //	(int) gdbarch, (int) next_frame);
+  sp = frame_unwind_register_unsigned (next_frame, MICROBLAZE_SP_REGNUM);
+  return frame_id_build (sp, frame_pc_unwind (next_frame));
+}
+
+/* Extract from an array REGBUF containing the (raw) register state, a
+   function return value of TYPE, and copy that into VALBUF.  */
+static void
+microblaze_extract_return_value (struct type *type, struct regcache *regcache,
+			         gdb_byte *valbuf)
+{
+  gdb_byte buf[8];
+
+  // printf("microblaze_extract_return_value (type = 0x%.8x, regcache = 0x%.8x, valbuf = 0x%.8x)\n",
+  //	(int) type, (int) regcache, (int) valbuf);
+  /* Copy the return value (starting) in RETVAL_REGNUM to VALBUF. */
+  switch (TYPE_LENGTH(type)) {
+	  case 1:	/* return last byte in the register */
+		  regcache_cooked_read (regcache, MICROBLAZE_RETVAL_REGNUM, buf);
+		  memcpy(valbuf, buf + REGISTER_SIZE - 1, 1);
+		  return;
+	  case 2:	/* return last 2 bytes in register */
+		  memcpy(valbuf, buf + REGISTER_SIZE - 2, 2);
+		  return;
+	  case 4:	/* for sizes 4 or 8, copy the required length */
+	  case 8:
+		  regcache_cooked_read (regcache, MICROBLAZE_RETVAL_REGNUM, buf);
+		  regcache_cooked_read (regcache, MICROBLAZE_RETVAL_REGNUM+1, buf+4);
+		  memcpy (valbuf, buf, TYPE_LENGTH (type));
+		  return;
+	  default:
+		  printf_filtered("Fatal error: unsupported return value size requested (%s @ %d)\n", 
+				  __FILE__, __LINE__);
+  }
+}
+
+/* Store the return value in VALBUF (of type TYPE) where the caller
+   expects to see it.
+
+   Integers are stored in r3.
+
+   Values less than 32 bits (short, boolean) are stored in r2, right justified and
+   sign or zero extended.		FIXME
+
+   Longs are stored in r3 (most significant word) and r4 (least significant word).
+   Small structures are always returned on stack.
+*/
+
+static void
+microblaze_store_return_value (struct type *type, struct regcache *regcache,
+			       const gdb_byte *valbuf)
+{
+  int len = TYPE_LENGTH (type);
+  gdb_byte buf[8];
+
+  memset (buf, 0, sizeof(buf));
+  
+  /* Integral and pointer return values.  */
+
+  if (len > 4)
+    {
+       gdb_assert (len == 8);
+       memcpy (buf, valbuf, 8);
+       regcache_cooked_write (regcache, MICROBLAZE_RETVAL_REGNUM+1, buf + 4);
+    }
+  else
+    {
+       /* ??? Do we need to do any sign-extension here?  */
+       memcpy (buf + 4 - len, valbuf, len);
+    }
+  regcache_cooked_write (regcache, MICROBLAZE_RETVAL_REGNUM, buf);
+}
+
+static enum return_value_convention
+microblaze_return_value (struct gdbarch *gdbarch, struct type *type,
+		      struct regcache *regcache, gdb_byte *readbuf,
+		      const gdb_byte *writebuf)
+{
+  if (readbuf)
+    microblaze_extract_return_value (type, regcache, readbuf);
+  if (writebuf)
+    microblaze_store_return_value (type, regcache, writebuf);
+
+  return RETURN_VALUE_REGISTER_CONVENTION;
+}
+
+static int
+microblaze_stabs_argument_has_addr (struct gdbarch *gdbarch, struct type *type)
+{
+  return (TYPE_LENGTH (type) == 16);		/* FIXME */
+}
+
+#if 0
+static void
+microblaze_dwarf2_frame_init_reg (struct gdbarch *gdbarch, int regnum,
+			          struct dwarf2_frame_state_reg *reg,
+			          struct frame_info *next_frame)
+{
+  switch (regnum)
+    {
+    case MICROBLAZE_R0_REGNUM:
+      reg->how = DWARF2_FRAME_REG_SAME_VALUE;
+      break;
+    case MICROBLAZE_SP_REGNUM:
+      reg->how = DWARF2_FRAME_REG_CFA;
+      break;
+    case MICROBLAZE_PC_REGNUM:
+      reg->how = DWARF2_FRAME_REG_SAVED_OFFSET;
+      reg->loc.offset = 0;
+      break;
+    }
+}
+#endif
+
+int microblaze_can_use_hardware_watchpoints (enum bptype type, int len, int ot) {
+    int count = 0;
+    switch (type) {
+        case bp_hardware_breakpoint:
+            count = 2;
+            break;
+        case bp_read_watchpoint:
+            count = 1;
+            break;
+        case bp_hardware_watchpoint:
+            count = 1;
+            break;
+        default:
+            count = 0;
+    }
+    return count;
+}
+
+/* Simulate single-step calls, since microblaze does not support 
+   single-stepping */
+
+/* single_step() is called just before we want to resume the inferior,
+   if we want to single-step it but there is no hardware or kernel single-step
+   support.  We find all the possible targets of the
+   coming instruction and breakpoint them.
+
+   single_step is also called just after the inferior stops.  If we had
+   set up a simulated single-step, we undo our damage.  */
+
+void
+microblaze_software_single_step (enum target_signal sig, int insert_breakpoints_p)
+{
+  struct gdbarch *arch = current_gdbarch;
+  struct gdbarch_tdep *tdep = gdbarch_tdep (arch);
+  static char le_breakp[] = LITTLE_BREAKPOINT;
+  static char be_breakp[] = BIG_BREAKPOINT;
+  char *breakp = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG ? be_breakp : le_breakp;
+
+  /* Save the address and the values of the next_pc and the target */
+  static struct sstep_breaks
+  {
+    CORE_ADDR address;
+    bfd_boolean valid;
+    /* Shadow contents.  */
+    char data[INST_WORD_SIZE];
+  } stepbreaks[2];
+  int ii;
+
+  if (insert_breakpoints_p)
+    {
+      CORE_ADDR pc;
+      long insn;
+      enum microblaze_instr minstr;
+      bfd_boolean isunsignednum;
+      enum microblaze_instr_type insn_type;
+      short delay_slots;
+      int imm;
+      bfd_boolean immfound = FALSE;
+
+      /* Set a breakpoint at the next instruction */
+      /* If the current instruction is an imm, set it at the inst after */
+      /* If the instruction has a delay slot, skip the delay slot */
+      pc = microblaze_address_from_register (MICROBLAZE_PC_REGNUM);
+      insn = microblaze_fetch_instruction (pc);
+      minstr = get_insn_microblaze (insn, &isunsignednum, &insn_type, &delay_slots);
+      if (insn_type == immediate_inst) 
+	{
+	  int rd, ra, rb;
+	  immfound = TRUE;
+	  minstr = microblaze_decode_insn (insn, &rd, &ra, &rb, &imm);
+	  pc = pc + INST_WORD_SIZE;
+	  insn = microblaze_fetch_instruction (pc);
+	  minstr = get_insn_microblaze (insn, &isunsignednum, &insn_type, &delay_slots);
+	}
+      stepbreaks[0].address = pc + (delay_slots * INST_WORD_SIZE) + INST_WORD_SIZE;
+      if (insn_type != return_inst) {
+	stepbreaks[0].valid = TRUE;
+      } else {
+	stepbreaks[0].valid = FALSE;
+      }
+
+      /* Now check for branch or return instructions */
+      if (insn_type == branch_inst || insn_type == return_inst) {
+	int limm;
+	int lrd, lra, lrb;
+	int ra, rb;
+	bfd_boolean targetvalid;
+	bfd_boolean unconditionalbranch;
+	microblaze_decode_insn(insn, &lrd, &lra, &lrb, &limm);
+	if (lra >= 0 && lra < NUM_REGS)
+	  ra = read_register(lra);
+	else
+	  ra = 0;
+	if (lrb >= 0 && lrb < NUM_REGS)
+	  rb = read_register(lrb);
+	else
+	  rb = 0;
+	stepbreaks[1].address = microblaze_get_target_address (insn, immfound, imm, pc, ra, rb, &targetvalid, &unconditionalbranch);
+	if (unconditionalbranch)
+	  stepbreaks[0].valid = FALSE; /* This is a unconditional branch: will not come to the next address */
+	if (targetvalid && (stepbreaks[0].valid == FALSE || 
+			    (stepbreaks[0].address != stepbreaks[1].address))
+	                && (stepbreaks[1].address != pc)) {
+	  stepbreaks[1].valid = TRUE;
+	} else {
+	  stepbreaks[1].valid = FALSE;
+	}
+      } else {
+	stepbreaks[1].valid = FALSE;
+      }
+
+      /* Insert the breakpoints */
+      for (ii = 0; ii < 2; ++ii)
+        {
+
+          /* ignore invalid breakpoint. */
+          if (stepbreaks[ii].valid) {
+	    target_read_memory (stepbreaks[ii].address, stepbreaks[ii].data, INST_WORD_SIZE);
+	    target_write_memory (stepbreaks[ii].address, breakp, INST_WORD_SIZE);
+	  }
+	}
+
+    } else {
+      /* Remove the breakpoints */
+      for (ii = 0; ii < 2; ++ii)
+        {
+          /* ignore invalid breakpoint. */
+          if (stepbreaks[ii].valid) {
+	    target_write_memory (stepbreaks[ii].address, stepbreaks[ii].data, INST_WORD_SIZE);
+	  }
+	}
+    }
+}
+
+static void
+microblaze_write_pc (CORE_ADDR pc, ptid_t ptid)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
+
+  write_register_pid (MICROBLAZE_PC_REGNUM, pc, ptid);
+}
+
+/* FIXME -- why special init file? */
+void microblaze_before_main_loop(void) {
+#if 0
+  /* PATH to ENV variable XILINX_EDK */
+  char* xilinx_edk_dir;
+  /* String to hold the path to mb-gdb's custom init file 
+     $XILINX_EDK/data/mb-gdb.ini */
+  char* mb_gdb_init;
+  char mbgdbinit_filename[] = "/data/mb-gdb.ini";
+  
+#ifdef __CYGWIN__
+  {
+    char *tmp = getenv ("XILINX_EDK");
+
+    if (tmp != NULL)
+      {
+	xilinx_edk_dir = (char *) xmalloc (PATH_MAX + 1);
+	cygwin32_conv_to_posix_path (tmp, xilinx_edk_dir);
+      }
+    else
+      xilinx_edk_dir = NULL;
+  }
+#else
+  xilinx_edk_dir = getenv ("XILINX_EDK");
+#endif
+  if (xilinx_edk_dir)
+    {
+      mb_gdb_init = (char *) xmalloc (strlen (xilinx_edk_dir) +
+				     strlen (mbgdbinit_filename) + 10);
+      strcpy (mb_gdb_init, xilinx_edk_dir);
+      strcat (mb_gdb_init, "/");
+      strcat (mb_gdb_init, mbgdbinit_filename);
+
+      if (!inhibit_gdbinit)
+	{
+	  catch_command_errors (source_command, mb_gdb_init, 0, RETURN_MASK_ALL);
+	}
+    }
+#endif
+}
+
+static int dwarf2_to_reg_map[78] =
+{ 0  /* r0  */,   1  /* r1  */,   2  /* r2  */,   3  /* r3  */,  /*  0- 3 */
+  4  /* r4  */,   5  /* r5  */,   6  /* r6  */,   7  /* r7  */,  /*  4- 7 */
+  8  /* r8  */,   9  /* r9  */,  10  /* r10 */,  11  /* r11 */,  /*  8-11 */
+  12 /* r12 */,  13  /* r13 */,  14  /* r14 */,  15  /* r15 */,  /* 12-15 */
+  16 /* r16 */,  17  /* r17 */,  18  /* r18 */,  19  /* r19 */,  /* 16-19 */
+  20 /* r20 */,  21  /* r21 */,  22  /* r22 */,  23  /* r23 */,  /* 20-23 */
+  24 /* r24 */,  25  /* r25 */,  26  /* r26 */,  27  /* r27 */,  /* 24-25 */
+  28 /* r28 */,  29  /* r29 */,  30  /* r30 */,  31  /* r31 */,  /* 28-31 */
+  -1 /* $f0 */,  -1  /* $f1 */,  -1  /* $f2 */,  -1  /* $f3 */,  /* 32-35 */
+  -1 /* $f4 */,  -1  /* $f5 */,  -1  /* $f6 */,  -1  /* $f7 */,  /* 36-39 */
+  -1 /* $f8 */,  -1  /* $f9 */,  -1  /* $f10 */, -1  /* $f11 */, /* 40-43 */
+  -1 /* $f12 */, -1  /* $f13 */, -1  /* $f14 */, -1  /* $f15 */, /* 44-47 */
+  -1 /* $f16 */, -1  /* $f17 */, -1  /* $f18 */, -1  /* $f19 */, /* 48-51 */
+  -1 /* $f20 */, -1  /* $f21 */, -1  /* $f22 */, -1  /* $f23 */, /* 52-55 */
+  -1 /* $f24 */, -1  /* $f25 */, -1  /* $f26 */, -1  /* $f27 */, /* 56-59 */
+  -1 /* $f28 */, -1  /* $f29 */, -1  /* $f30 */, -1  /* $f31 */, /* 60-63 */
+  -1 /* hi   */, -1  /* lo   */, -1  /* accum*/, 33  /* rmsr */, /* 64-67 */
+  -1 /* $fcc1*/, -1  /* $fcc2*/, -1  /* $fcc3*/, -1  /* $fcc4*/, /* 68-71 */
+  -1 /* $fcc5*/, -1  /* $fcc6*/, -1  /* $fcc7*/, -1  /* $ap  */, /* 72-75 */
+  -1 /* $rap */, -1  /* $frp */					 /* 76-77 */
+};
+
+#define DWARF2_FRAME_RETURN_COLUMN 64
+static int
+microblaze_dwarf2_reg_to_regnum (int reg)
+{
+//  if (reg == DWARF2_FRAME_RETURN_COLUMN)
+//    return MICROBLAZE_LR_REGNUM;
+  return dwarf2_to_reg_map[reg];
+}
+
+static struct gdbarch *
+microblaze_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
+{
+  struct gdbarch_tdep *tdep;
+  struct gdbarch *gdbarch;
+
+  /* If there is already a candidate, use it.  */
+  arches = gdbarch_list_lookup_by_info (arches, &info);
+  if (arches != NULL)
+    return arches->gdbarch;
+
+  /* Allocate space for the new architecture.  */
+  tdep = XMALLOC (struct gdbarch_tdep);
+  gdbarch = gdbarch_alloc (&info, tdep);
+
+  set_gdbarch_long_double_bit (gdbarch, 128);
+  /* set_gdbarch_long_double_format (gdbarch, &floatformat_microblaze_quad); */
+
+  set_gdbarch_num_regs (gdbarch, MICROBLAZE_NUM_REGS);
+  set_gdbarch_register_name (gdbarch, microblaze_register_name);
+  set_gdbarch_register_type (gdbarch, microblaze_register_type);
+  /* set_gdbarch_num_pseudo_regs (gdbarch, MICROBLAZE_NUM_PSEUDO_REGS); */
+  /* set_gdbarch_pseudo_register_read (gdbarch, microblaze_pseudo_register_read); */
+  /* set_gdbarch_pseudo_register_write (gdbarch, microblaze_pseudo_register_write); */
+
+  /* Register numbers of various important registers.  */
+  set_gdbarch_sp_regnum (gdbarch, MICROBLAZE_SP_REGNUM); /* $sp */
+  set_gdbarch_pc_regnum (gdbarch, MICROBLAZE_PC_REGNUM); /* $pc */
+
+  /* Map Dwarf2 registers to GDB registers. */
+  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, microblaze_dwarf2_reg_to_regnum);
+
+  /* Call dummy code.  */
+  set_gdbarch_call_dummy_location (gdbarch, ON_STACK);
+  set_gdbarch_push_dummy_code (gdbarch, microblaze_push_dummy_code);
+  set_gdbarch_push_dummy_call (gdbarch, microblaze_push_dummy_call);
+
+  set_gdbarch_return_value (gdbarch, microblaze_return_value);
+  set_gdbarch_stabs_argument_has_addr
+    (gdbarch, microblaze_stabs_argument_has_addr);
+
+  set_gdbarch_skip_prologue (gdbarch, microblaze_skip_prologue);
+
+  /* Stack grows downward.  */
+  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
+
+  set_gdbarch_breakpoint_from_pc (gdbarch, microblaze_breakpoint_from_pc);
+
+  set_gdbarch_frame_args_skip (gdbarch, 8);
+
+  set_gdbarch_print_insn (gdbarch, print_insn_microblaze);
+
+  set_gdbarch_software_single_step (gdbarch, microblaze_software_single_step);
+  set_gdbarch_write_pc (gdbarch, microblaze_write_pc);
+
+  set_gdbarch_unwind_dummy_id (gdbarch, microblaze_unwind_dummy_id);
+
+  set_gdbarch_unwind_pc (gdbarch, microblaze_unwind_pc);
+
+  frame_base_set_default (gdbarch, &microblaze_frame_base);
+
+  /* Hook in the DWARF CFI frame unwinder.  */
+  // dwarf2_frame_set_init_reg (gdbarch, microblaze_dwarf2_frame_init_reg);
+
+  /* Hook in ABI-specific overrides, if they have been registered.  */
+  gdbarch_init_osabi (info, gdbarch); 
+
+  /* Hook in the DWARF CFI frame unwinder.  */
+  frame_unwind_append_sniffer (gdbarch, dwarf2_frame_sniffer);
+
+  frame_unwind_append_sniffer (gdbarch, microblaze_frame_sniffer);
+
+  return gdbarch;
+}
+
+
+/* Provide a prototype to silence -Wmissing-prototypes.  */
+void _initialize_microblaze_tdep (void);
+
+void
+_initialize_microblaze_tdep (void)
+{
+  register_gdbarch_init (bfd_arch_microblaze, microblaze_gdbarch_init);
+}
+
+int
+microblaze_frame_num_args_p (struct gdbarch *gdbarch)
+{
+  return 0;
+}
+
diff --git a/gdb/microblaze-tdep.h b/gdb/microblaze-tdep.h
new file mode 100644
index 0000000..9495f23
--- /dev/null
+++ b/gdb/microblaze-tdep.h
@@ -0,0 +1,168 @@
+/* Target-dependent code for Xilinx MicroBlaze.
+ 
+   Copyright (C) 2007 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+#ifndef MICROBLAZE_TDEP_H
+#define MICROBLAZE_TDEP_H 1
+
+#undef MICROBLAZE_DEBUG 
+#ifdef MICROBLAZE_DEBUG
+int microblaze_debug = 1;
+#endif 
+
+/* Microblaze architecture-specific information.  */
+
+struct gdbarch_tdep
+{
+  int dummy;		// declare something.  
+};
+
+struct microblaze_frame_cache
+{
+  /* Base address.  */
+  CORE_ADDR base;
+  CORE_ADDR pc;
+
+  /* Do we have a frame?  */
+  int frameless_p;
+
+  /* Frame size. */
+  int framesize;
+
+  /* Frame register. */
+  int fp_regnum;
+
+  /* Offsets to saved registers. */
+  int register_offsets[NUM_REGS];
+
+  /* Table of saved registers.  */
+  struct trad_frame_saved_reg *saved_regs;
+};
+
+/* Register numbers */
+enum microblaze_regnum 
+{
+  MICROBLAZE_R0_REGNUM,
+  MICROBLAZE_R1_REGNUM, MICROBLAZE_SP_REGNUM = MICROBLAZE_R1_REGNUM,
+  MICROBLAZE_R2_REGNUM,
+  MICROBLAZE_R3_REGNUM, MICROBLAZE_RETVAL_REGNUM = MICROBLAZE_R3_REGNUM,
+  MICROBLAZE_R4_REGNUM,
+  MICROBLAZE_R5_REGNUM,
+  MICROBLAZE_R6_REGNUM,
+  MICROBLAZE_R7_REGNUM,
+  MICROBLAZE_R8_REGNUM,
+  MICROBLAZE_R9_REGNUM,
+  MICROBLAZE_R10_REGNUM,
+  MICROBLAZE_R11_REGNUM,
+  MICROBLAZE_R12_REGNUM,
+  MICROBLAZE_R13_REGNUM,
+  MICROBLAZE_R14_REGNUM,
+  MICROBLAZE_R15_REGNUM,
+  MICROBLAZE_R16_REGNUM,
+  MICROBLAZE_R17_REGNUM,
+  MICROBLAZE_R18_REGNUM,
+  MICROBLAZE_R19_REGNUM,
+  MICROBLAZE_R20_REGNUM,
+  MICROBLAZE_R21_REGNUM,
+  MICROBLAZE_R22_REGNUM,
+  MICROBLAZE_R23_REGNUM,
+  MICROBLAZE_R24_REGNUM,
+  MICROBLAZE_R25_REGNUM,
+  MICROBLAZE_R26_REGNUM,
+  MICROBLAZE_R27_REGNUM,
+  MICROBLAZE_R28_REGNUM,
+  MICROBLAZE_R29_REGNUM,
+  MICROBLAZE_R30_REGNUM,
+  MICROBLAZE_R31_REGNUM,
+  MICROBLAZE_PC_REGNUM,
+  MICROBLAZE_MSR_REGNUM,
+  MICROBLAZE_EAR_REGNUM,
+  MICROBLAZE_ESR_REGNUM,
+  MICROBLAZE_FSR_REGNUM,
+  MICROBLAZE_BTR_REGNUM,
+  MICROBLAZE_PVR0_REGNUM,
+  MICROBLAZE_PVR1_REGNUM,
+  MICROBLAZE_PVR2_REGNUM,
+  MICROBLAZE_PVR3_REGNUM,
+  MICROBLAZE_PVR4_REGNUM,
+  MICROBLAZE_PVR5_REGNUM,
+  MICROBLAZE_PVR6_REGNUM,
+  MICROBLAZE_PVR7_REGNUM,
+  MICROBLAZE_PVR8_REGNUM,
+  MICROBLAZE_PVR9_REGNUM,
+  MICROBLAZE_PVR10_REGNUM,
+  MICROBLAZE_PVR11_REGNUM
+};
+
+/* The base of the current frame is actually in the stack pointer.
+   This happens when there is no frame pointer (microblaze ABI does not
+   require a frame pointer) or when we're stopped in the prologue or
+   epilogue itself.  In these cases, microblaze_analyze_prologue will need
+   to update fi->frame before returning or analyzing the register
+   save instructions. */
+#define MY_FRAME_IN_SP 0x1
+
+/* The base of the current frame is in a frame pointer register.
+   This register is noted in frame_extra_info->fp_regnum.
+
+   Note that the existance of an FP might also indicate that the
+   function has called alloca. */
+#define MY_FRAME_IN_FP 0x2
+
+/* This flag is set to indicate that this frame is the top-most
+   frame. This tells frame chain not to bother trying to unwind
+   beyond this frame. */
+#define NO_MORE_FRAMES 0x4
+
+
+/* Instruction macros used for analyzing the prologue */
+/* This set of instruction macros need to be changed whenever the prologue generated
+ * by the compiler could have more instructions or different type of instructions
+ * This set also needs to be verified if it is complete 
+ */
+#define IS_RETURN(op) (op == rtsd || op == rtid)
+#define IS_UPDATE_SP(op, rd, ra) ((op == addik || op == addi) && rd == REG_SP && ra == REG_SP)
+#define IS_SPILL_SP(op, rd, ra) ((op == swi || op == sw) && rd == REG_SP && ra == REG_SP)
+#define IS_SPILL_REG(op, rd, ra) ((op == swi || op == sw) && rd != REG_SP && ra == REG_SP)
+/* The base of the current frame is actually in the stack pointer.
+   This happens when there is no frame pointer (microblaze ABI does not
+   require a frame pointer) or when we're stopped in the prologue or
+   epilogue itself.  In these cases, microblaze_analyze_prologue will need
+   to update fi->frame before returning or analyzing the register
+   save instructions. */
+#define MY_FRAME_IN_SP 0x1
+
+/* The base of the current frame is in a frame pointer register.
+   This register is noted in frame_extra_info->fp_regnum.
+
+   Note that the existance of an FP might also indicate that the
+   function has called alloca. */
+#define MY_FRAME_IN_FP 0x2
+
+/* This flag is set to indicate that this frame is the top-most
+   frame. This tells frame chain not to bother trying to unwind
+   beyond this frame. */
+#define NO_MORE_FRAMES 0x4
+#define IS_ALSO_SPILL_REG(op, rd, ra, rb) ((op == swi || op == sw) && rd != REG_SP && ra == 0 && rb == REG_SP)
+#define IS_SETUP_FP(op, ra, rb) ((op == add || op == addik || op == addk) && ra == REG_SP && rb == 0)
+#define IS_SPILL_REG_FP(op, rd, ra, fpregnum) ((op == swi || op == sw) && rd != REG_SP && ra == fpregnum && ra != 0)
+#define IS_SAVE_HIDDEN_PTR(op, rd, ra, rb) ((op == add || op == addik) && ra == FIRST_ARGREG && rb == 0)
+
+#endif /* microblaze-tdep.h */
diff --git a/gdb/remote.c b/gdb/remote.c
index c6ed900..493a398 100644
--- a/gdb/remote.c
+++ b/gdb/remote.c
@@ -5218,6 +5218,65 @@ remote_get_thread_local_address (ptid_t ptid, CORE_ADDR lm, CORE_ADDR offset)
   return 0;
 }
 
+void 
+xmd_load_program(char* args, int from_tty) {
+  struct remote_state *rs = get_remote_state ();
+  int i;
+  char *buf2 = alloca (rs->remote_packet_size);
+  char *p2 = &buf2[0];
+  char outbuf[4096]; /* FIXME: this should be bigger than rs->remote_packet_size, allocate dynamically */
+  /* except for querying the minimum buffer size, target must be open */
+  if (!remote_desc)
+    error ("remote query is only available after target open");
+
+
+  *p2++ = 'q';
+  *p2++ = 'x';
+  *p2++ = 'i';
+  *p2++ = 'l';
+  *p2++ = ',';
+  *p2++ = 'D';
+  *p2++ = '0';
+  *p2++ = ',';
+
+/*
+  *p2++ = 'R';
+  *p2++ = 'c';  
+  *p2++ = 'm';
+  *p2++ = 'd';
+  *p2++ = ',';
+*/
+
+  /* we used one buffer char for the remote protocol q command and another
+     for the query type.  As the remote protocol encapsulation uses 4 chars
+     plus one extra in case we are debugging (remote_debug),
+     we have PBUFZIZ - 7 left to pack the query string */
+
+  bin2hex(args, p2, 0);
+  //  bin2hex(tempbuf, p2, 0); //assuming args ends with a zero
+
+  //printf_filtered("Sending filename : %s\n", buf2);
+
+  i = putpkt (buf2);
+  if (i < 0)
+    return i;
+
+  getpkt (&rs->buf, &rs->buf_size, 0);
+
+/*
+  // Now qxil,D0,<filename> is just an info for XMD to reset the target (optionally)
+  // So no need for response
+  if (rs->buf[0] == 'O' && rs->buf[1] == 'K')
+    return 0;
+
+  printf_filtered("Fast download failed. Using normal download.\n");
+*/
+  //  warning("Reply to filename is : %s\n", outbuf);
+
+  generic_load(args, from_tty);
+}
+
+
 static void
 init_remote_ops (void)
 {
@@ -5248,7 +5307,9 @@ Specify the serial device it is connected to\n\
   remote_ops.to_insert_watchpoint = remote_insert_watchpoint;
   remote_ops.to_remove_watchpoint = remote_remove_watchpoint;
   remote_ops.to_kill = remote_kill;
-  remote_ops.to_load = generic_load;
+// changes to program loading - send info to XMD to reset target (based on user option) before every program download
+// remote_ops.to_load = generic_load;
+  remote_ops.to_load = xmd_load_program;
   remote_ops.to_mourn_inferior = remote_mourn;
   remote_ops.to_thread_alive = remote_thread_alive;
   remote_ops.to_find_new_threads = remote_threads_info;
@@ -5695,4 +5756,11 @@ packets."),
 
   /* Eventually initialize fileio.  See fileio.c */
   initialize_remote_fileio (remote_set_cmdlist, remote_show_cmdlist);
+
+  /* Use the maximum possible remote read/write packet sizes, since the defaults are quite conservative */
+  /* FIXME: this may not be the right location to do such initializations */
+  set_memory_read_packet_size("fixed", 0);
+  set_memory_read_packet_size("16384", 0);
+  set_memory_write_packet_size("fixed", 0);
+  set_memory_write_packet_size("16384", 0);
 }
diff --git a/gdb/symfile.c b/gdb/symfile.c
index 59cd3dc..b9595bf 100644
--- a/gdb/symfile.c
+++ b/gdb/symfile.c
@@ -1516,7 +1516,7 @@ load_command (char *arg, int from_tty)
    we don't want to run a subprocess.  On the other hand, I'm not sure how
    performance compares.  */
 
-static int download_write_size = 512;
+static int download_write_size = 4096;
 static void
 show_download_write_size (struct ui_file *file, int from_tty,
 			  struct cmd_list_element *c, const char *value)
diff --git a/gdb/utils.c b/gdb/utils.c
index 00a060b..27536b4 100644
--- a/gdb/utils.c
+++ b/gdb/utils.c
@@ -1628,6 +1628,7 @@ init_page_info (void)
       lines_per_page = rows;
       chars_per_line = cols;
 
+#if 1
       /* Readline should have fetched the termcap entry for us.  */
       if (tgetnum ("li") < 0 || getenv ("EMACS"))
 	{
@@ -1636,6 +1637,9 @@ init_page_info (void)
 	     not useful (e.g. emacs shell window), so disable paging.  */
 	  lines_per_page = UINT_MAX;
 	}
+#else
+	  lines_per_page = UINT_MAX;
+#endif
 
       /* FIXME: Get rid of this junk.  */
 #if defined(SIGWINCH) && defined(SIGWINCH_HANDLER)
diff --git a/include/dis-asm.h b/include/dis-asm.h
index bdbf9f8..af7f379 100644
--- a/include/dis-asm.h
+++ b/include/dis-asm.h
@@ -237,6 +237,7 @@ extern int print_insn_m88k		(bfd_vma, disassemble_info *);
 extern int print_insn_maxq_little	(bfd_vma, disassemble_info *);
 extern int print_insn_maxq_big		(bfd_vma, disassemble_info *);
 extern int print_insn_mcore		(bfd_vma, disassemble_info *);
+extern int print_insn_microblaze	(bfd_vma, disassemble_info *);
 extern int print_insn_mmix		(bfd_vma, disassemble_info *);
 extern int print_insn_mn10200		(bfd_vma, disassemble_info *);
 extern int print_insn_mn10300		(bfd_vma, disassemble_info *);
diff --git a/include/elf/common.h b/include/elf/common.h
index b11171b..04460e1 100644
--- a/include/elf/common.h
+++ b/include/elf/common.h
@@ -185,6 +185,7 @@
 #define EM_BLACKFIN	106	/* ADI Blackfin */
 #define EM_ALTERA_NIOS2	113	/* Altera Nios II soft-core processor */
 #define EM_CRX		114	/* National Semiconductor CRX */
+#define EM_MICROBLAZE	115	/* Xilinx MicroBlaze */
 
 /* If it is necessary to assign new unofficial EM_* values, please pick large
    random numbers (0x8523, 0xa7f2, etc.) to minimize the chances of collision
diff --git a/include/elf/microblaze.h b/include/elf/microblaze.h
new file mode 100644
index 0000000..165a751
--- /dev/null
+++ b/include/elf/microblaze.h
@@ -0,0 +1,73 @@
+/* Xilinx MicroBlaze support for BFD.
+   Copyright (C) 1995, 1999 Free Software Foundation, Inc.
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/*
+ * Copyright (c) 2001 Xilinx, Inc.  All rights reserved. 
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by Xilinx, Inc.  The name of the Company may not be used to endorse 
+ * or promote products derived from this software without specific prior 
+ * written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ *	Xilinx, Inc.
+ */
+
+/* This file holds definitions specific to the MICROBLAZE ELF ABI. */
+#ifndef _ELF_MORE_H
+#define _ELF_MORE_H
+
+#include "elf/reloc-macros.h"
+
+/* Relocations.  */
+START_RELOC_NUMBERS (elf_microblaze_reloc_type)
+  RELOC_NUMBER (R_MICROBLAZE_NONE, 0)
+  RELOC_NUMBER (R_MICROBLAZE_32, 1)
+  RELOC_NUMBER (R_MICROBLAZE_32_PCREL, 2)
+  RELOC_NUMBER (R_MICROBLAZE_64_PCREL, 3)
+  RELOC_NUMBER (R_MICROBLAZE_32_PCREL_LO, 4)
+  RELOC_NUMBER (R_MICROBLAZE_64, 5)
+  RELOC_NUMBER (R_MICROBLAZE_32_LO, 6)
+  RELOC_NUMBER (R_MICROBLAZE_SRO32, 7)
+  RELOC_NUMBER (R_MICROBLAZE_SRW32, 8)
+     /*
+#ifndef MICROBLAZE_CYGWIN_VERSION
+  EMPTY_RELOC  (R_MICROBLAZE_max)
+END_RELOC_NUMBERS
+#else
+     */
+END_RELOC_NUMBERS (R_MICROBLAZE_max)
+     /*
+#endif
+     */
+
+/* Global base address names */
+#define RO_SDA_ANCHOR_NAME "_SDA2_BASE_"
+#define RW_SDA_ANCHOR_NAME "_SDA_BASE_"
+
+/* Section Attributes.  */
+#define SHF_MICROBLAZE_NOREAD	0x80000000
+
+#endif /* _ELF_MICROBLAZE_H */
diff --git a/opcodes/Makefile.am b/opcodes/Makefile.am
index 2a29b55..968a9a2 100644
--- a/opcodes/Makefile.am
+++ b/opcodes/Makefile.am
@@ -39,6 +39,7 @@ HFILES = \
 	m32c-desc.h m32c-opc.h \
 	m32r-desc.h m32r-opc.h \
 	mcore-opc.h \
+	microblaze-opc.h \
 	mt-desc.h mt-opc.h \
 	openrisc-desc.h openrisc-opc.h \
 	sh-opc.h \
@@ -131,6 +132,7 @@ CFILES = \
 	m88k-dis.c \
 	maxq-dis.c \
 	mcore-dis.c \
+	microblaze-dis.c \
 	mips-dis.c \
 	mips-opc.c \
 	mips16-opc.c \
@@ -266,6 +268,7 @@ ALL_MACHINES = \
 	m10300-opc.lo \
 	maxq-dis.lo \
 	mcore-dis.lo \
+	microblaze-dis.lo \
 	mips-dis.lo \
 	mips-opc.lo \
 	mips16-opc.lo \
@@ -847,6 +850,8 @@ maxq-dis.lo: maxq-dis.c sysdep.h config.h $(INCDIR)/ansidecl.h \
   $(INCDIR)/dis-asm.h $(BFD_H) $(INCDIR)/symcat.h $(INCDIR)/opcode/maxq.h
 mcore-dis.lo: mcore-dis.c sysdep.h config.h $(INCDIR)/ansidecl.h \
   mcore-opc.h $(INCDIR)/dis-asm.h $(BFD_H) $(INCDIR)/symcat.h
+microblaze-dis.lo: microblaze-dis.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  microblaze-opc.h $(INCDIR)/dis-asm.h $(BFD_H) $(INCDIR)/symcat.h
 mips-dis.lo: mips-dis.c sysdep.h config.h $(INCDIR)/ansidecl.h \
   $(INCDIR)/dis-asm.h $(BFD_H) $(INCDIR)/symcat.h $(INCDIR)/libiberty.h \
   $(INCDIR)/opcode/mips.h opintl.h $(BFDDIR)/elf-bfd.h \
diff --git a/opcodes/Makefile.in b/opcodes/Makefile.in
index 9029085..9e2c49c 100644
--- a/opcodes/Makefile.in
+++ b/opcodes/Makefile.in
@@ -257,6 +257,7 @@ HFILES = \
 	m32c-desc.h m32c-opc.h \
 	m32r-desc.h m32r-opc.h \
 	mcore-opc.h \
+	microblaze-opc.h \
 	mt-desc.h mt-opc.h \
 	openrisc-desc.h openrisc-opc.h \
 	sh-opc.h \
@@ -350,6 +351,7 @@ CFILES = \
 	m88k-dis.c \
 	maxq-dis.c \
 	mcore-dis.c \
+	microblaze-dis.c \
 	mips-dis.c \
 	mips-opc.c \
 	mips16-opc.c \
@@ -485,6 +487,7 @@ ALL_MACHINES = \
 	m10300-opc.lo \
 	maxq-dis.lo \
 	mcore-dis.lo \
+	microblaze-dis.lo \
 	mips-dis.lo \
 	mips-opc.lo \
 	mips16-opc.lo \
@@ -1389,6 +1392,8 @@ maxq-dis.lo: maxq-dis.c sysdep.h config.h $(INCDIR)/ansidecl.h \
   $(INCDIR)/dis-asm.h $(BFD_H) $(INCDIR)/symcat.h $(INCDIR)/opcode/maxq.h
 mcore-dis.lo: mcore-dis.c sysdep.h config.h $(INCDIR)/ansidecl.h \
   mcore-opc.h $(INCDIR)/dis-asm.h $(BFD_H) $(INCDIR)/symcat.h
+microblaze-dis.lo: microblaze-dis.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  microblaze-opc.h $(INCDIR)/dis-asm.h $(BFD_H) $(INCDIR)/symcat.h
 mips-dis.lo: mips-dis.c sysdep.h config.h $(INCDIR)/ansidecl.h \
   $(INCDIR)/dis-asm.h $(BFD_H) $(INCDIR)/symcat.h $(INCDIR)/libiberty.h \
   $(INCDIR)/opcode/mips.h opintl.h $(BFDDIR)/elf-bfd.h \
diff --git a/opcodes/configure b/opcodes/configure
index da29cc3..b1897f9 100755
--- a/opcodes/configure
+++ b/opcodes/configure
@@ -8831,6 +8831,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_m88k_arch)		ta="$ta m88k-dis.lo" ;;
 	bfd_maxq_arch)		ta="$ta maxq-dis.lo" ;;
 	bfd_mcore_arch)		ta="$ta mcore-dis.lo" ;;
+	bfd_microblaze_arch)	ta="$ta microblaze-dis.lo" ;;
 	bfd_mips_arch)		ta="$ta mips-dis.lo mips-opc.lo mips16-opc.lo" ;;
 	bfd_mmix_arch)		ta="$ta mmix-dis.lo mmix-opc.lo" ;;
 	bfd_mn10200_arch)	ta="$ta m10200-dis.lo m10200-opc.lo" ;;
diff --git a/opcodes/configure.in b/opcodes/configure.in
index d19d23c..5d5f47e 100644
--- a/opcodes/configure.in
+++ b/opcodes/configure.in
@@ -183,6 +183,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_m88k_arch)		ta="$ta m88k-dis.lo" ;;
 	bfd_maxq_arch)		ta="$ta maxq-dis.lo" ;;
 	bfd_mcore_arch)		ta="$ta mcore-dis.lo" ;;
+	bfd_microblaze_arch)	ta="$ta microblaze-dis.lo" ;;
 	bfd_mips_arch)		ta="$ta mips-dis.lo mips-opc.lo mips16-opc.lo" ;;
 	bfd_mmix_arch)		ta="$ta mmix-dis.lo mmix-opc.lo" ;;
 	bfd_mn10200_arch)	ta="$ta m10200-dis.lo m10200-opc.lo" ;;
diff --git a/opcodes/disassemble.c b/opcodes/disassemble.c
index 3ea4583..e6392b0 100644
--- a/opcodes/disassemble.c
+++ b/opcodes/disassemble.c
@@ -50,6 +50,7 @@
 #define ARCH_m88k
 #define ARCH_maxq
 #define ARCH_mcore
+#define ARCH_microblaze
 #define ARCH_mips
 #define ARCH_mmix
 #define ARCH_mn10200
@@ -259,6 +260,11 @@ disassembler (abfd)
       disassemble = print_insn_mcore;
       break;
 #endif
+#ifdef ARCH_microblaze
+    case bfd_arch_microblaze:
+      disassemble = print_insn_microblaze;
+      break;
+#endif
 #ifdef ARCH_mips
     case bfd_arch_mips:
       if (bfd_big_endian (abfd))
diff --git a/opcodes/microblaze-dis.c b/opcodes/microblaze-dis.c
new file mode 100644
index 0000000..bc6b3db
--- /dev/null
+++ b/opcodes/microblaze-dis.c
@@ -0,0 +1,527 @@
+/* Disassemble Xilinx microblaze instructions.
+   Copyright (C) 1993, 1999, 2000 Free Software Foundation, Inc.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/*
+ * Copyright (c) 2001 Xilinx, Inc.  All rights reserved. 
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by Xilinx, Inc.  The name of the Company may not be used to endorse 
+ * or promote products derived from this software without specific prior 
+ * written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ *	Xilinx, Inc.
+ */
+
+
+#include <stdio.h>
+#include <sysdep.h>
+#define STATIC_TABLE
+#define DEFINE_TABLE
+
+#include "microblaze-opc.h"
+#include "dis-asm.h"
+#include <string.h>
+
+extern char * get_field (long, long, unsigned short);
+extern char * get_field_imm (long);
+extern char * get_field_imm5 (long);
+extern char * get_field_imm12 (long);
+extern char * get_field_imm14 (long);
+extern char * get_field_unsigned_imm (long);
+extern char * get_field_special (long, struct op_code_struct *);
+extern unsigned long read_insn_microblaze (bfd_vma, struct disassemble_info *, struct op_code_struct **);
+extern void no_abort_memory_error(int, bfd_vma, struct disassemble_info *);
+extern int print_insn_microblaze (bfd_vma, struct disassemble_info *);
+extern enum microblaze_instr get_insn_microblaze (long, bfd_boolean *, enum microblaze_instr_type *, short *);
+extern short get_delay_slots_microblaze (long);
+extern enum microblaze_instr microblaze_decode_insn (long, int *, int *, int *, int *);
+
+#define get_field_rd(instr) get_field(instr, RD_MASK, RD_LOW)
+#define get_field_r1(instr) get_field(instr, RA_MASK, RA_LOW)
+#define get_field_r2(instr) get_field(instr, RB_MASK, RB_LOW)
+#define get_int_field_imm(instr) ((instr & IMM_MASK) >> IMM_LOW)
+#define get_int_field_r1(instr) ((instr & RA_MASK) >> RA_LOW)
+
+char *
+get_field (
+     long instr, long mask,
+     unsigned short low)
+{
+  char tmpstr[25];
+  sprintf(tmpstr, "%s%d", register_prefix, (int)((instr & mask) >> low));
+  return(strdup(tmpstr));
+}
+
+char *
+get_field_imm (
+     long instr)
+{
+  char tmpstr[25];
+  sprintf(tmpstr, "%d", (short)((instr & IMM_MASK) >> IMM_LOW));
+  return(strdup(tmpstr));
+}
+
+char *
+get_field_imm5 (
+     long instr)
+{
+  char tmpstr[25];
+  sprintf(tmpstr, "%d", (short)((instr & IMM5_MASK) >> IMM_LOW));
+  return(strdup(tmpstr));
+}
+
+char *
+get_field_imm12 (
+     long instr)
+{
+  char tmpstr[25];
+  sprintf(tmpstr, "%s%d", fsl_register_prefix, (short)((instr & IMM12_MASK) >> IMM_LOW));
+  return(strdup(tmpstr));
+}
+
+char *
+get_field_imm14 (
+     long instr)
+{
+  char tmpstr[25];
+  sprintf(tmpstr, "%d", (short)((instr & IMM14_MASK) >> IMM_LOW));
+  return(strdup(tmpstr));
+}
+
+char *
+get_field_unsigned_imm (
+     long instr)
+{
+  char tmpstr[25];
+  sprintf(tmpstr, "%d", (int)((instr & IMM_MASK) >> IMM_LOW));
+  return(strdup(tmpstr));
+}
+
+/*
+  char *
+  get_field_special (instr) 
+  long instr;
+  {
+  char tmpstr[25];
+  
+  sprintf(tmpstr, "%s%s", register_prefix, (((instr & IMM_MASK) >> IMM_LOW) & REG_MSR_MASK) == 0 ? "pc" : "msr");
+  
+  return(strdup(tmpstr));
+  }
+*/
+
+char *
+get_field_special (
+   long instr,
+struct op_code_struct * op)
+{
+   char tmpstr[25];
+   char spr[5];
+
+   switch ( (((instr & IMM_MASK) >> IMM_LOW) ^ (op->immval_mask)) ) {
+   case REG_MSR_MASK :
+      strcpy(spr, "msr");
+      break;
+   case REG_PC_MASK :
+      strcpy(spr, "pc");
+      break;
+   case REG_EAR_MASK :
+      strcpy(spr, "ear");
+      break;
+   case REG_ESR_MASK :
+      strcpy(spr, "esr");
+      break;
+   case REG_FSR_MASK :
+      strcpy(spr, "fsr");
+      break;      
+   case REG_BTR_MASK :
+      strcpy(spr, "btr");
+      break;      
+   case REG_PVR0_MASK :
+   default :
+      sprintf(spr, "pvr%d", (int)((instr & IMM_MASK) >> IMM_LOW) & 0xf);
+      break;
+      break;
+   }
+   
+   sprintf(tmpstr, "%s%s", register_prefix, spr);
+   return(strdup(tmpstr));
+}
+
+unsigned long
+read_insn_microblaze(
+   bfd_vma memaddr,
+struct disassemble_info *info,
+struct op_code_struct **opr)
+{
+  unsigned char       ibytes[4];
+  int                 status;
+  struct op_code_struct * op;
+  unsigned long inst;
+
+  status = info->read_memory_func (memaddr, ibytes, 4, info);
+
+  if (status != 0) 
+    {
+      info->memory_error_func (status, memaddr, info);
+      return 0;
+    }
+
+  if (info->endian == BFD_ENDIAN_BIG)
+    inst = (ibytes[0] << 24) | (ibytes[1] << 16) | (ibytes[2] << 8) | ibytes[3];
+  else if (info->endian == BFD_ENDIAN_LITTLE)
+    inst = (ibytes[3] << 24) | (ibytes[2] << 16) | (ibytes[1] << 8) | ibytes[0];
+  else
+    abort ();
+
+  /* Just a linear search of the table.  */
+  for (op = opcodes; op->name != 0; op ++)
+    if (op->bit_sequence == (inst & op->opcode_mask))
+      break;
+
+  *opr = op;
+  return inst;
+}
+
+void no_abort_memory_error(int status ATTRIBUTE_UNUSED, 
+			   bfd_vma memaddr ATTRIBUTE_UNUSED,
+			   struct disassemble_info *info ATTRIBUTE_UNUSED) {}
+
+int 
+print_insn_microblaze (
+     bfd_vma memaddr,
+     struct disassemble_info * info)
+{
+  fprintf_ftype       fprintf = info->fprintf_func;
+  void *              stream = info->stream;
+  unsigned long       inst, prev_inst;
+  struct op_code_struct * op, *pop;
+  int                 immval = 0;
+  bfd_boolean             immfound = FALSE;
+  static bfd_vma prev_insn_addr = -1; /*init the prev insn addr */
+  void *tmp;
+ 
+  info->bytes_per_chunk = 4;
+
+  tmp = info->memory_error_func;
+  info->memory_error_func = no_abort_memory_error;
+  inst = read_insn_microblaze (memaddr, info, &op);
+  info->memory_error_func = tmp;
+  if (inst == 0) {
+    fprintf(stream, "Unable to read memory location 0x%x", (unsigned)memaddr);
+    return 4;
+  }
+
+  if (memaddr-(info->bytes_per_chunk) == prev_insn_addr) {
+    tmp = info->memory_error_func;
+    info->memory_error_func = no_abort_memory_error;
+    prev_inst = read_insn_microblaze (prev_insn_addr, info, &pop);
+    info->memory_error_func = tmp;
+    if (prev_inst == 0) {
+      fprintf(stream, "Unable to read memory location 0x%x", (unsigned)memaddr);
+      return 4;
+    }
+    if (pop->instr == imm) {
+      immval = (get_int_field_imm(prev_inst) << 16) & 0xffff0000;
+      immfound = TRUE;
+    }
+    else {
+      immval = 0;
+      immfound = FALSE;
+    }
+  }
+  /* make curr insn as prev insn */
+  prev_insn_addr = memaddr;
+
+  if (op->name == 0)
+    fprintf (stream, ".short 0x%04x", (unsigned)inst);
+  else
+    {
+      fprintf (stream, "%s", op->name);
+      
+      switch (op->inst_type)
+	{
+  case INST_TYPE_RD_R1_R2:
+     fprintf(stream, "\t%s, %s, %s", get_field_rd(inst), get_field_r1(inst), get_field_r2(inst));
+     break;
+        case INST_TYPE_RD_R1_IMM:
+	  fprintf(stream, "\t%s, %s, %s", get_field_rd(inst), get_field_r1(inst), get_field_imm(inst));
+	  if (info->print_address_func && get_int_field_r1(inst) == 0 && info->symbol_at_address_func) {
+	    if (immfound)
+	      immval |= (get_int_field_imm(inst) & 0x0000ffff);
+	    else {
+	      immval = get_int_field_imm(inst);
+	      if (immval & 0x8000)
+		immval |= 0xFFFF0000;
+	    }
+	    if (immval > 0 && info->symbol_at_address_func(immval, info)) {
+	      fprintf (stream, "\t// ");
+	      info->print_address_func (immval, info);
+	    }
+	  }
+	  break;
+	case INST_TYPE_RD_R1_IMM5:
+	  fprintf(stream, "\t%s, %s, %s", get_field_rd(inst), get_field_r1(inst), get_field_imm5(inst));
+	  break;
+	case INST_TYPE_RD_IMM12:
+	  fprintf(stream, "\t%s, %s", get_field_rd(inst), get_field_imm12(inst));
+	  break;
+	case INST_TYPE_R1_IMM12:
+	  fprintf(stream, "\t%s, %s", get_field_r1(inst), get_field_imm12(inst));
+	  break;
+	case INST_TYPE_RD_SPECIAL:
+	  fprintf(stream, "\t%s, %s", get_field_rd(inst), get_field_special(inst, op));
+	  break;
+	case INST_TYPE_SPECIAL_R1:
+	  fprintf(stream, "\t%s, %s", get_field_special(inst, op), get_field_r1(inst));
+	  break;
+	case INST_TYPE_RD_R1:
+	  fprintf(stream, "\t%s, %s", get_field_rd(inst), get_field_r1(inst));
+	  break;
+	case INST_TYPE_R1_R2:
+	  fprintf(stream, "\t%s, %s", get_field_r1(inst), get_field_r2(inst));
+	  break;
+	case INST_TYPE_R1_IMM:
+	  fprintf(stream, "\t%s, %s", get_field_r1(inst), get_field_imm(inst));
+	  /* The non-pc relative instructions are returns, which shouldn't 
+	     have a label printed */
+	  if (info->print_address_func && op->inst_offset_type == INST_PC_OFFSET && info->symbol_at_address_func) {
+	    if (immfound)
+	      immval |= (get_int_field_imm(inst) & 0x0000ffff);
+	    else {
+	      immval = get_int_field_imm(inst);
+	      if (immval & 0x8000)
+		immval |= 0xFFFF0000;
+	    }
+	    immval += memaddr;
+	    if (immval > 0 && info->symbol_at_address_func(immval, info)) {
+	      fprintf (stream, "\t// ");
+	      info->print_address_func (immval, info);
+	    } else {
+	      fprintf (stream, "\t\t// ");
+	      fprintf (stream, "%x", immval);
+	    }
+	  }
+	  break;
+        case INST_TYPE_RD_IMM:
+	  fprintf(stream, "\t%s, %s", get_field_rd(inst), get_field_imm(inst));
+	  if (info->print_address_func && info->symbol_at_address_func) {
+	    if (immfound)
+	      immval |= (get_int_field_imm(inst) & 0x0000ffff);
+	    else {
+	      immval = get_int_field_imm(inst);
+	      if (immval & 0x8000)
+		immval |= 0xFFFF0000;
+	    }
+	    if (op->inst_offset_type == INST_PC_OFFSET)
+	      immval += (int) memaddr;
+	    if (info->symbol_at_address_func(immval, info)) {
+	      fprintf (stream, "\t// ");
+	      info->print_address_func (immval, info);
+	    } 
+	  }
+	  break;
+        case INST_TYPE_IMM:
+	  fprintf(stream, "\t%s", get_field_imm(inst));
+	  if (info->print_address_func && info->symbol_at_address_func && op->instr != imm) {
+	    if (immfound)
+	      immval |= (get_int_field_imm(inst) & 0x0000ffff);
+	    else {
+	      immval = get_int_field_imm(inst);
+	      if (immval & 0x8000)
+		immval |= 0xFFFF0000;
+	    }
+	    if (op->inst_offset_type == INST_PC_OFFSET)
+	      immval += (int) memaddr;
+	    if (immval > 0 && info->symbol_at_address_func(immval, info)) {
+	      fprintf (stream, "\t// ");
+	      info->print_address_func (immval, info);
+	    } else if (op->inst_offset_type == INST_PC_OFFSET) {
+	      fprintf (stream, "\t\t// ");
+	      fprintf (stream, "%x", immval);
+	    }
+	  }
+	  break;
+        case INST_TYPE_RD_R2:
+	  fprintf(stream, "\t%s, %s", get_field_rd(inst), get_field_r2(inst));
+	  break;
+  case INST_TYPE_R2:
+     fprintf(stream, "\t%s", get_field_r2(inst));
+     break;
+  case INST_TYPE_R1:
+     fprintf(stream, "\t%s", get_field_r1(inst));
+     break;
+  case INST_TYPE_RD_R1_SPECIAL:
+     fprintf(stream, "\t%s, %s", get_field_rd(inst), get_field_r2(inst));
+     break;
+  case INST_TYPE_RD_IMM14:
+     fprintf(stream, "\t%s, %s", get_field_rd(inst), get_field_imm14(inst));
+     break;
+     /* For tuqula instruction */
+  case INST_TYPE_RD:
+     fprintf(stream, "\t%s", get_field_rd(inst));
+     break;
+     
+  default:
+	  /* if the disassembler lags the instruction set */
+	  fprintf (stream, "\tundecoded operands, inst is 0x%04x", (unsigned) inst);
+	  break;
+	}
+    }
+  
+  /* Say how many bytes we consumed? */
+  return 4;
+}
+
+enum microblaze_instr
+get_insn_microblaze( 
+  long inst,
+  bfd_boolean *isunsignedimm,
+  enum microblaze_instr_type *insn_type,
+  short *delay_slots)
+{
+  struct op_code_struct * op;
+  *isunsignedimm = FALSE;
+
+  /* Just a linear search of the table.  */
+  for (op = opcodes; op->name != 0; op ++)
+    if (op->bit_sequence == (inst & op->opcode_mask))
+      break;
+
+  if (op->name == 0)
+    return invalid_inst;
+  else {
+    *isunsignedimm = (op->inst_type == INST_TYPE_RD_R1_UNSIGNED_IMM);
+    *insn_type = op->instr_type;
+    *delay_slots = op->delay_slots;
+    return op->instr;
+  }
+}
+
+short
+get_delay_slots_microblaze ( 
+  long inst)
+{
+  bfd_boolean isunsignedimm;
+  enum microblaze_instr_type insn_type;
+  enum microblaze_instr op;
+  short delay_slots;
+
+  op = get_insn_microblaze( inst, &isunsignedimm, &insn_type, &delay_slots);
+  if (op == invalid_inst)
+    return 0;
+  else 
+    return delay_slots;
+}
+
+enum microblaze_instr
+microblaze_decode_insn (
+  long insn,
+int *rd, int *ra, int *rb, int *imm)
+{
+  enum microblaze_instr op;
+  bfd_boolean t1;
+  enum microblaze_instr_type t2;
+  short t3;
+
+  op = get_insn_microblaze(insn, &t1, &t2, &t3);
+  *rd = (insn & RD_MASK) >> RD_LOW;
+  *ra = (insn & RA_MASK) >> RA_LOW;
+  *rb = (insn & RB_MASK) >> RB_LOW;
+  t3 = (insn & IMM_MASK) >> IMM_LOW;
+  *imm = (int) t3;
+  return (op);
+}
+
+unsigned long
+microblaze_get_target_address (
+  long inst,
+  bfd_boolean immfound,
+  int immval,
+  long pcval,
+  long r1val,
+  long r2val,
+  bfd_boolean *targetvalid,
+  bfd_boolean *unconditionalbranch)
+{
+  struct op_code_struct * op;
+  long targetaddr = 0;
+
+  *unconditionalbranch = FALSE;
+  /* Just a linear search of the table.  */
+  for (op = opcodes; op->name != 0; op ++)
+    if (op->bit_sequence == (inst & op->opcode_mask))
+      break;
+
+  if (op->name == 0) {
+    *targetvalid = FALSE;
+  } else if (op->instr_type == branch_inst) {
+    switch (op->inst_type) {
+    case INST_TYPE_R2:
+      *unconditionalbranch = TRUE;
+      /* fallthru */
+    case INST_TYPE_RD_R2:
+    case INST_TYPE_R1_R2:
+      targetaddr = r2val;
+      *targetvalid = TRUE;
+      if (op->inst_offset_type == INST_PC_OFFSET)
+	targetaddr += pcval;
+      break;
+    case INST_TYPE_IMM:
+      *unconditionalbranch = TRUE;
+      /* fallthru */
+    case INST_TYPE_RD_IMM:
+    case INST_TYPE_R1_IMM:
+      if (immfound) {
+	targetaddr = (immval << 16) & 0xffff0000;
+	targetaddr |= (get_int_field_imm(inst) & 0x0000ffff);
+      } else {
+	targetaddr = get_int_field_imm(inst);
+	if (targetaddr & 0x8000)
+	  targetaddr |= 0xFFFF0000;
+      }
+      if (op->inst_offset_type == INST_PC_OFFSET)
+	targetaddr += pcval;
+      *targetvalid = TRUE;
+      break;
+    default:
+      *targetvalid = FALSE;
+      break;
+    }
+  } else if (op->instr_type == return_inst) {
+      if (immfound) {
+	targetaddr = (immval << 16) & 0xffff0000;
+	targetaddr |= (get_int_field_imm(inst) & 0x0000ffff);
+      } else {
+	targetaddr = get_int_field_imm(inst);
+	if (targetaddr & 0x8000)
+	  targetaddr |= 0xFFFF0000;
+      }
+      targetaddr += r1val;
+      *targetvalid = TRUE;
+  } else {
+    *targetvalid = FALSE;
+  }
+  return targetaddr;
+}
diff --git a/opcodes/microblaze-opc.h b/opcodes/microblaze-opc.h
new file mode 100644
index 0000000..ff18cf4
--- /dev/null
+++ b/opcodes/microblaze-opc.h
@@ -0,0 +1,276 @@
+#ifndef MICROBLAZE_OPC
+#define MICROBLAZE_OPC
+/* Assembler instructions for Xilinx's microblaze processor
+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.
+
+   
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/*
+ * Copyright (c) 2001 Xilinx, Inc.  All rights reserved. 
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by Xilinx, Inc.  The name of the Company may not be used to endorse 
+ * or promote products derived from this software without specific prior 
+ * written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ *	Xilinx, Inc.
+ */
+
+#include "microblaze-opcm.h"
+
+
+#define INST_TYPE_RD_R1_R2 0
+#define INST_TYPE_RD_R1_IMM 1
+#define INST_TYPE_RD_R1_UNSIGNED_IMM 2
+#define INST_TYPE_RD_R1 3
+#define INST_TYPE_RD_R2 4
+#define INST_TYPE_RD_IMM 5
+#define INST_TYPE_R2 6
+#define INST_TYPE_R1_R2 7
+#define INST_TYPE_R1_IMM 8
+#define INST_TYPE_IMM 9
+#define INST_TYPE_SPECIAL_R1 10
+#define INST_TYPE_RD_SPECIAL 11
+#define INST_TYPE_R1 12
+  // new instn type for barrel shift imms
+#define INST_TYPE_RD_R1_IMM5  13
+#define INST_TYPE_RD_IMM12    14
+#define INST_TYPE_R1_IMM12    15
+
+  // new insn type for insn cache
+#define INST_TYPE_RD_R1_SPECIAL 16
+
+// new insn type for msrclr, msrset insns.
+#define INST_TYPE_RD_IMM14    17
+
+// new insn type for tuqula rd - addik rd, r0, 42
+#define INST_TYPE_RD    18
+
+#define INST_TYPE_NONE 25
+
+
+
+#define INST_PC_OFFSET 1 /* instructions where the label address is resolved as a PC offset (for branch label)*/
+#define INST_NO_OFFSET 0 /* instructions where the label address is resolved as an absolute value (for data mem or abs address)*/
+
+#define IMMVAL_MASK_NON_SPECIAL 0x0000
+#define IMMVAL_MASK_MTS 0x4000
+#define IMMVAL_MASK_MFS 0x0000
+
+#define OPCODE_MASK_H   0xFC000000 /* High 6 bits only */
+#define OPCODE_MASK_H1  0xFFE00000 /* High 11 bits */
+#define OPCODE_MASK_H2  0xFC1F0000 /* High 6 and bits 20-16 */
+#define OPCODE_MASK_H12 0xFFFF0000 /* High 16 */
+#define OPCODE_MASK_H4  0xFC0007FF /* High 6 and low 11 bits */
+#define OPCODE_MASK_H13S 0xFFE0FFF0 /* High 11 and 15:1 bits and last nibble of last byte for spr */
+#define OPCODE_MASK_H23S 0xFC1FDFF0 /* High 6, 20-16 and 15:1 bits and last nibble of last byte for spr */
+#define OPCODE_MASK_H34 0xFC00FFFF /* High 6 and low 16 bits */
+#define OPCODE_MASK_H14 0xFFE007FF /* High 11 and low 11 bits */
+#define OPCODE_MASK_H24 0xFC1F07FF /* High 6, bits 20-16 and low 11 bits */
+#define OPCODE_MASK_H124  0xFFFF07FF /* High 16, and low 11 bits */
+#define OPCODE_MASK_H1234 0xFFFFFFFF /* All 32 bits */
+#define OPCODE_MASK_H3  0xFC000600 /* High 6 bits and bits 21, 22 */  
+#define OPCODE_MASK_H32 0xFC00F000 /* High 6 bits and bit 16, 17, 18 and 19*/
+#define OPCODE_MASK_H34B   0xFC0000FF /* High 6 bits and low 8 bits */
+
+// New Mask for msrset, msrclr insns.
+#define OPCODE_MASK_H23N  0xFC1FC000 /* High 6 and bits 12 - 18 */
+
+#define DELAY_SLOT 1
+#define NO_DELAY_SLOT 0
+
+#define MAX_OPCODES 149
+
+struct op_code_struct {
+  char *name;
+  short inst_type; /* registers and immediate values involved */
+  short inst_offset_type; /* immediate vals offset from PC? (= 1 for branches) */
+  short delay_slots; /* info about delay slots needed after this instr. */
+  short immval_mask;
+  unsigned long bit_sequence; /* all the fixed bits for the op are set and all the variable bits (reg names, imm vals) are set to 0 */ 
+  unsigned long opcode_mask; /* which bits define the opcode */
+  enum microblaze_instr instr;
+  enum microblaze_instr_type instr_type;
+  /* more info about output format here */
+} opcodes[MAX_OPCODES] = 
+
+{ 
+  {"add",   INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x00000000, OPCODE_MASK_H4, add, arithmetic_inst },
+  {"rsub",  INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x04000000, OPCODE_MASK_H4, rsub, arithmetic_inst },
+  {"addc",  INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x08000000, OPCODE_MASK_H4, addc, arithmetic_inst },
+  {"rsubc", INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x0C000000, OPCODE_MASK_H4, rsubc, arithmetic_inst },
+  {"addk",  INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x10000000, OPCODE_MASK_H4, addk, arithmetic_inst },
+  {"rsubk", INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x14000000, OPCODE_MASK_H4, rsubk, arithmetic_inst },
+  {"cmp",   INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x14000001, OPCODE_MASK_H4, cmp, arithmetic_inst },
+  {"cmpu",  INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x14000003, OPCODE_MASK_H4, cmpu, arithmetic_inst },
+  {"addkc", INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x18000000, OPCODE_MASK_H4, addkc, arithmetic_inst },
+  {"rsubkc",INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x1C000000, OPCODE_MASK_H4, rsubkc, arithmetic_inst },
+  {"addi",  INST_TYPE_RD_R1_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x20000000, OPCODE_MASK_H, addi, arithmetic_inst },
+  {"rsubi", INST_TYPE_RD_R1_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x24000000, OPCODE_MASK_H, rsubi, arithmetic_inst },
+  {"addic", INST_TYPE_RD_R1_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x28000000, OPCODE_MASK_H, addic, arithmetic_inst },
+  {"rsubic",INST_TYPE_RD_R1_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x2C000000, OPCODE_MASK_H, rsubic, arithmetic_inst },
+  {"addik", INST_TYPE_RD_R1_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x30000000, OPCODE_MASK_H, addik, arithmetic_inst },
+  {"rsubik",INST_TYPE_RD_R1_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x34000000, OPCODE_MASK_H, rsubik, arithmetic_inst },
+  {"addikc",INST_TYPE_RD_R1_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x38000000, OPCODE_MASK_H, addikc, arithmetic_inst },
+  {"rsubikc",INST_TYPE_RD_R1_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x3C000000, OPCODE_MASK_H, rsubikc, arithmetic_inst },
+  {"mul",   INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x40000000, OPCODE_MASK_H4, mul, mult_inst },
+  {"idiv",  INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x48000000, OPCODE_MASK_H4, idiv, div_inst },
+  {"idivu", INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x48000002, OPCODE_MASK_H4, idivu, div_inst },
+  {"bsll",  INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x44000400, OPCODE_MASK_H3, bsll, barrel_shift_inst },
+  {"bsra",  INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x44000200, OPCODE_MASK_H3, bsra, barrel_shift_inst },
+  {"bsrl",  INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x44000000, OPCODE_MASK_H3, bsrl, barrel_shift_inst },
+  {"get",   INST_TYPE_RD_IMM12, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C000000, OPCODE_MASK_H32, get, anyware_inst },
+  {"put",   INST_TYPE_R1_IMM12, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C008000, OPCODE_MASK_H32, put, anyware_inst },
+  {"nget",  INST_TYPE_RD_IMM12, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C004000, OPCODE_MASK_H32, nget, anyware_inst },
+  {"nput",  INST_TYPE_R1_IMM12, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C00C000, OPCODE_MASK_H32, nput, anyware_inst },
+  {"cget",  INST_TYPE_RD_IMM12, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C002000, OPCODE_MASK_H32, cget, anyware_inst },
+  {"cput",  INST_TYPE_R1_IMM12, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C00A000, OPCODE_MASK_H32, cput, anyware_inst },
+  {"ncget", INST_TYPE_RD_IMM12, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C006000, OPCODE_MASK_H32, ncget, anyware_inst },
+  {"ncput", INST_TYPE_R1_IMM12, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C00E000, OPCODE_MASK_H32, ncput, anyware_inst },
+  {"muli",  INST_TYPE_RD_R1_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x60000000, OPCODE_MASK_H, muli, mult_inst },
+  {"bslli", INST_TYPE_RD_R1_IMM5, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x64000400, OPCODE_MASK_H3, bslli, barrel_shift_inst },
+  {"bsrai", INST_TYPE_RD_R1_IMM5, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x64000200, OPCODE_MASK_H3, bsrai, barrel_shift_inst },
+  {"bsrli", INST_TYPE_RD_R1_IMM5, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x64000000, OPCODE_MASK_H3, bsrli, barrel_shift_inst },
+  {"or",    INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x80000000, OPCODE_MASK_H4, or, logical_inst },
+  {"and",   INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x84000000, OPCODE_MASK_H4, and, logical_inst },
+  {"xor",   INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x88000000, OPCODE_MASK_H4, xor, logical_inst },
+  {"andn",  INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x8C000000, OPCODE_MASK_H4, andn, logical_inst },
+  {"pcmpbf",INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x80000400, OPCODE_MASK_H4, pcmpbf, logical_inst },
+  {"pcmpbc",INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x84000400, OPCODE_MASK_H4, pcmpbc, logical_inst },
+  {"pcmpeq",INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x88000400, OPCODE_MASK_H4, pcmpeq, logical_inst },
+  {"pcmpne",INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x8C000400, OPCODE_MASK_H4, pcmpne, logical_inst },
+  {"sra",   INST_TYPE_RD_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000001, OPCODE_MASK_H34, sra, logical_inst },
+  {"src",   INST_TYPE_RD_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000021, OPCODE_MASK_H34, src, logical_inst },
+  {"srl",   INST_TYPE_RD_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000041, OPCODE_MASK_H34, srl, logical_inst },
+  {"sext8", INST_TYPE_RD_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000060, OPCODE_MASK_H34, sext8, logical_inst },
+  {"sext16",INST_TYPE_RD_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000061, OPCODE_MASK_H34, sext16, logical_inst },
+  {"wic",   INST_TYPE_RD_R1_SPECIAL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000068, OPCODE_MASK_H34B, wic, special_inst },
+  {"wdc",   INST_TYPE_RD_R1_SPECIAL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000064, OPCODE_MASK_H34B, wdc, special_inst },
+  {"wdc.clear",   INST_TYPE_RD_R1_SPECIAL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000066, OPCODE_MASK_H34B, wdc, special_inst },  
+  {"wdc.flush", INST_TYPE_RD_R1_SPECIAL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000074, OPCODE_MASK_H34B, wdc, special_inst },  
+  {"mts",   INST_TYPE_SPECIAL_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_MTS, 0x9400C000, OPCODE_MASK_H13S, mts, special_inst },
+  {"mfs",   INST_TYPE_RD_SPECIAL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_MFS, 0x94008000, OPCODE_MASK_H23S, mfs, special_inst },
+  {"br",    INST_TYPE_R2, INST_PC_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x98000000, OPCODE_MASK_H124, br, branch_inst },
+  {"brd",   INST_TYPE_R2, INST_PC_OFFSET, DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x98100000, OPCODE_MASK_H124, brd, branch_inst },
+  {"brld",  INST_TYPE_RD_R2, INST_PC_OFFSET, DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x98140000, OPCODE_MASK_H24, brld, branch_inst },
+  {"bra",   INST_TYPE_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x98080000, OPCODE_MASK_H124, bra, branch_inst },
+  {"brad",  INST_TYPE_R2, INST_NO_OFFSET, DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x98180000, OPCODE_MASK_H124, brad, branch_inst },
+  {"brald", INST_TYPE_RD_R2, INST_NO_OFFSET, DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x981C0000, OPCODE_MASK_H24, brald, branch_inst },
+  {"brk",   INST_TYPE_RD_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x980C0000, OPCODE_MASK_H24, microblaze_brk, branch_inst },
+  {"beq",   INST_TYPE_R1_R2, INST_PC_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x9C000000, OPCODE_MASK_H14, beq, branch_inst },
+  {"beqd",  INST_TYPE_R1_R2, INST_PC_OFFSET, DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x9E000000, OPCODE_MASK_H14, beqd, branch_inst },
+  {"bne",   INST_TYPE_R1_R2, INST_PC_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x9C200000, OPCODE_MASK_H14, bne, branch_inst },
+  {"bned",  INST_TYPE_R1_R2, INST_PC_OFFSET, DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x9E200000, OPCODE_MASK_H14, bned, branch_inst },
+  {"blt",   INST_TYPE_R1_R2, INST_PC_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x9C400000, OPCODE_MASK_H14, blt, branch_inst },
+  {"bltd",  INST_TYPE_R1_R2, INST_PC_OFFSET, DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x9E400000, OPCODE_MASK_H14, bltd, branch_inst },
+  {"ble",   INST_TYPE_R1_R2, INST_PC_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x9C600000, OPCODE_MASK_H14, ble, branch_inst },
+  {"bled",  INST_TYPE_R1_R2, INST_PC_OFFSET, DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x9E600000, OPCODE_MASK_H14, bled, branch_inst },
+  {"bgt",   INST_TYPE_R1_R2, INST_PC_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x9C800000, OPCODE_MASK_H14, bgt, branch_inst },
+  {"bgtd",  INST_TYPE_R1_R2, INST_PC_OFFSET, DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x9E800000, OPCODE_MASK_H14, bgtd, branch_inst },
+  {"bge",   INST_TYPE_R1_R2, INST_PC_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x9CA00000, OPCODE_MASK_H14, bge, branch_inst },
+  {"bged",  INST_TYPE_R1_R2, INST_PC_OFFSET, DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x9EA00000, OPCODE_MASK_H14, bged, branch_inst },
+  {"ori",   INST_TYPE_RD_R1_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xA0000000, OPCODE_MASK_H, ori, logical_inst },
+  {"andi",  INST_TYPE_RD_R1_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xA4000000, OPCODE_MASK_H, andi, logical_inst },
+  {"xori",  INST_TYPE_RD_R1_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xA8000000, OPCODE_MASK_H, xori, logical_inst },
+  {"andni", INST_TYPE_RD_R1_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xAC000000, OPCODE_MASK_H, andni, logical_inst },
+  {"imm",   INST_TYPE_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xB0000000, OPCODE_MASK_H12, imm, immediate_inst },
+  {"rtsd",  INST_TYPE_R1_IMM, INST_NO_OFFSET, DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xB6000000, OPCODE_MASK_H1, rtsd, return_inst },
+  {"rtid",  INST_TYPE_R1_IMM, INST_NO_OFFSET, DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xB6200000, OPCODE_MASK_H1, rtid, return_inst },
+  {"rtbd",  INST_TYPE_R1_IMM, INST_NO_OFFSET, DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xB6400000, OPCODE_MASK_H1, rtbd, return_inst },
+  {"rted",  INST_TYPE_R1_IMM, INST_NO_OFFSET, DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xB6800000, OPCODE_MASK_H1, rted, return_inst },
+  {"bri",   INST_TYPE_IMM, INST_PC_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xB8000000, OPCODE_MASK_H12, bri, branch_inst },
+  {"brid",  INST_TYPE_IMM, INST_PC_OFFSET, DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xB8100000, OPCODE_MASK_H12, brid, branch_inst },
+  {"brlid", INST_TYPE_RD_IMM, INST_PC_OFFSET, DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xB8140000, OPCODE_MASK_H2, brlid, branch_inst },
+  {"brai",  INST_TYPE_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xB8080000, OPCODE_MASK_H12, brai, branch_inst },
+  {"braid", INST_TYPE_IMM, INST_NO_OFFSET, DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xB8180000, OPCODE_MASK_H12, braid, branch_inst },
+  {"bralid",INST_TYPE_RD_IMM, INST_NO_OFFSET, DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xB81C0000, OPCODE_MASK_H2, bralid, branch_inst },
+  {"brki",  INST_TYPE_RD_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xB80C0000, OPCODE_MASK_H2, brki, branch_inst },
+  {"beqi",  INST_TYPE_R1_IMM, INST_PC_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xBC000000, OPCODE_MASK_H1, beqi, branch_inst },
+  {"beqid", INST_TYPE_R1_IMM, INST_PC_OFFSET, DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xBE000000, OPCODE_MASK_H1, beqid, branch_inst },
+  {"bnei",  INST_TYPE_R1_IMM, INST_PC_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xBC200000, OPCODE_MASK_H1, bnei, branch_inst },
+  {"bneid", INST_TYPE_R1_IMM, INST_PC_OFFSET, DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xBE200000, OPCODE_MASK_H1, bneid, branch_inst },
+  {"blti",  INST_TYPE_R1_IMM, INST_PC_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xBC400000, OPCODE_MASK_H1, blti, branch_inst },
+  {"bltid", INST_TYPE_R1_IMM, INST_PC_OFFSET, DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xBE400000, OPCODE_MASK_H1, bltid, branch_inst },
+  {"blei",  INST_TYPE_R1_IMM, INST_PC_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xBC600000, OPCODE_MASK_H1, blei, branch_inst },
+  {"bleid", INST_TYPE_R1_IMM, INST_PC_OFFSET, DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xBE600000, OPCODE_MASK_H1, bleid, branch_inst },
+  {"bgti",  INST_TYPE_R1_IMM, INST_PC_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xBC800000, OPCODE_MASK_H1, bgti, branch_inst },
+  {"bgtid", INST_TYPE_R1_IMM, INST_PC_OFFSET, DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xBE800000, OPCODE_MASK_H1, bgtid, branch_inst },
+  {"bgei",  INST_TYPE_R1_IMM, INST_PC_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xBCA00000, OPCODE_MASK_H1, bgei, branch_inst },
+  {"bgeid", INST_TYPE_R1_IMM, INST_PC_OFFSET, DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xBEA00000, OPCODE_MASK_H1, bgeid, branch_inst },
+  {"lbu",   INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xC0000000, OPCODE_MASK_H4, lbu, memory_load_inst },
+  {"lhu",   INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xC4000000, OPCODE_MASK_H4, lhu, memory_load_inst },
+  {"lw",    INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xC8000000, OPCODE_MASK_H4, lw, memory_load_inst },
+  {"lwx",   INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xC8000400, OPCODE_MASK_H4, lwx, memory_load_inst },
+  {"sb",    INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xD0000000, OPCODE_MASK_H4, sb, memory_store_inst },
+  {"sh",    INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xD4000000, OPCODE_MASK_H4, sh, memory_store_inst },
+  {"sw",    INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xD8000000, OPCODE_MASK_H4, sw, memory_store_inst },
+  {"swx",   INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xD8000400, OPCODE_MASK_H4, swx, memory_store_inst },
+  {"lbui",  INST_TYPE_RD_R1_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xE0000000, OPCODE_MASK_H, lbui, memory_load_inst },
+  {"lhui",  INST_TYPE_RD_R1_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xE4000000, OPCODE_MASK_H, lhui, memory_load_inst },
+  {"lwi",   INST_TYPE_RD_R1_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xE8000000, OPCODE_MASK_H, lwi, memory_load_inst },
+  {"sbi",   INST_TYPE_RD_R1_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xF0000000, OPCODE_MASK_H, sbi, memory_store_inst },
+  {"shi",   INST_TYPE_RD_R1_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xF4000000, OPCODE_MASK_H, shi, memory_store_inst },
+  {"swi",   INST_TYPE_RD_R1_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xF8000000, OPCODE_MASK_H, swi, memory_store_inst },
+  {"nop",   INST_TYPE_NONE, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x80000000, OPCODE_MASK_H1234, invalid_inst, logical_inst }, /* translates to or r0, r0, r0 */
+  {"la",    INST_TYPE_RD_R1_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x30000000, OPCODE_MASK_H, invalid_inst, arithmetic_inst }, /* la translates to addik */
+  {"tuqula",INST_TYPE_RD, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x3000002A, OPCODE_MASK_H, invalid_inst, arithmetic_inst }, /* tuqula rd translates to addik rd, r0, 42 */
+  {"not",   INST_TYPE_RD_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xA800FFFF, OPCODE_MASK_H34, invalid_inst, logical_inst }, /* not translates to xori rd,ra,-1 */
+  {"neg",   INST_TYPE_RD_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x04000000, OPCODE_MASK_H, invalid_inst, arithmetic_inst }, /* neg translates to rsub rd, ra, r0 */
+  {"rtb",   INST_TYPE_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xB6000004, OPCODE_MASK_H1, invalid_inst, return_inst }, /* rtb translates to rts rd, 4 */
+  {"sub",   INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x04000000, OPCODE_MASK_H, invalid_inst, arithmetic_inst }, /* sub translates to rsub rd, rb, ra */
+  {"lmi",   INST_TYPE_RD_R1_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xE8000000, OPCODE_MASK_H, invalid_inst, memory_load_inst },
+  {"smi",   INST_TYPE_RD_R1_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xF8000000, OPCODE_MASK_H, invalid_inst, memory_store_inst },
+  {"msrset",INST_TYPE_RD_IMM14, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x94100000, OPCODE_MASK_H23N, msrset, special_inst },
+  {"msrclr",INST_TYPE_RD_IMM14, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x94110000, OPCODE_MASK_H23N, msrclr, special_inst },
+  {"fadd",  INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x58000000, OPCODE_MASK_H4, fadd, arithmetic_inst },
+  {"fsub",  INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x58000080, OPCODE_MASK_H4, fsub, arithmetic_inst },
+  {"fmul",  INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x58000100, OPCODE_MASK_H4, fmul, arithmetic_inst },
+  {"fdiv",  INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x58000180, OPCODE_MASK_H4, fdiv, arithmetic_inst },
+  {"fcmp.lt", INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x58000210, OPCODE_MASK_H4, fcmp_lt, arithmetic_inst },
+  {"fcmp.eq", INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x58000220, OPCODE_MASK_H4, fcmp_eq, arithmetic_inst },
+  {"fcmp.le", INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x58000230, OPCODE_MASK_H4, fcmp_le, arithmetic_inst },
+  {"fcmp.gt", INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x58000240, OPCODE_MASK_H4, fcmp_gt, arithmetic_inst },
+  {"fcmp.ne", INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x58000250, OPCODE_MASK_H4, fcmp_ne, arithmetic_inst },
+  {"fcmp.ge", INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x58000260, OPCODE_MASK_H4, fcmp_ge, arithmetic_inst },
+  {"fcmp.un", INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x58000200, OPCODE_MASK_H4, fcmp_un, arithmetic_inst },
+  {"", 0, 0, 0, 0, 0, 0, 0, 0}
+};
+
+/* prefix for register names */
+char register_prefix[] = "r";
+char special_register_prefix[] = "spr";
+char fsl_register_prefix[] = "rfsl";
+
+
+/* #defines for valid immediate range */
+#define MIN_IMM  0x80000000
+#define MAX_IMM  0x7fffffff 
+
+#define MIN_IMM12  0x000
+#define MAX_IMM12  0x7ff
+
+#define MIN_IMM14  0x0000
+#define MAX_IMM14  0x1fff
+
+#endif /* MICROBLAZE_OPC */
+
diff --git a/opcodes/microblaze-opcm.h b/opcodes/microblaze-opcm.h
new file mode 100644
index 0000000..4dffdf8
--- /dev/null
+++ b/opcodes/microblaze-opcm.h
@@ -0,0 +1,99 @@
+#ifndef MICROBLAZE_OPCM
+#define MICROBLAZE_OPCM
+
+/*
+ * Copyright (c) 2001 Xilinx, Inc.  All rights reserved. 
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by Xilinx, Inc.  The name of the Company may not be used to endorse 
+ * or promote products derived from this software without specific prior 
+ * written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ *	Xilinx, Inc.
+ * $Header:
+ */
+
+#include "bfd.h"
+
+extern unsigned long microblaze_get_target_address (long, bfd_boolean, int, long, 
+    long, long, bfd_boolean *, bfd_boolean *);
+
+enum microblaze_instr {
+   add, rsub, addc, rsubc, addk, rsubk, addkc, rsubkc, cmp, cmpu,
+   addi, rsubi, addic, rsubic, addik, rsubik, addikc, rsubikc, mul,
+   idiv, idivu, bsll, bsra, bsrl, get, put, nget, nput, cget, cput,
+   ncget, ncput, muli, bslli, bsrai, bsrli, mului, or, and, xor,
+   andn, pcmpbf, pcmpbc, pcmpeq, pcmpne, sra, src, srl, sext8, sext16, wic, wdc, wdcclear, wdcflush, mts, mfs, br, brd,
+   brld, bra, brad, brald, microblaze_brk, beq, beqd, bne, bned, blt,
+   bltd, ble, bled, bgt, bgtd, bge, bged, ori, andi, xori, andni,
+   imm, rtsd, rtid, rtbd, rted, bri, brid, brlid, brai, braid, bralid,
+   brki, beqi, beqid, bnei, bneid, blti, bltid, blei, bleid, bgti,
+   bgtid, bgei, bgeid, lbu, lhu, lw, lwx, sb, sh, sw, swx, lbui, lhui, lwi,
+   sbi, shi, swi, msrset, msrclr, tuqula, fadd, fsub, fmul, fdiv, 
+   fcmp_lt, fcmp_eq, fcmp_le, fcmp_gt, fcmp_ne, fcmp_ge, fcmp_un, invalid_inst } ;
+
+enum microblaze_instr_type {
+   arithmetic_inst, logical_inst, mult_inst, div_inst, branch_inst,
+   return_inst, immediate_inst, special_inst, memory_load_inst,
+   memory_store_inst, barrel_shift_inst, anyware_inst };
+
+#define INST_WORD_SIZE 4
+
+/* gen purpose regs go from 0 to 31 */
+/* mask is reg num - max_reg_num, ie reg_num - 32 in this case */
+
+#define REG_PC_MASK 0x8000
+#define REG_MSR_MASK 0x8001
+#define REG_EAR_MASK 0x8003
+#define REG_ESR_MASK 0x8005
+#define REG_FSR_MASK 0x8007
+#define REG_BTR_MASK 0x800B
+
+#define REG_PVR0_MASK 0xA000
+
+#define MIN_REGNUM 0
+#define MAX_REGNUM 31
+
+#define REG_PC  32 /* PC */
+#define REG_MSR 33 /* machine status reg */
+#define REG_EAR 35 /* Exception reg */
+#define REG_ESR 37 /* Exception reg */
+#define REG_FSR 39 /* FPU Status reg */
+
+/* alternate names for gen purpose regs */
+#define REG_SP  1 /* stack pointer */
+#define REG_ROSDP 2 /* read-only small data pointer */
+#define REG_RWSDP 13 /* read-write small data pointer */
+
+/* Assembler Register - Used in Delay Slot Optimization */
+#define REG_AS    18
+#define REG_ZERO  0
+ 
+#define RD_LOW  21 /* low bit for RD */
+#define RA_LOW  16 /* low bit for RA */
+#define RB_LOW  11 /* low bit for RB */
+#define IMM_LOW  0 /* low bit for immediate */
+
+#define RD_MASK 0x03E00000
+#define RA_MASK 0x001F0000
+#define RB_MASK 0x0000F800
+#define IMM_MASK 0x0000FFFF
+
+// imm mask for barrel shifts
+#define IMM5_MASK 0x0000001F
+
+
+// imm mask for get, put instructions
+#define  IMM12_MASK 0x00000FFF
+
+// imm mask for msrset, msrclr instructions
+#define  IMM14_MASK 0x00003FFF
+
+#endif /* MICROBLAZE-OPCM */
diff --git a/sim/microblaze/Makefile.in b/sim/microblaze/Makefile.in
new file mode 100644
index 0000000..3d405a2
--- /dev/null
+++ b/sim/microblaze/Makefile.in
@@ -0,0 +1,27 @@
+#    Makefile template for Configure for the Xilinx microblaze sim library.
+#    Copyright (C) 1990, 91, 92, 95, 96, 19, 1999 Free Software Foundation, Inc.
+#    Written by Cygnus Solutions.
+# 
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+## COMMON_PRE_CONFIG_FRAG
+
+SIM_OBJS = interp.o $(SIM_NEW_COMMON_OBJS) sim-load.o sim-break.o 
+SIM_EXTRA_LIBS = -lm
+
+## COMMON_POST_CONFIG_FRAG
+
+interp.o: interp.c sim-main.h microblaze.isa microblaze.h
+
diff --git a/sim/microblaze/config.in b/sim/microblaze/config.in
new file mode 100644
index 0000000..21724bc
--- /dev/null
+++ b/sim/microblaze/config.in
@@ -0,0 +1,34 @@
+/* config.in.  Generated automatically from configure.in by autoheader.  */
+
+/* Define as the return type of signal handlers (int or void).  */
+#undef RETSIGTYPE
+
+/* Define if you have the getrusage function.  */
+#undef HAVE_GETRUSAGE
+
+/* Define if you have the sigaction function.  */
+#undef HAVE_SIGACTION
+
+/* Define if you have the time function.  */
+#undef HAVE_TIME
+
+/* Define if you have the <stdlib.h> header file.  */
+#undef HAVE_STDLIB_H
+
+/* Define if you have the <string.h> header file.  */
+#undef HAVE_STRING_H
+
+/* Define if you have the <strings.h> header file.  */
+#undef HAVE_STRINGS_H
+
+/* Define if you have the <sys/resource.h> header file.  */
+#undef HAVE_SYS_RESOURCE_H
+
+/* Define if you have the <sys/time.h> header file.  */
+#undef HAVE_SYS_TIME_H
+
+/* Define if you have the <time.h> header file.  */
+#undef HAVE_TIME_H
+
+/* Define if you have the <unistd.h> header file.  */
+#undef HAVE_UNISTD_H
diff --git a/sim/microblaze/configure b/sim/microblaze/configure
new file mode 100644
index 0000000..ccca2cb
--- /dev/null
+++ b/sim/microblaze/configure
@@ -0,0 +1,4013 @@
+#! /bin/sh
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+sim_inline="-DDEFAULT_INLINE=0"
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# This file is derived from `gettext.m4'.  The difference is that the
+# included macros assume Cygnus-style source and build trees.
+
+# Macro to add for using GNU gettext.
+# Ulrich Drepper <drepper@cygnus.com>, 1995.
+#
+# This file file be copied and used freely without restrictions.  It can
+# be used in projects which are not available under the GNU Public License
+# but which still want to provide support for the GNU gettext functionality.
+# Please note that the actual code is *not* freely available.
+
+# serial 3
+
+
+
+
+
+# Search path for a program which passes the given test.
+# Ulrich Drepper <drepper@cygnus.com>, 1996.
+#
+# This file file be copied and used freely without restrictions.  It can
+# be used in projects which are not available under the GNU Public License
+# but which still want to provide support for the GNU gettext functionality.
+# Please note that the actual code is *not* freely available.
+
+# serial 1
+
+
+
+# Check whether LC_MESSAGES is available in <locale.h>.
+# Ulrich Drepper <drepper@cygnus.com>, 1995.
+#
+# This file file be copied and used freely without restrictions.  It can
+# be used in projects which are not available under the GNU Public License
+# but which still want to provide support for the GNU gettext functionality.
+# Please note that the actual code is *not* freely available.
+
+# serial 1
+
+
+
+
+
+
+# Guess values for system-dependent variables and create Makefiles.
+# Generated automatically using autoconf version 2.13 
+# Copyright (C) 1992, 93, 94, 95, 96 Free Software Foundation, Inc.
+#
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+
+# Defaults:
+ac_help=
+ac_default_prefix=/usr/local
+# Any additions from configure.in:
+ac_help="$ac_help
+  --disable-nls           do not use Native Language Support"
+ac_help="$ac_help
+  --with-included-gettext use the GNU gettext library included here"
+ac_help="$ac_help
+  --enable-maintainer-mode		Enable developer functionality."
+ac_help="$ac_help
+  --enable-sim-bswap			Use Host specific BSWAP instruction."
+ac_help="$ac_help
+  --enable-sim-cflags=opts		Extra CFLAGS for use in building simulator"
+ac_help="$ac_help
+  --enable-sim-debug=opts		Enable debugging flags"
+ac_help="$ac_help
+  --enable-sim-stdio			Specify whether to use stdio for console input/output."
+ac_help="$ac_help
+  --enable-sim-trace=opts		Enable tracing flags"
+ac_help="$ac_help
+  --enable-sim-profile=opts		Enable profiling flags"
+
+# Initialize some variables set by options.
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+build=NONE
+cache_file=./config.cache
+exec_prefix=NONE
+host=NONE
+no_create=
+nonopt=NONE
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+target=NONE
+verbose=
+x_includes=NONE
+x_libraries=NONE
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datadir='${prefix}/share'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+libdir='${exec_prefix}/lib'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+infodir='${prefix}/info'
+mandir='${prefix}/man'
+
+# Initialize some other variables.
+subdirs=
+MFLAGS= MAKEFLAGS=
+SHELL=${CONFIG_SHELL-/bin/sh}
+# Maximum number of lines to put in a shell here document.
+ac_max_here_lines=12
+
+ac_prev=
+for ac_option
+do
+
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval "$ac_prev=\$ac_option"
+    ac_prev=
+    continue
+  fi
+
+  case "$ac_option" in
+  -*=*) ac_optarg=`echo "$ac_option" | sed 's/[-_a-zA-Z0-9]*=//'` ;;
+  *) ac_optarg= ;;
+  esac
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case "$ac_option" in
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir="$ac_optarg" ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build="$ac_optarg" ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file="$ac_optarg" ;;
+
+  -datadir | --datadir | --datadi | --datad | --data | --dat | --da)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=* | --data=* | --dat=* \
+  | --da=*)
+    datadir="$ac_optarg" ;;
+
+  -disable-* | --disable-*)
+    ac_feature=`echo $ac_option|sed -e 's/-*disable-//'`
+    # Reject names that are not valid shell variable names.
+    if test -n "`echo $ac_feature| sed 's/[-a-zA-Z0-9_]//g'`"; then
+      { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
+    fi
+    ac_feature=`echo $ac_feature| sed 's/-/_/g'`
+    eval "enable_${ac_feature}=no" ;;
+
+  -enable-* | --enable-*)
+    ac_feature=`echo $ac_option|sed -e 's/-*enable-//' -e 's/=.*//'`
+    # Reject names that are not valid shell variable names.
+    if test -n "`echo $ac_feature| sed 's/[-_a-zA-Z0-9]//g'`"; then
+      { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
+    fi
+    ac_feature=`echo $ac_feature| sed 's/-/_/g'`
+    case "$ac_option" in
+      *=*) ;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "enable_${ac_feature}='$ac_optarg'" ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix="$ac_optarg" ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he)
+    # Omit some internal or obsolete options to make the list less imposing.
+    # This message is too long to be a string in the A/UX 3.1 sh.
+    cat << EOF
+Usage: configure [options] [host]
+Options: [defaults in brackets after descriptions]
+Configuration:
+  --cache-file=FILE       cache test results in FILE
+  --help                  print this message
+  --no-create             do not create output files
+  --quiet, --silent       do not print \`checking...' messages
+  --version               print the version of autoconf that created configure
+Directory and file names:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+                          [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+                          [same as prefix]
+  --bindir=DIR            user executables in DIR [EPREFIX/bin]
+  --sbindir=DIR           system admin executables in DIR [EPREFIX/sbin]
+  --libexecdir=DIR        program executables in DIR [EPREFIX/libexec]
+  --datadir=DIR           read-only architecture-independent data in DIR
+                          [PREFIX/share]
+  --sysconfdir=DIR        read-only single-machine data in DIR [PREFIX/etc]
+  --sharedstatedir=DIR    modifiable architecture-independent data in DIR
+                          [PREFIX/com]
+  --localstatedir=DIR     modifiable single-machine data in DIR [PREFIX/var]
+  --libdir=DIR            object code libraries in DIR [EPREFIX/lib]
+  --includedir=DIR        C header files in DIR [PREFIX/include]
+  --oldincludedir=DIR     C header files for non-gcc in DIR [/usr/include]
+  --infodir=DIR           info documentation in DIR [PREFIX/info]
+  --mandir=DIR            man documentation in DIR [PREFIX/man]
+  --srcdir=DIR            find the sources in DIR [configure dir or ..]
+  --program-prefix=PREFIX prepend PREFIX to installed program names
+  --program-suffix=SUFFIX append SUFFIX to installed program names
+  --program-transform-name=PROGRAM
+                          run sed PROGRAM on installed program names
+EOF
+    cat << EOF
+Host type:
+  --build=BUILD           configure for building on BUILD [BUILD=HOST]
+  --host=HOST             configure for HOST [guessed]
+  --target=TARGET         configure for TARGET [TARGET=HOST]
+Features and packages:
+  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --x-includes=DIR        X include files are in DIR
+  --x-libraries=DIR       X library files are in DIR
+EOF
+    if test -n "$ac_help"; then
+      echo "--enable and --with options recognized:$ac_help"
+    fi
+    exit 0 ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host="$ac_optarg" ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir="$ac_optarg" ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir="$ac_optarg" ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir="$ac_optarg" ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir="$ac_optarg" ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst \
+  | --locals | --local | --loca | --loc | --lo)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* \
+  | --locals=* | --local=* | --loca=* | --loc=* | --lo=*)
+    localstatedir="$ac_optarg" ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir="$ac_optarg" ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir="$ac_optarg" ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix="$ac_optarg" ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix="$ac_optarg" ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix="$ac_optarg" ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name="$ac_optarg" ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir="$ac_optarg" ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir="$ac_optarg" ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site="$ac_optarg" ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir="$ac_optarg" ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir="$ac_optarg" ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target="$ac_optarg" ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers)
+    echo "configure generated by autoconf version 2.13"
+    exit 0 ;;
+
+  -with-* | --with-*)
+    ac_package=`echo $ac_option|sed -e 's/-*with-//' -e 's/=.*//'`
+    # Reject names that are not valid shell variable names.
+    if test -n "`echo $ac_package| sed 's/[-_a-zA-Z0-9]//g'`"; then
+      { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
+    fi
+    ac_package=`echo $ac_package| sed 's/-/_/g'`
+    case "$ac_option" in
+      *=*) ;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "with_${ac_package}='$ac_optarg'" ;;
+
+  -without-* | --without-*)
+    ac_package=`echo $ac_option|sed -e 's/-*without-//'`
+    # Reject names that are not valid shell variable names.
+    if test -n "`echo $ac_package| sed 's/[-a-zA-Z0-9_]//g'`"; then
+      { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
+    fi
+    ac_package=`echo $ac_package| sed 's/-/_/g'`
+    eval "with_${ac_package}=no" ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes="$ac_optarg" ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries="$ac_optarg" ;;
+
+  -*) { echo "configure: error: $ac_option: invalid option; use --help to show usage" 1>&2; exit 1; }
+    ;;
+
+  *)
+    if test -n "`echo $ac_option| sed 's/[-a-z0-9.]//g'`"; then
+      echo "configure: warning: $ac_option: invalid host type" 1>&2
+    fi
+    if test "x$nonopt" != xNONE; then
+      { echo "configure: error: can only configure for one host and one target at a time" 1>&2; exit 1; }
+    fi
+    nonopt="$ac_option"
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  { echo "configure: error: missing argument to --`echo $ac_prev | sed 's/_/-/g'`" 1>&2; exit 1; }
+fi
+
+trap 'rm -fr conftest* confdefs* core core.* *.core $ac_clean_files; exit 1' 1 2 15
+
+# File descriptor usage:
+# 0 standard input
+# 1 file creation
+# 2 errors and warnings
+# 3 some systems may open it to /dev/tty
+# 4 used on the Kubota Titan
+# 6 checking for... messages and results
+# 5 compiler messages saved in config.log
+if test "$silent" = yes; then
+  exec 6>/dev/null
+else
+  exec 6>&1
+fi
+exec 5>./config.log
+
+echo "\
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+" 1>&5
+
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Also quote any args containing shell metacharacters.
+ac_configure_args=
+for ac_arg
+do
+  case "$ac_arg" in
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c) ;;
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r) ;;
+  *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?]*)
+  ac_configure_args="$ac_configure_args '$ac_arg'" ;;
+  *) ac_configure_args="$ac_configure_args $ac_arg" ;;
+  esac
+done
+
+# NLS nuisances.
+# Only set these to C if already set.  These must not be set unconditionally
+# because not all systems understand e.g. LANG=C (notably SCO).
+# Fixing LC_MESSAGES prevents Solaris sh from translating var values in `set'!
+# Non-C LC_CTYPE values break the ctype check.
+if test "${LANG+set}"   = set; then LANG=C;   export LANG;   fi
+if test "${LC_ALL+set}" = set; then LC_ALL=C; export LC_ALL; fi
+if test "${LC_MESSAGES+set}" = set; then LC_MESSAGES=C; export LC_MESSAGES; fi
+if test "${LC_CTYPE+set}"    = set; then LC_CTYPE=C;    export LC_CTYPE;    fi
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -rf conftest* confdefs.h
+# AIX cpp loses on an empty file, so make sure it contains at least a newline.
+echo > confdefs.h
+
+# A filename unique to this package, relative to the directory that
+# configure is in, which we can look for to find out if srcdir is correct.
+ac_unique_file=Makefile.in
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then its parent.
+  ac_prog=$0
+  ac_confdir=`echo $ac_prog|sed 's%/[^/][^/]*$%%'`
+  test "x$ac_confdir" = "x$ac_prog" && ac_confdir=.
+  srcdir=$ac_confdir
+  if test ! -r $srcdir/$ac_unique_file; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r $srcdir/$ac_unique_file; then
+  if test "$ac_srcdir_defaulted" = yes; then
+    { echo "configure: error: can not find sources in $ac_confdir or .." 1>&2; exit 1; }
+  else
+    { echo "configure: error: can not find sources in $srcdir" 1>&2; exit 1; }
+  fi
+fi
+srcdir=`echo "${srcdir}" | sed 's%\([^/]\)/*$%\1%'`
+
+# Prefer explicitly selected file to automatically selected ones.
+if test -z "$CONFIG_SITE"; then
+  if test "x$prefix" != xNONE; then
+    CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
+  else
+    CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
+  fi
+fi
+for ac_site_file in $CONFIG_SITE; do
+  if test -r "$ac_site_file"; then
+    echo "loading site script $ac_site_file"
+    . "$ac_site_file"
+  fi
+done
+
+if test -r "$cache_file"; then
+  echo "loading cache $cache_file"
+  . $cache_file
+else
+  echo "creating cache $cache_file"
+  > $cache_file
+fi
+
+ac_ext=c
+# CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
+ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
+cross_compiling=$ac_cv_prog_cc_cross
+
+ac_exeext=
+ac_objext=o
+if (echo "testing\c"; echo 1,2,3) | grep c >/dev/null; then
+  # Stardent Vistra SVR4 grep lacks -e, says ghazi@caip.rutgers.edu.
+  if (echo -n testing; echo 1,2,3) | sed s/-n/xn/ | grep xn >/dev/null; then
+    ac_n= ac_c='
+' ac_t='	'
+  else
+    ac_n=-n ac_c= ac_t=
+  fi
+else
+  ac_n= ac_c='\c' ac_t=
+fi
+
+
+
+echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
+echo "configure:668: checking how to run the C preprocessor" >&5
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+if eval "test \"`echo '$''{'ac_cv_prog_CPP'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+    # This must be in double quotes, not single quotes, because CPP may get
+  # substituted into the Makefile and "${CC-cc}" will confuse make.
+  CPP="${CC-cc} -E"
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp.
+  cat > conftest.$ac_ext <<EOF
+#line 683 "configure"
+#include "confdefs.h"
+#include <assert.h>
+Syntax Error
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:689: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  :
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  CPP="${CC-cc} -E -traditional-cpp"
+  cat > conftest.$ac_ext <<EOF
+#line 700 "configure"
+#include "confdefs.h"
+#include <assert.h>
+Syntax Error
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:706: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  :
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  CPP="${CC-cc} -nologo -E"
+  cat > conftest.$ac_ext <<EOF
+#line 717 "configure"
+#include "confdefs.h"
+#include <assert.h>
+Syntax Error
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:723: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  :
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  CPP=/lib/cpp
+fi
+rm -f conftest*
+fi
+rm -f conftest*
+fi
+rm -f conftest*
+  ac_cv_prog_CPP="$CPP"
+fi
+  CPP="$ac_cv_prog_CPP"
+else
+  ac_cv_prog_CPP="$CPP"
+fi
+echo "$ac_t""$CPP" 1>&6
+
+echo $ac_n "checking whether ${MAKE-make} sets \${MAKE}""... $ac_c" 1>&6
+echo "configure:748: checking whether ${MAKE-make} sets \${MAKE}" >&5
+set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftestmake <<\EOF
+all:
+	@echo 'ac_maketemp="${MAKE}"'
+EOF
+# GNU make sometimes prints "make[1]: Entering...", which would confuse us.
+eval `${MAKE-make} -f conftestmake 2>/dev/null | grep temp=`
+if test -n "$ac_maketemp"; then
+  eval ac_cv_prog_make_${ac_make}_set=yes
+else
+  eval ac_cv_prog_make_${ac_make}_set=no
+fi
+rm -f conftestmake
+fi
+if eval "test \"`echo '$ac_cv_prog_make_'${ac_make}_set`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  SET_MAKE=
+else
+  echo "$ac_t""no" 1>&6
+  SET_MAKE="MAKE=${MAKE-make}"
+fi
+
+echo $ac_n "checking for POSIXized ISC""... $ac_c" 1>&6
+echo "configure:775: checking for POSIXized ISC" >&5
+if test -d /etc/conf/kconfig.d &&
+  grep _POSIX_VERSION /usr/include/sys/unistd.h >/dev/null 2>&1
+then
+  echo "$ac_t""yes" 1>&6
+  ISC=yes # If later tests want to check for ISC.
+  cat >> confdefs.h <<\EOF
+#define _POSIX_SOURCE 1
+EOF
+
+  if test "$GCC" = yes; then
+    CC="$CC -posix"
+  else
+    CC="$CC -Xp"
+  fi
+else
+  echo "$ac_t""no" 1>&6
+  ISC=
+fi
+
+echo $ac_n "checking for ANSI C header files""... $ac_c" 1>&6
+echo "configure:796: checking for ANSI C header files" >&5
+if eval "test \"`echo '$''{'ac_cv_header_stdc'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 801 "configure"
+#include "confdefs.h"
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:809: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  ac_cv_header_stdc=yes
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+cat > conftest.$ac_ext <<EOF
+#line 826 "configure"
+#include "confdefs.h"
+#include <string.h>
+EOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "memchr" >/dev/null 2>&1; then
+  :
+else
+  rm -rf conftest*
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+cat > conftest.$ac_ext <<EOF
+#line 844 "configure"
+#include "confdefs.h"
+#include <stdlib.h>
+EOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "free" >/dev/null 2>&1; then
+  :
+else
+  rm -rf conftest*
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+if test "$cross_compiling" = yes; then
+  :
+else
+  cat > conftest.$ac_ext <<EOF
+#line 865 "configure"
+#include "confdefs.h"
+#include <ctype.h>
+#define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+#define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int main () { int i; for (i = 0; i < 256; i++)
+if (XOR (islower (i), ISLOWER (i)) || toupper (i) != TOUPPER (i)) exit(2);
+exit (0); }
+
+EOF
+if { (eval echo configure:876: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+then
+  :
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  ac_cv_header_stdc=no
+fi
+rm -fr conftest*
+fi
+
+fi
+fi
+
+echo "$ac_t""$ac_cv_header_stdc" 1>&6
+if test $ac_cv_header_stdc = yes; then
+  cat >> confdefs.h <<\EOF
+#define STDC_HEADERS 1
+EOF
+
+fi
+
+echo $ac_n "checking for working const""... $ac_c" 1>&6
+echo "configure:900: checking for working const" >&5
+if eval "test \"`echo '$''{'ac_cv_c_const'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 905 "configure"
+#include "confdefs.h"
+
+int main() {
+
+/* Ultrix mips cc rejects this.  */
+typedef int charset[2]; const charset x;
+/* SunOS 4.1.1 cc rejects this.  */
+char const *const *ccp;
+char **p;
+/* NEC SVR4.0.2 mips cc rejects this.  */
+struct point {int x, y;};
+static struct point const zero = {0,0};
+/* AIX XL C 1.02.0.0 rejects this.
+   It does not let you subtract one const X* pointer from another in an arm
+   of an if-expression whose if-part is not a constant expression */
+const char *g = "string";
+ccp = &g + (g ? g-g : 0);
+/* HPUX 7.0 cc rejects these. */
+++ccp;
+p = (char**) ccp;
+ccp = (char const *const *) p;
+{ /* SCO 3.2v4 cc rejects this.  */
+  char *t;
+  char const *s = 0 ? (char *) 0 : (char const *) 0;
+
+  *t++ = 0;
+}
+{ /* Someone thinks the Sun supposedly-ANSI compiler will reject this.  */
+  int x[] = {25, 17};
+  const int *foo = &x[0];
+  ++foo;
+}
+{ /* Sun SC1.0 ANSI compiler rejects this -- but not the above. */
+  typedef const int *iptr;
+  iptr p = 0;
+  ++p;
+}
+{ /* AIX XL C 1.02.0.0 rejects this saying
+     "k.c", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
+  struct s { int j; const int *ap[3]; };
+  struct s *b; b->j = 5;
+}
+{ /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
+  const int foo = 10;
+}
+
+; return 0; }
+EOF
+if { (eval echo configure:954: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_c_const=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_c_const=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$ac_cv_c_const" 1>&6
+if test $ac_cv_c_const = no; then
+  cat >> confdefs.h <<\EOF
+#define const 
+EOF
+
+fi
+
+echo $ac_n "checking for inline""... $ac_c" 1>&6
+echo "configure:975: checking for inline" >&5
+if eval "test \"`echo '$''{'ac_cv_c_inline'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_cv_c_inline=no
+for ac_kw in inline __inline__ __inline; do
+  cat > conftest.$ac_ext <<EOF
+#line 982 "configure"
+#include "confdefs.h"
+
+int main() {
+} $ac_kw foo() {
+; return 0; }
+EOF
+if { (eval echo configure:989: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_c_inline=$ac_kw; break
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+fi
+rm -f conftest*
+done
+
+fi
+
+echo "$ac_t""$ac_cv_c_inline" 1>&6
+case "$ac_cv_c_inline" in
+  inline | yes) ;;
+  no) cat >> confdefs.h <<\EOF
+#define inline 
+EOF
+ ;;
+  *)  cat >> confdefs.h <<EOF
+#define inline $ac_cv_c_inline
+EOF
+ ;;
+esac
+
+echo $ac_n "checking for off_t""... $ac_c" 1>&6
+echo "configure:1015: checking for off_t" >&5
+if eval "test \"`echo '$''{'ac_cv_type_off_t'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1020 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#if STDC_HEADERS
+#include <stdlib.h>
+#include <stddef.h>
+#endif
+EOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "(^|[^a-zA-Z_0-9])off_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
+  rm -rf conftest*
+  ac_cv_type_off_t=yes
+else
+  rm -rf conftest*
+  ac_cv_type_off_t=no
+fi
+rm -f conftest*
+
+fi
+echo "$ac_t""$ac_cv_type_off_t" 1>&6
+if test $ac_cv_type_off_t = no; then
+  cat >> confdefs.h <<\EOF
+#define off_t long
+EOF
+
+fi
+
+echo $ac_n "checking for size_t""... $ac_c" 1>&6
+echo "configure:1048: checking for size_t" >&5
+if eval "test \"`echo '$''{'ac_cv_type_size_t'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1053 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#if STDC_HEADERS
+#include <stdlib.h>
+#include <stddef.h>
+#endif
+EOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "(^|[^a-zA-Z_0-9])size_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
+  rm -rf conftest*
+  ac_cv_type_size_t=yes
+else
+  rm -rf conftest*
+  ac_cv_type_size_t=no
+fi
+rm -f conftest*
+
+fi
+echo "$ac_t""$ac_cv_type_size_t" 1>&6
+if test $ac_cv_type_size_t = no; then
+  cat >> confdefs.h <<\EOF
+#define size_t unsigned
+EOF
+
+fi
+
+# The Ultrix 4.2 mips builtin alloca declared by alloca.h only works
+# for constant arguments.  Useless!
+echo $ac_n "checking for working alloca.h""... $ac_c" 1>&6
+echo "configure:1083: checking for working alloca.h" >&5
+if eval "test \"`echo '$''{'ac_cv_header_alloca_h'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1088 "configure"
+#include "confdefs.h"
+#include <alloca.h>
+int main() {
+char *p = alloca(2 * sizeof(int));
+; return 0; }
+EOF
+if { (eval echo configure:1095: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  ac_cv_header_alloca_h=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_header_alloca_h=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$ac_cv_header_alloca_h" 1>&6
+if test $ac_cv_header_alloca_h = yes; then
+  cat >> confdefs.h <<\EOF
+#define HAVE_ALLOCA_H 1
+EOF
+
+fi
+
+echo $ac_n "checking for alloca""... $ac_c" 1>&6
+echo "configure:1116: checking for alloca" >&5
+if eval "test \"`echo '$''{'ac_cv_func_alloca_works'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1121 "configure"
+#include "confdefs.h"
+
+#ifdef __GNUC__
+# define alloca __builtin_alloca
+#else
+# ifdef _MSC_VER
+#  include <malloc.h>
+#  define alloca _alloca
+# else
+#  if HAVE_ALLOCA_H
+#   include <alloca.h>
+#  else
+#   ifdef _AIX
+ #pragma alloca
+#   else
+#    ifndef alloca /* predefined by HP cc +Olibcalls */
+char *alloca ();
+#    endif
+#   endif
+#  endif
+# endif
+#endif
+
+int main() {
+char *p = (char *) alloca(1);
+; return 0; }
+EOF
+if { (eval echo configure:1149: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  ac_cv_func_alloca_works=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_func_alloca_works=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$ac_cv_func_alloca_works" 1>&6
+if test $ac_cv_func_alloca_works = yes; then
+  cat >> confdefs.h <<\EOF
+#define HAVE_ALLOCA 1
+EOF
+
+fi
+
+if test $ac_cv_func_alloca_works = no; then
+  # The SVR3 libPW and SVR4 libucb both contain incompatible functions
+  # that cause trouble.  Some versions do not even contain alloca or
+  # contain a buggy version.  If you still want to use their alloca,
+  # use ar to extract alloca.o from them instead of compiling alloca.c.
+  ALLOCA=alloca.${ac_objext}
+  cat >> confdefs.h <<\EOF
+#define C_ALLOCA 1
+EOF
+
+
+echo $ac_n "checking whether alloca needs Cray hooks""... $ac_c" 1>&6
+echo "configure:1181: checking whether alloca needs Cray hooks" >&5
+if eval "test \"`echo '$''{'ac_cv_os_cray'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1186 "configure"
+#include "confdefs.h"
+#if defined(CRAY) && ! defined(CRAY2)
+webecray
+#else
+wenotbecray
+#endif
+
+EOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "webecray" >/dev/null 2>&1; then
+  rm -rf conftest*
+  ac_cv_os_cray=yes
+else
+  rm -rf conftest*
+  ac_cv_os_cray=no
+fi
+rm -f conftest*
+
+fi
+
+echo "$ac_t""$ac_cv_os_cray" 1>&6
+if test $ac_cv_os_cray = yes; then
+for ac_func in _getb67 GETB67 getb67; do
+  echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
+echo "configure:1211: checking for $ac_func" >&5
+if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1216 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char $ac_func();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+$ac_func();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:1239: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  cat >> confdefs.h <<EOF
+#define CRAY_STACKSEG_END $ac_func
+EOF
+
+  break
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+done
+fi
+
+echo $ac_n "checking stack direction for C alloca""... $ac_c" 1>&6
+echo "configure:1266: checking stack direction for C alloca" >&5
+if eval "test \"`echo '$''{'ac_cv_c_stack_direction'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_c_stack_direction=0
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1274 "configure"
+#include "confdefs.h"
+find_stack_direction ()
+{
+  static char *addr = 0;
+  auto char dummy;
+  if (addr == 0)
+    {
+      addr = &dummy;
+      return find_stack_direction ();
+    }
+  else
+    return (&dummy > addr) ? 1 : -1;
+}
+main ()
+{
+  exit (find_stack_direction() < 0);
+}
+EOF
+if { (eval echo configure:1293: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+then
+  ac_cv_c_stack_direction=1
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  ac_cv_c_stack_direction=-1
+fi
+rm -fr conftest*
+fi
+
+fi
+
+echo "$ac_t""$ac_cv_c_stack_direction" 1>&6
+cat >> confdefs.h <<EOF
+#define STACK_DIRECTION $ac_cv_c_stack_direction
+EOF
+
+fi
+
+for ac_hdr in unistd.h
+do
+ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
+echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
+echo "configure:1318: checking for $ac_hdr" >&5
+if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1323 "configure"
+#include "confdefs.h"
+#include <$ac_hdr>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:1328: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=yes"
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=no"
+fi
+rm -f conftest*
+fi
+if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_hdr 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+for ac_func in getpagesize
+do
+echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
+echo "configure:1357: checking for $ac_func" >&5
+if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1362 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char $ac_func();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+$ac_func();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:1385: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_func 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+echo $ac_n "checking for working mmap""... $ac_c" 1>&6
+echo "configure:1410: checking for working mmap" >&5
+if eval "test \"`echo '$''{'ac_cv_func_mmap_fixed_mapped'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_func_mmap_fixed_mapped=no
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1418 "configure"
+#include "confdefs.h"
+
+/* Thanks to Mike Haertel and Jim Avera for this test.
+   Here is a matrix of mmap possibilities:
+	mmap private not fixed
+	mmap private fixed at somewhere currently unmapped
+	mmap private fixed at somewhere already mapped
+	mmap shared not fixed
+	mmap shared fixed at somewhere currently unmapped
+	mmap shared fixed at somewhere already mapped
+   For private mappings, we should verify that changes cannot be read()
+   back from the file, nor mmap's back from the file at a different
+   address.  (There have been systems where private was not correctly
+   implemented like the infamous i386 svr4.0, and systems where the
+   VM page cache was not coherent with the filesystem buffer cache
+   like early versions of FreeBSD and possibly contemporary NetBSD.)
+   For shared mappings, we should conversely verify that changes get
+   propogated back to all the places they're supposed to be.
+
+   Grep wants private fixed already mapped.
+   The main things grep needs to know about mmap are:
+   * does it exist and is it safe to write into the mmap'd area
+   * how to use it (BSD variants)  */
+#include <sys/types.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+
+/* This mess was copied from the GNU getpagesize.h.  */
+#ifndef HAVE_GETPAGESIZE
+# ifdef HAVE_UNISTD_H
+#  include <unistd.h>
+# endif
+
+/* Assume that all systems that can run configure have sys/param.h.  */
+# ifndef HAVE_SYS_PARAM_H
+#  define HAVE_SYS_PARAM_H 1
+# endif
+
+# ifdef _SC_PAGESIZE
+#  define getpagesize() sysconf(_SC_PAGESIZE)
+# else /* no _SC_PAGESIZE */
+#  ifdef HAVE_SYS_PARAM_H
+#   include <sys/param.h>
+#   ifdef EXEC_PAGESIZE
+#    define getpagesize() EXEC_PAGESIZE
+#   else /* no EXEC_PAGESIZE */
+#    ifdef NBPG
+#     define getpagesize() NBPG * CLSIZE
+#     ifndef CLSIZE
+#      define CLSIZE 1
+#     endif /* no CLSIZE */
+#    else /* no NBPG */
+#     ifdef NBPC
+#      define getpagesize() NBPC
+#     else /* no NBPC */
+#      ifdef PAGESIZE
+#       define getpagesize() PAGESIZE
+#      endif /* PAGESIZE */
+#     endif /* no NBPC */
+#    endif /* no NBPG */
+#   endif /* no EXEC_PAGESIZE */
+#  else /* no HAVE_SYS_PARAM_H */
+#   define getpagesize() 8192	/* punt totally */
+#  endif /* no HAVE_SYS_PARAM_H */
+# endif /* no _SC_PAGESIZE */
+
+#endif /* no HAVE_GETPAGESIZE */
+
+#ifdef __cplusplus
+extern "C" { void *malloc(unsigned); }
+#else
+char *malloc();
+#endif
+
+int
+main()
+{
+	char *data, *data2, *data3;
+	int i, pagesize;
+	int fd;
+
+	pagesize = getpagesize();
+
+	/*
+	 * First, make a file with some known garbage in it.
+	 */
+	data = malloc(pagesize);
+	if (!data)
+		exit(1);
+	for (i = 0; i < pagesize; ++i)
+		*(data + i) = rand();
+	umask(0);
+	fd = creat("conftestmmap", 0600);
+	if (fd < 0)
+		exit(1);
+	if (write(fd, data, pagesize) != pagesize)
+		exit(1);
+	close(fd);
+
+	/*
+	 * Next, try to mmap the file at a fixed address which
+	 * already has something else allocated at it.  If we can,
+	 * also make sure that we see the same garbage.
+	 */
+	fd = open("conftestmmap", O_RDWR);
+	if (fd < 0)
+		exit(1);
+	data2 = malloc(2 * pagesize);
+	if (!data2)
+		exit(1);
+	data2 += (pagesize - ((int) data2 & (pagesize - 1))) & (pagesize - 1);
+	if (data2 != mmap(data2, pagesize, PROT_READ | PROT_WRITE,
+	    MAP_PRIVATE | MAP_FIXED, fd, 0L))
+		exit(1);
+	for (i = 0; i < pagesize; ++i)
+		if (*(data + i) != *(data2 + i))
+			exit(1);
+
+	/*
+	 * Finally, make sure that changes to the mapped area
+	 * do not percolate back to the file as seen by read().
+	 * (This is a bug on some variants of i386 svr4.0.)
+	 */
+	for (i = 0; i < pagesize; ++i)
+		*(data2 + i) = *(data2 + i) + 1;
+	data3 = malloc(pagesize);
+	if (!data3)
+		exit(1);
+	if (read(fd, data3, pagesize) != pagesize)
+		exit(1);
+	for (i = 0; i < pagesize; ++i)
+		if (*(data + i) != *(data3 + i))
+			exit(1);
+	close(fd);
+	unlink("conftestmmap");
+	exit(0);
+}
+
+EOF
+if { (eval echo configure:1558: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+then
+  ac_cv_func_mmap_fixed_mapped=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  ac_cv_func_mmap_fixed_mapped=no
+fi
+rm -fr conftest*
+fi
+
+fi
+
+echo "$ac_t""$ac_cv_func_mmap_fixed_mapped" 1>&6
+if test $ac_cv_func_mmap_fixed_mapped = yes; then
+  cat >> confdefs.h <<\EOF
+#define HAVE_MMAP 1
+EOF
+
+fi
+
+echo $ac_n "checking for Cygwin environment""... $ac_c" 1>&6
+echo "configure:1581: checking for Cygwin environment" >&5
+if eval "test \"`echo '$''{'ac_cv_cygwin'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1586 "configure"
+#include "confdefs.h"
+
+int main() {
+
+#ifndef __CYGWIN__
+#define __CYGWIN__ __CYGWIN32__
+#endif
+return __CYGWIN__;
+; return 0; }
+EOF
+if { (eval echo configure:1597: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_cygwin=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_cygwin=no
+fi
+rm -f conftest*
+rm -f conftest*
+fi
+
+echo "$ac_t""$ac_cv_cygwin" 1>&6
+CYGWIN=
+test "$ac_cv_cygwin" = yes && CYGWIN=yes
+echo $ac_n "checking for mingw32 environment""... $ac_c" 1>&6
+echo "configure:1614: checking for mingw32 environment" >&5
+if eval "test \"`echo '$''{'ac_cv_mingw32'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1619 "configure"
+#include "confdefs.h"
+
+int main() {
+return __MINGW32__;
+; return 0; }
+EOF
+if { (eval echo configure:1626: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_mingw32=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_mingw32=no
+fi
+rm -f conftest*
+rm -f conftest*
+fi
+
+echo "$ac_t""$ac_cv_mingw32" 1>&6
+MINGW32=
+test "$ac_cv_mingw32" = yes && MINGW32=yes
+
+# autoconf.info says this should be called right after AC_INIT.
+
+
+ac_aux_dir=
+for ac_dir in `cd $srcdir;pwd`/../.. $srcdir/`cd $srcdir;pwd`/../..; do
+  if test -f $ac_dir/install-sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f $ac_dir/install.sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  { echo "configure: error: can not find install-sh or install.sh in `cd $srcdir;pwd`/../.. $srcdir/`cd $srcdir;pwd`/../.." 1>&2; exit 1; }
+fi
+ac_config_guess=$ac_aux_dir/config.guess
+ac_config_sub=$ac_aux_dir/config.sub
+ac_configure=$ac_aux_dir/configure # This should be Cygnus configure.
+
+
+# Do some error checking and defaulting for the host and target type.
+# The inputs are:
+#    configure --host=HOST --target=TARGET --build=BUILD NONOPT
+#
+# The rules are:
+# 1. You are not allowed to specify --host, --target, and nonopt at the
+#    same time.
+# 2. Host defaults to nonopt.
+# 3. If nonopt is not specified, then host defaults to the current host,
+#    as determined by config.guess.
+# 4. Target and build default to nonopt.
+# 5. If nonopt is not specified, then target and build default to host.
+
+# The aliases save the names the user supplied, while $host etc.
+# will get canonicalized.
+case $host---$target---$nonopt in
+NONE---*---* | *---NONE---* | *---*---NONE) ;;
+*) { echo "configure: error: can only configure for one host and one target at a time" 1>&2; exit 1; } ;;
+esac
+
+
+# Make sure we can run config.sub.
+if ${CONFIG_SHELL-/bin/sh} $ac_config_sub sun4 >/dev/null 2>&1; then :
+else { echo "configure: error: can not run $ac_config_sub" 1>&2; exit 1; }
+fi
+
+echo $ac_n "checking host system type""... $ac_c" 1>&6
+echo "configure:1693: checking host system type" >&5
+
+host_alias=$host
+case "$host_alias" in
+NONE)
+  case $nonopt in
+  NONE)
+    if host_alias=`${CONFIG_SHELL-/bin/sh} $ac_config_guess`; then :
+    else { echo "configure: error: can not guess host type; you must specify one" 1>&2; exit 1; }
+    fi ;;
+  *) host_alias=$nonopt ;;
+  esac ;;
+esac
+
+host=`${CONFIG_SHELL-/bin/sh} $ac_config_sub $host_alias`
+host_cpu=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+host_vendor=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+host_os=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+echo "$ac_t""$host" 1>&6
+
+echo $ac_n "checking target system type""... $ac_c" 1>&6
+echo "configure:1714: checking target system type" >&5
+
+target_alias=$target
+case "$target_alias" in
+NONE)
+  case $nonopt in
+  NONE) target_alias=$host_alias ;;
+  *) target_alias=$nonopt ;;
+  esac ;;
+esac
+
+target=`${CONFIG_SHELL-/bin/sh} $ac_config_sub $target_alias`
+target_cpu=`echo $target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+target_vendor=`echo $target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+target_os=`echo $target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+echo "$ac_t""$target" 1>&6
+
+echo $ac_n "checking build system type""... $ac_c" 1>&6
+echo "configure:1732: checking build system type" >&5
+
+build_alias=$build
+case "$build_alias" in
+NONE)
+  case $nonopt in
+  NONE) build_alias=$host_alias ;;
+  *) build_alias=$nonopt ;;
+  esac ;;
+esac
+
+build=`${CONFIG_SHELL-/bin/sh} $ac_config_sub $build_alias`
+build_cpu=`echo $build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+build_vendor=`echo $build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+build_os=`echo $build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+echo "$ac_t""$build" 1>&6
+
+test "$host_alias" != "$target_alias" &&
+  test "$program_prefix$program_suffix$program_transform_name" = \
+    NONENONEs,x,x, &&
+  program_prefix=${target_alias}-
+
+if test "$program_transform_name" = s,x,x,; then
+  program_transform_name=
+else
+  # Double any \ or $.  echo might interpret backslashes.
+  cat <<\EOF_SED > conftestsed
+s,\\,\\\\,g; s,\$,$$,g
+EOF_SED
+  program_transform_name="`echo $program_transform_name|sed -f conftestsed`"
+  rm -f conftestsed
+fi
+test "$program_prefix" != NONE &&
+  program_transform_name="s,^,${program_prefix},; $program_transform_name"
+# Use a double $ so make ignores it.
+test "$program_suffix" != NONE &&
+  program_transform_name="s,\$\$,${program_suffix},; $program_transform_name"
+
+# sed with no file args requires a program.
+test "$program_transform_name" = "" && program_transform_name="s,x,x,"
+
+# Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:1776: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
+  ac_dummy="$PATH"
+  for ac_dir in $ac_dummy; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      ac_cv_prog_CC="gcc"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+fi
+fi
+CC="$ac_cv_prog_CC"
+if test -n "$CC"; then
+  echo "$ac_t""$CC" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:1806: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
+  ac_prog_rejected=no
+  ac_dummy="$PATH"
+  for ac_dir in $ac_dummy; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      if test "$ac_dir/$ac_word" = "/usr/ucb/cc"; then
+        ac_prog_rejected=yes
+	continue
+      fi
+      ac_cv_prog_CC="cc"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# -gt 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    set dummy "$ac_dir/$ac_word" "$@"
+    shift
+    ac_cv_prog_CC="$@"
+  fi
+fi
+fi
+fi
+CC="$ac_cv_prog_CC"
+if test -n "$CC"; then
+  echo "$ac_t""$CC" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+  if test -z "$CC"; then
+    case "`uname -s`" in
+    *win32* | *WIN32*)
+      # Extract the first word of "cl", so it can be a program name with args.
+set dummy cl; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:1857: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
+  ac_dummy="$PATH"
+  for ac_dir in $ac_dummy; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      ac_cv_prog_CC="cl"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+fi
+fi
+CC="$ac_cv_prog_CC"
+if test -n "$CC"; then
+  echo "$ac_t""$CC" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+ ;;
+    esac
+  fi
+  test -z "$CC" && { echo "configure: error: no acceptable cc found in \$PATH" 1>&2; exit 1; }
+fi
+
+echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
+echo "configure:1889: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
+
+ac_ext=c
+# CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
+ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
+cross_compiling=$ac_cv_prog_cc_cross
+
+cat > conftest.$ac_ext << EOF
+
+#line 1900 "configure"
+#include "confdefs.h"
+
+main(){return(0);}
+EOF
+if { (eval echo configure:1905: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  ac_cv_prog_cc_works=yes
+  # If we can't run a trivial program, we are probably using a cross compiler.
+  if (./conftest; exit) 2>/dev/null; then
+    ac_cv_prog_cc_cross=no
+  else
+    ac_cv_prog_cc_cross=yes
+  fi
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  ac_cv_prog_cc_works=no
+fi
+rm -fr conftest*
+ac_ext=c
+# CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
+ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
+cross_compiling=$ac_cv_prog_cc_cross
+
+echo "$ac_t""$ac_cv_prog_cc_works" 1>&6
+if test $ac_cv_prog_cc_works = no; then
+  { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
+fi
+echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
+echo "configure:1931: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
+cross_compiling=$ac_cv_prog_cc_cross
+
+echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
+echo "configure:1936: checking whether we are using GNU C" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.c <<EOF
+#ifdef __GNUC__
+  yes;
+#endif
+EOF
+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1945: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+  ac_cv_prog_gcc=yes
+else
+  ac_cv_prog_gcc=no
+fi
+fi
+
+echo "$ac_t""$ac_cv_prog_gcc" 1>&6
+
+if test $ac_cv_prog_gcc = yes; then
+  GCC=yes
+else
+  GCC=
+fi
+
+ac_test_CFLAGS="${CFLAGS+set}"
+ac_save_CFLAGS="$CFLAGS"
+CFLAGS=
+echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
+echo "configure:1964: checking whether ${CC-cc} accepts -g" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  echo 'void f(){}' > conftest.c
+if test -z "`${CC-cc} -g -c conftest.c 2>&1`"; then
+  ac_cv_prog_cc_g=yes
+else
+  ac_cv_prog_cc_g=no
+fi
+rm -f conftest*
+
+fi
+
+echo "$ac_t""$ac_cv_prog_cc_g" 1>&6
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS="$ac_save_CFLAGS"
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# ./install, which can be erroneously created by make from ./install.sh.
+echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&6
+echo "configure:2007: checking for a BSD compatible install" >&5
+if test -z "$INSTALL"; then
+if eval "test \"`echo '$''{'ac_cv_path_install'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+    IFS="${IFS= 	}"; ac_save_IFS="$IFS"; IFS=":"
+  for ac_dir in $PATH; do
+    # Account for people who put trailing slashes in PATH elements.
+    case "$ac_dir/" in
+    /|./|.//|/etc/*|/usr/sbin/*|/usr/etc/*|/sbin/*|/usr/afsws/bin/*|/usr/ucb/*) ;;
+    *)
+      # OSF1 and SCO ODT 3.0 have their own names for install.
+      # Don't use installbsd from OSF since it installs stuff as root
+      # by default.
+      for ac_prog in ginstall scoinst install; do
+        if test -f $ac_dir/$ac_prog; then
+	  if test $ac_prog = install &&
+            grep dspmsg $ac_dir/$ac_prog >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  else
+	    ac_cv_path_install="$ac_dir/$ac_prog -c"
+	    break 2
+	  fi
+	fi
+      done
+      ;;
+    esac
+  done
+  IFS="$ac_save_IFS"
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL="$ac_cv_path_install"
+  else
+    # As a last resort, use the slow shell script.  We don't cache a
+    # path for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the path is relative.
+    INSTALL="$ac_install_sh"
+  fi
+fi
+echo "$ac_t""$INSTALL" 1>&6
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL_PROGRAM}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+
+# Put a plausible default for CC_FOR_BUILD in Makefile.
+if test "x$cross_compiling" = "xno"; then
+  CC_FOR_BUILD='$(CC)'
+else
+  CC_FOR_BUILD=gcc
+fi
+
+
+
+
+AR=${AR-ar}
+
+# Extract the first word of "ranlib", so it can be a program name with args.
+set dummy ranlib; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:2075: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test -n "$RANLIB"; then
+  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
+else
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
+  ac_dummy="$PATH"
+  for ac_dir in $ac_dummy; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      ac_cv_prog_RANLIB="ranlib"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_prog_RANLIB" && ac_cv_prog_RANLIB=":"
+fi
+fi
+RANLIB="$ac_cv_prog_RANLIB"
+if test -n "$RANLIB"; then
+  echo "$ac_t""$RANLIB" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+
+ALL_LINGUAS=
+                              
+   for ac_hdr in argz.h limits.h locale.h nl_types.h malloc.h string.h \
+unistd.h values.h sys/param.h
+do
+ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
+echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
+echo "configure:2110: checking for $ac_hdr" >&5
+if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2115 "configure"
+#include "confdefs.h"
+#include <$ac_hdr>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:2120: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=yes"
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=no"
+fi
+rm -f conftest*
+fi
+if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_hdr 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+   for ac_func in getcwd munmap putenv setenv setlocale strchr strcasecmp \
+__argz_count __argz_stringify __argz_next
+do
+echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
+echo "configure:2150: checking for $ac_func" >&5
+if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2155 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char $ac_func();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+$ac_func();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:2178: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_func 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+
+   if test "${ac_cv_func_stpcpy+set}" != "set"; then
+     for ac_func in stpcpy
+do
+echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
+echo "configure:2207: checking for $ac_func" >&5
+if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2212 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char $ac_func();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+$ac_func();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:2235: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_func 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+   fi
+   if test "${ac_cv_func_stpcpy}" = "yes"; then
+     cat >> confdefs.h <<\EOF
+#define HAVE_STPCPY 1
+EOF
+
+   fi
+
+   if test $ac_cv_header_locale_h = yes; then
+    echo $ac_n "checking for LC_MESSAGES""... $ac_c" 1>&6
+echo "configure:2269: checking for LC_MESSAGES" >&5
+if eval "test \"`echo '$''{'am_cv_val_LC_MESSAGES'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2274 "configure"
+#include "confdefs.h"
+#include <locale.h>
+int main() {
+return LC_MESSAGES
+; return 0; }
+EOF
+if { (eval echo configure:2281: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  am_cv_val_LC_MESSAGES=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  am_cv_val_LC_MESSAGES=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$am_cv_val_LC_MESSAGES" 1>&6
+    if test $am_cv_val_LC_MESSAGES = yes; then
+      cat >> confdefs.h <<\EOF
+#define HAVE_LC_MESSAGES 1
+EOF
+
+    fi
+  fi
+   echo $ac_n "checking whether NLS is requested""... $ac_c" 1>&6
+echo "configure:2302: checking whether NLS is requested" >&5
+        # Check whether --enable-nls or --disable-nls was given.
+if test "${enable_nls+set}" = set; then
+  enableval="$enable_nls"
+  USE_NLS=$enableval
+else
+  USE_NLS=yes
+fi
+
+    echo "$ac_t""$USE_NLS" 1>&6
+    
+
+    USE_INCLUDED_LIBINTL=no
+
+        if test "$USE_NLS" = "yes"; then
+      cat >> confdefs.h <<\EOF
+#define ENABLE_NLS 1
+EOF
+
+      echo $ac_n "checking whether included gettext is requested""... $ac_c" 1>&6
+echo "configure:2322: checking whether included gettext is requested" >&5
+      # Check whether --with-included-gettext or --without-included-gettext was given.
+if test "${with_included_gettext+set}" = set; then
+  withval="$with_included_gettext"
+  nls_cv_force_use_gnu_gettext=$withval
+else
+  nls_cv_force_use_gnu_gettext=no
+fi
+
+      echo "$ac_t""$nls_cv_force_use_gnu_gettext" 1>&6
+
+      nls_cv_use_gnu_gettext="$nls_cv_force_use_gnu_gettext"
+      if test "$nls_cv_force_use_gnu_gettext" != "yes"; then
+                        		nls_cv_header_intl=
+	nls_cv_header_libgt=
+	CATOBJEXT=NONE
+
+	ac_safe=`echo "libintl.h" | sed 'y%./+-%__p_%'`
+echo $ac_n "checking for libintl.h""... $ac_c" 1>&6
+echo "configure:2341: checking for libintl.h" >&5
+if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2346 "configure"
+#include "confdefs.h"
+#include <libintl.h>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:2351: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=yes"
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=no"
+fi
+rm -f conftest*
+fi
+if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  echo $ac_n "checking for gettext in libc""... $ac_c" 1>&6
+echo "configure:2368: checking for gettext in libc" >&5
+if eval "test \"`echo '$''{'gt_cv_func_gettext_libc'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2373 "configure"
+#include "confdefs.h"
+#include <libintl.h>
+int main() {
+return (int) gettext ("")
+; return 0; }
+EOF
+if { (eval echo configure:2380: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  gt_cv_func_gettext_libc=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  gt_cv_func_gettext_libc=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$gt_cv_func_gettext_libc" 1>&6
+
+	   if test "$gt_cv_func_gettext_libc" != "yes"; then
+	     echo $ac_n "checking for bindtextdomain in -lintl""... $ac_c" 1>&6
+echo "configure:2396: checking for bindtextdomain in -lintl" >&5
+ac_lib_var=`echo intl'_'bindtextdomain | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lintl  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 2404 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char bindtextdomain();
+
+int main() {
+bindtextdomain()
+; return 0; }
+EOF
+if { (eval echo configure:2415: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  echo $ac_n "checking for gettext in libintl""... $ac_c" 1>&6
+echo "configure:2431: checking for gettext in libintl" >&5
+if eval "test \"`echo '$''{'gt_cv_func_gettext_libintl'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2436 "configure"
+#include "confdefs.h"
+
+int main() {
+return (int) gettext ("")
+; return 0; }
+EOF
+if { (eval echo configure:2443: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  gt_cv_func_gettext_libintl=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  gt_cv_func_gettext_libintl=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$gt_cv_func_gettext_libintl" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+	   fi
+
+	   if test "$gt_cv_func_gettext_libc" = "yes" \
+	      || test "$gt_cv_func_gettext_libintl" = "yes"; then
+	      cat >> confdefs.h <<\EOF
+#define HAVE_GETTEXT 1
+EOF
+
+	      # Extract the first word of "msgfmt", so it can be a program name with args.
+set dummy msgfmt; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:2471: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_path_MSGFMT'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  case "$MSGFMT" in
+  /*)
+  ac_cv_path_MSGFMT="$MSGFMT" # Let the user override the test with a path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      if test -z "`$ac_dir/$ac_word -h 2>&1 | grep 'dv '`"; then
+	ac_cv_path_MSGFMT="$ac_dir/$ac_word"
+	break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_MSGFMT" && ac_cv_path_MSGFMT="no"
+  ;;
+esac
+fi
+MSGFMT="$ac_cv_path_MSGFMT"
+if test -n "$MSGFMT"; then
+  echo "$ac_t""$MSGFMT" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+	      if test "$MSGFMT" != "no"; then
+		for ac_func in dcgettext
+do
+echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
+echo "configure:2505: checking for $ac_func" >&5
+if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2510 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char $ac_func();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+$ac_func();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:2533: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_func 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+		# Extract the first word of "gmsgfmt", so it can be a program name with args.
+set dummy gmsgfmt; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:2560: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_path_GMSGFMT'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  case "$GMSGFMT" in
+  /*)
+  ac_cv_path_GMSGFMT="$GMSGFMT" # Let the user override the test with a path.
+  ;;
+  ?:/*)			 
+  ac_cv_path_GMSGFMT="$GMSGFMT" # Let the user override the test with a dos path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
+  ac_dummy="$PATH"
+  for ac_dir in $ac_dummy; do 
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      ac_cv_path_GMSGFMT="$ac_dir/$ac_word"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_GMSGFMT" && ac_cv_path_GMSGFMT="$MSGFMT"
+  ;;
+esac
+fi
+GMSGFMT="$ac_cv_path_GMSGFMT"
+if test -n "$GMSGFMT"; then
+  echo "$ac_t""$GMSGFMT" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+		# Extract the first word of "xgettext", so it can be a program name with args.
+set dummy xgettext; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:2596: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_path_XGETTEXT'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  case "$XGETTEXT" in
+  /*)
+  ac_cv_path_XGETTEXT="$XGETTEXT" # Let the user override the test with a path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      if test -z "`$ac_dir/$ac_word -h 2>&1 | grep '(HELP)'`"; then
+	ac_cv_path_XGETTEXT="$ac_dir/$ac_word"
+	break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_XGETTEXT" && ac_cv_path_XGETTEXT=":"
+  ;;
+esac
+fi
+XGETTEXT="$ac_cv_path_XGETTEXT"
+if test -n "$XGETTEXT"; then
+  echo "$ac_t""$XGETTEXT" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+		cat > conftest.$ac_ext <<EOF
+#line 2628 "configure"
+#include "confdefs.h"
+
+int main() {
+extern int _nl_msg_cat_cntr;
+			       return _nl_msg_cat_cntr
+; return 0; }
+EOF
+if { (eval echo configure:2636: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  CATOBJEXT=.gmo
+		   DATADIRNAME=share
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  CATOBJEXT=.mo
+		   DATADIRNAME=lib
+fi
+rm -f conftest*
+		INSTOBJEXT=.mo
+	      fi
+	    fi
+	
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+
+	        
+        if test "$CATOBJEXT" = "NONE"; then
+	  	  	  nls_cv_use_gnu_gettext=yes
+        fi
+      fi
+
+      if test "$nls_cv_use_gnu_gettext" = "yes"; then
+                INTLOBJS="\$(GETTOBJS)"
+        # Extract the first word of "msgfmt", so it can be a program name with args.
+set dummy msgfmt; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:2668: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_path_MSGFMT'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  case "$MSGFMT" in
+  /*)
+  ac_cv_path_MSGFMT="$MSGFMT" # Let the user override the test with a path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      if test -z "`$ac_dir/$ac_word -h 2>&1 | grep 'dv '`"; then
+	ac_cv_path_MSGFMT="$ac_dir/$ac_word"
+	break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_MSGFMT" && ac_cv_path_MSGFMT="msgfmt"
+  ;;
+esac
+fi
+MSGFMT="$ac_cv_path_MSGFMT"
+if test -n "$MSGFMT"; then
+  echo "$ac_t""$MSGFMT" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+        # Extract the first word of "gmsgfmt", so it can be a program name with args.
+set dummy gmsgfmt; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:2702: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_path_GMSGFMT'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  case "$GMSGFMT" in
+  /*)
+  ac_cv_path_GMSGFMT="$GMSGFMT" # Let the user override the test with a path.
+  ;;
+  ?:/*)			 
+  ac_cv_path_GMSGFMT="$GMSGFMT" # Let the user override the test with a dos path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
+  ac_dummy="$PATH"
+  for ac_dir in $ac_dummy; do 
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      ac_cv_path_GMSGFMT="$ac_dir/$ac_word"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_GMSGFMT" && ac_cv_path_GMSGFMT="$MSGFMT"
+  ;;
+esac
+fi
+GMSGFMT="$ac_cv_path_GMSGFMT"
+if test -n "$GMSGFMT"; then
+  echo "$ac_t""$GMSGFMT" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+        # Extract the first word of "xgettext", so it can be a program name with args.
+set dummy xgettext; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:2738: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_path_XGETTEXT'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  case "$XGETTEXT" in
+  /*)
+  ac_cv_path_XGETTEXT="$XGETTEXT" # Let the user override the test with a path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      if test -z "`$ac_dir/$ac_word -h 2>&1 | grep '(HELP)'`"; then
+	ac_cv_path_XGETTEXT="$ac_dir/$ac_word"
+	break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_XGETTEXT" && ac_cv_path_XGETTEXT=":"
+  ;;
+esac
+fi
+XGETTEXT="$ac_cv_path_XGETTEXT"
+if test -n "$XGETTEXT"; then
+  echo "$ac_t""$XGETTEXT" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+        
+	USE_INCLUDED_LIBINTL=yes
+        CATOBJEXT=.gmo
+        INSTOBJEXT=.mo
+        DATADIRNAME=share
+	INTLDEPS='$(top_builddir)/../intl/libintl.a'
+	INTLLIBS=$INTLDEPS
+	LIBS=`echo $LIBS | sed -e 's/-lintl//'`
+        nls_cv_header_intl=libintl.h
+        nls_cv_header_libgt=libgettext.h
+      fi
+
+            if test "$XGETTEXT" != ":"; then
+			if $XGETTEXT --omit-header /dev/null 2> /dev/null; then
+	  : ;
+	else
+	  echo "$ac_t""found xgettext programs is not GNU xgettext; ignore it" 1>&6
+	  XGETTEXT=":"
+	fi
+      fi
+
+      # We need to process the po/ directory.
+      POSUB=po
+    else
+      DATADIRNAME=share
+      nls_cv_header_intl=libintl.h
+      nls_cv_header_libgt=libgettext.h
+    fi
+
+    # If this is used in GNU gettext we have to set USE_NLS to `yes'
+    # because some of the sources are only built for this goal.
+    if test "$PACKAGE" = gettext; then
+      USE_NLS=yes
+      USE_INCLUDED_LIBINTL=yes
+    fi
+
+                for lang in $ALL_LINGUAS; do
+      GMOFILES="$GMOFILES $lang.gmo"
+      POFILES="$POFILES $lang.po"
+    done
+
+        
+    
+    
+    
+    
+    
+    
+    
+    
+    
+    
+  
+
+   if test "x$CATOBJEXT" != "x"; then
+     if test "x$ALL_LINGUAS" = "x"; then
+       LINGUAS=
+     else
+       echo $ac_n "checking for catalogs to be installed""... $ac_c" 1>&6
+echo "configure:2828: checking for catalogs to be installed" >&5
+       NEW_LINGUAS=
+       for lang in ${LINGUAS=$ALL_LINGUAS}; do
+         case "$ALL_LINGUAS" in
+          *$lang*) NEW_LINGUAS="$NEW_LINGUAS $lang" ;;
+         esac
+       done
+       LINGUAS=$NEW_LINGUAS
+       echo "$ac_t""$LINGUAS" 1>&6
+     fi
+
+          if test -n "$LINGUAS"; then
+       for lang in $LINGUAS; do CATALOGS="$CATALOGS $lang$CATOBJEXT"; done
+     fi
+   fi
+
+            if test $ac_cv_header_locale_h = yes; then
+     INCLUDE_LOCALE_H="#include <locale.h>"
+   else
+     INCLUDE_LOCALE_H="\
+/* The system does not provide the header <locale.h>.  Take care yourself.  */"
+   fi
+   
+
+            if test -f $srcdir/po2tbl.sed.in; then
+      if test "$CATOBJEXT" = ".cat"; then
+	 ac_safe=`echo "linux/version.h" | sed 'y%./+-%__p_%'`
+echo $ac_n "checking for linux/version.h""... $ac_c" 1>&6
+echo "configure:2856: checking for linux/version.h" >&5
+if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2861 "configure"
+#include "confdefs.h"
+#include <linux/version.h>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:2866: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=yes"
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=no"
+fi
+rm -f conftest*
+fi
+if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  msgformat=linux
+else
+  echo "$ac_t""no" 1>&6
+msgformat=xopen
+fi
+
+
+	          	 sed -e '/^#/d' $srcdir/$msgformat-msg.sed > po2msg.sed
+      fi
+            sed -e '/^#.*[^\\]$/d' -e '/^#$/d' \
+	 $srcdir/po2tbl.sed.in > po2tbl.sed
+   fi
+
+            if test "$PACKAGE" = "gettext"; then
+     GT_NO="#NO#"
+     GT_YES=
+   else
+     GT_NO=
+     GT_YES="#YES#"
+   fi
+   
+   
+
+   MKINSTALLDIRS="\$(srcdir)/../../mkinstalldirs"
+   
+
+      l=
+   
+
+            if test -d $srcdir/po; then
+      test -d po || mkdir po
+      if test "x$srcdir" != "x."; then
+	 if test "x`echo $srcdir | sed 's@/.*@@'`" = "x"; then
+	    posrcprefix="$srcdir/"
+	 else
+	    posrcprefix="../$srcdir/"
+	 fi
+      else
+	 posrcprefix="../"
+      fi
+      rm -f po/POTFILES
+      sed -e "/^#/d" -e "/^\$/d" -e "s,.*,	$posrcprefix& \\\\," -e "\$s/\(.*\) \\\\/\1/" \
+	 < $srcdir/po/POTFILES.in > po/POTFILES
+   fi
+  
+
+# Check for common headers.
+# FIXME: Seems to me this can cause problems for i386-windows hosts.
+# At one point there were hardcoded AC_DEFINE's if ${host} = i386-*-windows*.
+for ac_hdr in stdlib.h string.h strings.h unistd.h time.h
+do
+ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
+echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
+echo "configure:2935: checking for $ac_hdr" >&5
+if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2940 "configure"
+#include "confdefs.h"
+#include <$ac_hdr>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:2945: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=yes"
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=no"
+fi
+rm -f conftest*
+fi
+if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_hdr 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+for ac_hdr in sys/time.h sys/resource.h
+do
+ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
+echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
+echo "configure:2975: checking for $ac_hdr" >&5
+if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2980 "configure"
+#include "confdefs.h"
+#include <$ac_hdr>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:2985: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=yes"
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=no"
+fi
+rm -f conftest*
+fi
+if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_hdr 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+for ac_hdr in fcntl.h fpu_control.h
+do
+ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
+echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
+echo "configure:3015: checking for $ac_hdr" >&5
+if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3020 "configure"
+#include "confdefs.h"
+#include <$ac_hdr>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:3025: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=yes"
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=no"
+fi
+rm -f conftest*
+fi
+if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_hdr 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+for ac_hdr in dlfcn.h errno.h sys/stat.h
+do
+ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
+echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
+echo "configure:3055: checking for $ac_hdr" >&5
+if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3060 "configure"
+#include "confdefs.h"
+#include <$ac_hdr>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:3065: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=yes"
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=no"
+fi
+rm -f conftest*
+fi
+if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_hdr 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+for ac_func in getrusage time sigaction __setfpucw
+do
+echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
+echo "configure:3094: checking for $ac_func" >&5
+if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3099 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char $ac_func();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+$ac_func();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:3122: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_func 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+
+# Check for socket libraries
+echo $ac_n "checking for bind in -lsocket""... $ac_c" 1>&6
+echo "configure:3149: checking for bind in -lsocket" >&5
+ac_lib_var=`echo socket'_'bind | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lsocket  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 3157 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char bind();
+
+int main() {
+bind()
+; return 0; }
+EOF
+if { (eval echo configure:3168: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_lib=HAVE_LIB`echo socket | sed -e 's/[^a-zA-Z0-9_]/_/g' \
+    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_lib 1
+EOF
+
+  LIBS="-lsocket $LIBS"
+
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+echo $ac_n "checking for gethostbyname in -lnsl""... $ac_c" 1>&6
+echo "configure:3196: checking for gethostbyname in -lnsl" >&5
+ac_lib_var=`echo nsl'_'gethostbyname | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lnsl  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 3204 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char gethostbyname();
+
+int main() {
+gethostbyname()
+; return 0; }
+EOF
+if { (eval echo configure:3215: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_lib=HAVE_LIB`echo nsl | sed -e 's/[^a-zA-Z0-9_]/_/g' \
+    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_lib 1
+EOF
+
+  LIBS="-lnsl $LIBS"
+
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+
+. ${srcdir}/../../bfd/configure.host
+
+
+
+USE_MAINTAINER_MODE=no
+# Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.
+if test "${enable_maintainer_mode+set}" = set; then
+  enableval="$enable_maintainer_mode"
+  case "${enableval}" in
+  yes)	MAINT="" USE_MAINTAINER_MODE=yes ;;
+  no)	MAINT="#" ;;
+  *)	{ echo "configure: error: "--enable-maintainer-mode does not take a value"" 1>&2; exit 1; }; MAINT="#" ;;
+esac
+if test x"$silent" != x"yes" && test x"$MAINT" = x""; then
+  echo "Setting maintainer mode" 6>&1
+fi
+else
+  MAINT="#"
+fi
+
+
+
+# Check whether --enable-sim-bswap or --disable-sim-bswap was given.
+if test "${enable_sim_bswap+set}" = set; then
+  enableval="$enable_sim_bswap"
+  case "${enableval}" in
+  yes)	sim_bswap="-DWITH_BSWAP=1 -DUSE_BSWAP=1";;
+  no)	sim_bswap="-DWITH_BSWAP=0";;
+  *)	{ echo "configure: error: "--enable-sim-bswap does not take a value"" 1>&2; exit 1; }; sim_bswap="";;
+esac
+if test x"$silent" != x"yes" && test x"$sim_bswap" != x""; then
+  echo "Setting bswap flags = $sim_bswap" 6>&1
+fi
+else
+  sim_bswap=""
+fi
+
+
+
+# Check whether --enable-sim-cflags or --disable-sim-cflags was given.
+if test "${enable_sim_cflags+set}" = set; then
+  enableval="$enable_sim_cflags"
+  case "${enableval}" in
+  yes)	 sim_cflags="-O2 -fomit-frame-pointer";;
+  trace) { echo "configure: error: "Please use --enable-sim-debug instead."" 1>&2; exit 1; }; sim_cflags="";;
+  no)	 sim_cflags="";;
+  *)	 sim_cflags=`echo "${enableval}" | sed -e "s/,/ /g"`;;
+esac
+if test x"$silent" != x"yes" && test x"$sim_cflags" != x""; then
+  echo "Setting sim cflags = $sim_cflags" 6>&1
+fi
+else
+  sim_cflags=""
+fi
+
+
+
+# Check whether --enable-sim-debug or --disable-sim-debug was given.
+if test "${enable_sim_debug+set}" = set; then
+  enableval="$enable_sim_debug"
+  case "${enableval}" in
+  yes) sim_debug="-DDEBUG=7 -DWITH_DEBUG=7";;
+  no)  sim_debug="-DDEBUG=0 -DWITH_DEBUG=0";;
+  *)   sim_debug="-DDEBUG='(${enableval})' -DWITH_DEBUG='(${enableval})'";;
+esac
+if test x"$silent" != x"yes" && test x"$sim_debug" != x""; then
+  echo "Setting sim debug = $sim_debug" 6>&1
+fi
+else
+  sim_debug=""
+fi
+
+
+
+# Check whether --enable-sim-stdio or --disable-sim-stdio was given.
+if test "${enable_sim_stdio+set}" = set; then
+  enableval="$enable_sim_stdio"
+  case "${enableval}" in
+  yes)	sim_stdio="-DWITH_STDIO=DO_USE_STDIO";;
+  no)	sim_stdio="-DWITH_STDIO=DONT_USE_STDIO";;
+  *)	{ echo "configure: error: "Unknown value $enableval passed to --enable-sim-stdio"" 1>&2; exit 1; }; sim_stdio="";;
+esac
+if test x"$silent" != x"yes" && test x"$sim_stdio" != x""; then
+  echo "Setting stdio flags = $sim_stdio" 6>&1
+fi
+else
+  sim_stdio=""
+fi
+
+
+
+# Check whether --enable-sim-trace or --disable-sim-trace was given.
+if test "${enable_sim_trace+set}" = set; then
+  enableval="$enable_sim_trace"
+  case "${enableval}" in
+  yes)	sim_trace="-DTRACE=1 -DWITH_TRACE=-1";;
+  no)	sim_trace="-DTRACE=0 -DWITH_TRACE=0";;
+  [-0-9]*)
+	sim_trace="-DTRACE='(${enableval})' -DWITH_TRACE='(${enableval})'";;
+  [a-z]*)
+	sim_trace=""
+	for x in `echo "$enableval" | sed -e "s/,/ /g"`; do
+	  if test x"$sim_trace" = x; then
+	    sim_trace="-DWITH_TRACE='(TRACE_$x"
+	  else
+	    sim_trace="${sim_trace}|TRACE_$x"
+	  fi
+	done
+	sim_trace="$sim_trace)'" ;;
+esac
+if test x"$silent" != x"yes" && test x"$sim_trace" != x""; then
+  echo "Setting sim trace = $sim_trace" 6>&1
+fi
+else
+  sim_trace=""
+fi
+
+
+
+# Check whether --enable-sim-profile or --disable-sim-profile was given.
+if test "${enable_sim_profile+set}" = set; then
+  enableval="$enable_sim_profile"
+  case "${enableval}" in
+  yes)	sim_profile="-DPROFILE=1 -DWITH_PROFILE=-1";;
+  no)	sim_profile="-DPROFILE=0 -DWITH_PROFILE=0";;
+  [-0-9]*)
+	sim_profile="-DPROFILE='(${enableval})' -DWITH_PROFILE='(${enableval})'";;
+  [a-z]*)
+	sim_profile=""
+	for x in `echo "$enableval" | sed -e "s/,/ /g"`; do
+	  if test x"$sim_profile" = x; then
+	    sim_profile="-DWITH_PROFILE='(PROFILE_$x"
+	  else
+	    sim_profile="${sim_profile}|PROFILE_$x"
+	  fi
+	done
+	sim_profile="$sim_profile)'" ;;
+esac
+if test x"$silent" != x"yes" && test x"$sim_profile" != x""; then
+  echo "Setting sim profile = $sim_profile" 6>&1
+fi
+else
+  sim_profile=""
+fi
+
+
+
+echo $ac_n "checking return type of signal handlers""... $ac_c" 1>&6
+echo "configure:3391: checking return type of signal handlers" >&5
+if eval "test \"`echo '$''{'ac_cv_type_signal'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3396 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#include <signal.h>
+#ifdef signal
+#undef signal
+#endif
+#ifdef __cplusplus
+extern "C" void (*signal (int, void (*)(int)))(int);
+#else
+void (*signal ()) ();
+#endif
+
+int main() {
+int i;
+; return 0; }
+EOF
+if { (eval echo configure:3413: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_type_signal=void
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_type_signal=int
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$ac_cv_type_signal" 1>&6
+cat >> confdefs.h <<EOF
+#define RETSIGTYPE $ac_cv_type_signal
+EOF
+
+
+
+
+
+echo $ac_n "checking for executable suffix""... $ac_c" 1>&6
+echo "configure:3435: checking for executable suffix" >&5
+if eval "test \"`echo '$''{'ac_cv_exeext'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test "$CYGWIN" = yes || test "$MINGW32" = yes; then
+  ac_cv_exeext=.exe
+else
+  rm -f conftest*
+  echo 'int main () { return 0; }' > conftest.$ac_ext
+  ac_cv_exeext=
+  if { (eval echo configure:3445: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; }; then
+    for file in conftest.*; do
+      case $file in
+      *.c | *.o | *.obj) ;;
+      *) ac_cv_exeext=`echo $file | sed -e s/conftest//` ;;
+      esac
+    done
+  else
+    { echo "configure: error: installation or configuration problem: compiler cannot create executables." 1>&2; exit 1; }
+  fi
+  rm -f conftest*
+  test x"${ac_cv_exeext}" = x && ac_cv_exeext=no
+fi
+fi
+
+EXEEXT=""
+test x"${ac_cv_exeext}" != xno && EXEEXT=${ac_cv_exeext}
+echo "$ac_t""${ac_cv_exeext}" 1>&6
+ac_exeext=$EXEEXT
+
+
+sim_link_files=
+sim_link_links=
+
+sim_link_links=tconfig.h
+if test -f ${srcdir}/tconfig.in
+then
+  sim_link_files=tconfig.in
+else
+  sim_link_files=../common/tconfig.in
+fi
+
+# targ-vals.def points to the libc macro description file.
+case "${target}" in
+*-*-*) TARG_VALS_DEF=../common/nltvals.def ;;
+esac
+sim_link_files="${sim_link_files} ${TARG_VALS_DEF}"
+sim_link_links="${sim_link_links} targ-vals.def"
+
+
+
+for ac_hdr in unistd.h
+do
+ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
+echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
+echo "configure:3490: checking for $ac_hdr" >&5
+if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3495 "configure"
+#include "confdefs.h"
+#include <$ac_hdr>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:3500: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=yes"
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=no"
+fi
+rm -f conftest*
+fi
+if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_hdr 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+
+
+
+trap '' 1 2 15
+cat > confcache <<\EOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs.  It is not useful on other systems.
+# If it contains results you don't want to keep, you may remove or edit it.
+#
+# By default, configure uses ./config.cache as the cache file,
+# creating it if it does not exist already.  You can give configure
+# the --cache-file=FILE option to use a different cache file; that is
+# what configure does when it calls configure scripts in
+# subdirectories, so they share the cache.
+# Giving --cache-file=/dev/null disables caching, for debugging configure.
+# config.status only pays attention to the cache file if you give it the
+# --recheck option to rerun configure.
+#
+EOF
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, don't put newlines in cache variables' values.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+(set) 2>&1 |
+  case `(ac_space=' '; set | grep ac_space) 2>&1` in
+  *ac_space=\ *)
+    # `set' does not quote correctly, so add quotes (double-quote substitution
+    # turns \\\\ into \\, and sed turns \\ into \).
+    sed -n \
+      -e "s/'/'\\\\''/g" \
+      -e "s/^\\([a-zA-Z0-9_]*_cv_[a-zA-Z0-9_]*\\)=\\(.*\\)/\\1=\${\\1='\\2'}/p"
+    ;;
+  *)
+    # `set' quotes correctly as required by POSIX, so do not add quotes.
+    sed -n -e 's/^\([a-zA-Z0-9_]*_cv_[a-zA-Z0-9_]*\)=\(.*\)/\1=${\1=\2}/p'
+    ;;
+  esac >> confcache
+if cmp -s $cache_file confcache; then
+  :
+else
+  if test -w $cache_file; then
+    echo "updating cache $cache_file"
+    cat confcache > $cache_file
+  else
+    echo "not updating unwritable cache $cache_file"
+  fi
+fi
+rm -f confcache
+
+trap 'rm -fr conftest* confdefs* core core.* *.core $ac_clean_files; exit 1' 1 2 15
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+# Any assignment to VPATH causes Sun make to only execute
+# the first set of double-colon rules, so remove it if not needed.
+# If there is a colon in the path, we need to keep it.
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[ 	]*VPATH[ 	]*=[^:]*$/d'
+fi
+
+trap 'rm -f $CONFIG_STATUS conftest*; exit 1' 1 2 15
+
+DEFS=-DHAVE_CONFIG_H
+
+# Without the "./", some shells look in PATH for config.status.
+: ${CONFIG_STATUS=./config.status}
+
+echo creating $CONFIG_STATUS
+rm -f $CONFIG_STATUS
+cat > $CONFIG_STATUS <<EOF
+#! /bin/sh
+# Generated automatically by configure.
+# Run this file to recreate the current configuration.
+# This directory was configured as follows,
+# on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
+#
+# $0 $ac_configure_args
+#
+# Compiler output produced by configure, useful for debugging
+# configure, is in ./config.log if it exists.
+
+ac_cs_usage="Usage: $CONFIG_STATUS [--recheck] [--version] [--help]"
+for ac_option
+do
+  case "\$ac_option" in
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    echo "running \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion"
+    exec \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion ;;
+  -version | --version | --versio | --versi | --vers | --ver | --ve | --v)
+    echo "$CONFIG_STATUS generated by autoconf version 2.13"
+    exit 0 ;;
+  -help | --help | --hel | --he | --h)
+    echo "\$ac_cs_usage"; exit 0 ;;
+  *) echo "\$ac_cs_usage"; exit 1 ;;
+  esac
+done
+
+ac_given_srcdir=$srcdir
+ac_given_INSTALL="$INSTALL"
+
+trap 'rm -fr `echo "Makefile.sim:Makefile.in Make-common.sim:../common/Make-common.in .gdbinit:../common/gdbinit.in config.h:config.in" | sed "s/:[^ ]*//g"` conftest*; exit 1' 1 2 15
+EOF
+cat >> $CONFIG_STATUS <<EOF
+
+# Protect against being on the right side of a sed subst in config.status.
+sed 's/%@/@@/; s/@%/@@/; s/%g\$/@g/; /@g\$/s/[\\\\&%]/\\\\&/g;
+ s/@@/%@/; s/@@/@%/; s/@g\$/%g/' > conftest.subs <<\\CEOF
+$ac_vpsub
+$extrasub
+s%@sim_environment@%$sim_environment%g
+s%@sim_alignment@%$sim_alignment%g
+s%@sim_assert@%$sim_assert%g
+s%@sim_bitsize@%$sim_bitsize%g
+s%@sim_endian@%$sim_endian%g
+s%@sim_hostendian@%$sim_hostendian%g
+s%@sim_float@%$sim_float%g
+s%@sim_scache@%$sim_scache%g
+s%@sim_default_model@%$sim_default_model%g
+s%@sim_hw_cflags@%$sim_hw_cflags%g
+s%@sim_hw_objs@%$sim_hw_objs%g
+s%@sim_hw@%$sim_hw%g
+s%@sim_inline@%$sim_inline%g
+s%@sim_packages@%$sim_packages%g
+s%@sim_regparm@%$sim_regparm%g
+s%@sim_reserved_bits@%$sim_reserved_bits%g
+s%@sim_smp@%$sim_smp%g
+s%@sim_stdcall@%$sim_stdcall%g
+s%@sim_xor_endian@%$sim_xor_endian%g
+s%@WARN_CFLAGS@%$WARN_CFLAGS%g
+s%@WERROR_CFLAGS@%$WERROR_CFLAGS%g
+s%@SHELL@%$SHELL%g
+s%@CFLAGS@%$CFLAGS%g
+s%@CPPFLAGS@%$CPPFLAGS%g
+s%@CXXFLAGS@%$CXXFLAGS%g
+s%@FFLAGS@%$FFLAGS%g
+s%@DEFS@%$DEFS%g
+s%@LDFLAGS@%$LDFLAGS%g
+s%@LIBS@%$LIBS%g
+s%@exec_prefix@%$exec_prefix%g
+s%@prefix@%$prefix%g
+s%@program_transform_name@%$program_transform_name%g
+s%@bindir@%$bindir%g
+s%@sbindir@%$sbindir%g
+s%@libexecdir@%$libexecdir%g
+s%@datadir@%$datadir%g
+s%@sysconfdir@%$sysconfdir%g
+s%@sharedstatedir@%$sharedstatedir%g
+s%@localstatedir@%$localstatedir%g
+s%@libdir@%$libdir%g
+s%@includedir@%$includedir%g
+s%@oldincludedir@%$oldincludedir%g
+s%@infodir@%$infodir%g
+s%@mandir@%$mandir%g
+s%@host@%$host%g
+s%@host_alias@%$host_alias%g
+s%@host_cpu@%$host_cpu%g
+s%@host_vendor@%$host_vendor%g
+s%@host_os@%$host_os%g
+s%@target@%$target%g
+s%@target_alias@%$target_alias%g
+s%@target_cpu@%$target_cpu%g
+s%@target_vendor@%$target_vendor%g
+s%@target_os@%$target_os%g
+s%@build@%$build%g
+s%@build_alias@%$build_alias%g
+s%@build_cpu@%$build_cpu%g
+s%@build_vendor@%$build_vendor%g
+s%@build_os@%$build_os%g
+s%@CC@%$CC%g
+s%@INSTALL_PROGRAM@%$INSTALL_PROGRAM%g
+s%@INSTALL_SCRIPT@%$INSTALL_SCRIPT%g
+s%@INSTALL_DATA@%$INSTALL_DATA%g
+s%@CC_FOR_BUILD@%$CC_FOR_BUILD%g
+s%@HDEFINES@%$HDEFINES%g
+s%@AR@%$AR%g
+s%@RANLIB@%$RANLIB%g
+s%@SET_MAKE@%$SET_MAKE%g
+s%@CPP@%$CPP%g
+s%@ALLOCA@%$ALLOCA%g
+s%@USE_NLS@%$USE_NLS%g
+s%@MSGFMT@%$MSGFMT%g
+s%@GMSGFMT@%$GMSGFMT%g
+s%@XGETTEXT@%$XGETTEXT%g
+s%@USE_INCLUDED_LIBINTL@%$USE_INCLUDED_LIBINTL%g
+s%@CATALOGS@%$CATALOGS%g
+s%@CATOBJEXT@%$CATOBJEXT%g
+s%@DATADIRNAME@%$DATADIRNAME%g
+s%@GMOFILES@%$GMOFILES%g
+s%@INSTOBJEXT@%$INSTOBJEXT%g
+s%@INTLDEPS@%$INTLDEPS%g
+s%@INTLLIBS@%$INTLLIBS%g
+s%@INTLOBJS@%$INTLOBJS%g
+s%@POFILES@%$POFILES%g
+s%@POSUB@%$POSUB%g
+s%@INCLUDE_LOCALE_H@%$INCLUDE_LOCALE_H%g
+s%@GT_NO@%$GT_NO%g
+s%@GT_YES@%$GT_YES%g
+s%@MKINSTALLDIRS@%$MKINSTALLDIRS%g
+s%@l@%$l%g
+s%@MAINT@%$MAINT%g
+s%@sim_bswap@%$sim_bswap%g
+s%@sim_cflags@%$sim_cflags%g
+s%@sim_debug@%$sim_debug%g
+s%@sim_stdio@%$sim_stdio%g
+s%@sim_trace@%$sim_trace%g
+s%@sim_profile@%$sim_profile%g
+s%@EXEEXT@%$EXEEXT%g
+
+CEOF
+EOF
+
+cat >> $CONFIG_STATUS <<\EOF
+
+# Split the substitutions into bite-sized pieces for seds with
+# small command number limits, like on Digital OSF/1 and HP-UX.
+ac_max_sed_cmds=90 # Maximum number of lines to put in a sed script.
+ac_file=1 # Number of current file.
+ac_beg=1 # First line for current file.
+ac_end=$ac_max_sed_cmds # Line after last line for current file.
+ac_more_lines=:
+ac_sed_cmds=""
+while $ac_more_lines; do
+  if test $ac_beg -gt 1; then
+    sed "1,${ac_beg}d; ${ac_end}q" conftest.subs > conftest.s$ac_file
+  else
+    sed "${ac_end}q" conftest.subs > conftest.s$ac_file
+  fi
+  if test ! -s conftest.s$ac_file; then
+    ac_more_lines=false
+    rm -f conftest.s$ac_file
+  else
+    if test -z "$ac_sed_cmds"; then
+      ac_sed_cmds="sed -f conftest.s$ac_file"
+    else
+      ac_sed_cmds="$ac_sed_cmds | sed -f conftest.s$ac_file"
+    fi
+    ac_file=`expr $ac_file + 1`
+    ac_beg=$ac_end
+    ac_end=`expr $ac_end + $ac_max_sed_cmds`
+  fi
+done
+if test -z "$ac_sed_cmds"; then
+  ac_sed_cmds=cat
+fi
+EOF
+
+cat >> $CONFIG_STATUS <<EOF
+
+CONFIG_FILES=\${CONFIG_FILES-"Makefile.sim:Makefile.in Make-common.sim:../common/Make-common.in .gdbinit:../common/gdbinit.in"}
+EOF
+cat >> $CONFIG_STATUS <<\EOF
+for ac_file in .. $CONFIG_FILES; do if test "x$ac_file" != x..; then
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case "$ac_file" in
+  *:*) ac_file_in=`echo "$ac_file"|sed 's%[^:]*:%%'`
+       ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
+  *) ac_file_in="${ac_file}.in" ;;
+  esac
+
+  # Adjust a relative srcdir, top_srcdir, and INSTALL for subdirectories.
+
+  # Remove last slash and all that follows it.  Not all systems have dirname.
+  ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
+  if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
+    # The file is in a subdirectory.
+    test ! -d "$ac_dir" && mkdir "$ac_dir"
+    ac_dir_suffix="/`echo $ac_dir|sed 's%^\./%%'`"
+    # A "../" for each directory in $ac_dir_suffix.
+    ac_dots=`echo $ac_dir_suffix|sed 's%/[^/]*%../%g'`
+  else
+    ac_dir_suffix= ac_dots=
+  fi
+
+  case "$ac_given_srcdir" in
+  .)  srcdir=.
+      if test -z "$ac_dots"; then top_srcdir=.
+      else top_srcdir=`echo $ac_dots|sed 's%/$%%'`; fi ;;
+  /*) srcdir="$ac_given_srcdir$ac_dir_suffix"; top_srcdir="$ac_given_srcdir" ;;
+  *) # Relative path.
+    srcdir="$ac_dots$ac_given_srcdir$ac_dir_suffix"
+    top_srcdir="$ac_dots$ac_given_srcdir" ;;
+  esac
+
+  case "$ac_given_INSTALL" in
+  [/$]*) INSTALL="$ac_given_INSTALL" ;;
+  *) INSTALL="$ac_dots$ac_given_INSTALL" ;;
+  esac
+
+  echo creating "$ac_file"
+  rm -f "$ac_file"
+  configure_input="Generated automatically from `echo $ac_file_in|sed 's%.*/%%'` by configure."
+  case "$ac_file" in
+  *Makefile*) ac_comsub="1i\\
+# $configure_input" ;;
+  *) ac_comsub= ;;
+  esac
+
+  ac_file_inputs=`echo $ac_file_in|sed -e "s%^%$ac_given_srcdir/%" -e "s%:% $ac_given_srcdir/%g"`
+  sed -e "$ac_comsub
+s%@configure_input@%$configure_input%g
+s%@srcdir@%$srcdir%g
+s%@top_srcdir@%$top_srcdir%g
+s%@INSTALL@%$INSTALL%g
+" $ac_file_inputs | (eval "$ac_sed_cmds") > $ac_file
+fi; done
+rm -f conftest.s*
+
+# These sed commands are passed to sed as "A NAME B NAME C VALUE D", where
+# NAME is the cpp macro being defined and VALUE is the value it is being given.
+#
+# ac_d sets the value in "#define NAME VALUE" lines.
+ac_dA='s%^\([ 	]*\)#\([ 	]*define[ 	][ 	]*\)'
+ac_dB='\([ 	][ 	]*\)[^ 	]*%\1#\2'
+ac_dC='\3'
+ac_dD='%g'
+# ac_u turns "#undef NAME" with trailing blanks into "#define NAME VALUE".
+ac_uA='s%^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
+ac_uB='\([ 	]\)%\1#\2define\3'
+ac_uC=' '
+ac_uD='\4%g'
+# ac_e turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
+ac_eA='s%^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
+ac_eB='$%\1#\2define\3'
+ac_eC=' '
+ac_eD='%g'
+
+if test "${CONFIG_HEADERS+set}" != set; then
+EOF
+cat >> $CONFIG_STATUS <<EOF
+  CONFIG_HEADERS="config.h:config.in"
+EOF
+cat >> $CONFIG_STATUS <<\EOF
+fi
+for ac_file in .. $CONFIG_HEADERS; do if test "x$ac_file" != x..; then
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case "$ac_file" in
+  *:*) ac_file_in=`echo "$ac_file"|sed 's%[^:]*:%%'`
+       ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
+  *) ac_file_in="${ac_file}.in" ;;
+  esac
+
+  echo creating $ac_file
+
+  rm -f conftest.frag conftest.in conftest.out
+  ac_file_inputs=`echo $ac_file_in|sed -e "s%^%$ac_given_srcdir/%" -e "s%:% $ac_given_srcdir/%g"`
+  cat $ac_file_inputs > conftest.in
+
+EOF
+
+# Transform confdefs.h into a sed script conftest.vals that substitutes
+# the proper values into config.h.in to produce config.h.  And first:
+# Protect against being on the right side of a sed subst in config.status.
+# Protect against being in an unquoted here document in config.status.
+rm -f conftest.vals
+cat > conftest.hdr <<\EOF
+s/[\\&%]/\\&/g
+s%[\\$`]%\\&%g
+s%#define \([A-Za-z_][A-Za-z0-9_]*\) *\(.*\)%${ac_dA}\1${ac_dB}\1${ac_dC}\2${ac_dD}%gp
+s%ac_d%ac_u%gp
+s%ac_u%ac_e%gp
+EOF
+sed -n -f conftest.hdr confdefs.h > conftest.vals
+rm -f conftest.hdr
+
+# This sed command replaces #undef with comments.  This is necessary, for
+# example, in the case of _POSIX_SOURCE, which is predefined and required
+# on some systems where configure will not decide to define it.
+cat >> conftest.vals <<\EOF
+s%^[ 	]*#[ 	]*undef[ 	][ 	]*[a-zA-Z_][a-zA-Z_0-9]*%/* & */%
+EOF
+
+# Break up conftest.vals because some shells have a limit on
+# the size of here documents, and old seds have small limits too.
+
+rm -f conftest.tail
+while :
+do
+  ac_lines=`grep -c . conftest.vals`
+  # grep -c gives empty output for an empty file on some AIX systems.
+  if test -z "$ac_lines" || test "$ac_lines" -eq 0; then break; fi
+  # Write a limited-size here document to conftest.frag.
+  echo '  cat > conftest.frag <<CEOF' >> $CONFIG_STATUS
+  sed ${ac_max_here_lines}q conftest.vals >> $CONFIG_STATUS
+  echo 'CEOF
+  sed -f conftest.frag conftest.in > conftest.out
+  rm -f conftest.in
+  mv conftest.out conftest.in
+' >> $CONFIG_STATUS
+  sed 1,${ac_max_here_lines}d conftest.vals > conftest.tail
+  rm -f conftest.vals
+  mv conftest.tail conftest.vals
+done
+rm -f conftest.vals
+
+cat >> $CONFIG_STATUS <<\EOF
+  rm -f conftest.frag conftest.h
+  echo "/* $ac_file.  Generated automatically by configure.  */" > conftest.h
+  cat conftest.in >> conftest.h
+  rm -f conftest.in
+  if cmp -s $ac_file conftest.h 2>/dev/null; then
+    echo "$ac_file is unchanged"
+    rm -f conftest.h
+  else
+    # Remove last slash and all that follows it.  Not all systems have dirname.
+      ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
+      if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
+      # The file is in a subdirectory.
+      test ! -d "$ac_dir" && mkdir "$ac_dir"
+    fi
+    rm -f $ac_file
+    mv conftest.h $ac_file
+  fi
+fi; done
+
+EOF
+
+cat >> $CONFIG_STATUS <<EOF
+ac_sources="$sim_link_files"
+ac_dests="$sim_link_links"
+EOF
+
+cat >> $CONFIG_STATUS <<\EOF
+srcdir=$ac_given_srcdir
+while test -n "$ac_sources"; do
+  set $ac_dests; ac_dest=$1; shift; ac_dests=$*
+  set $ac_sources; ac_source=$1; shift; ac_sources=$*
+
+  echo "linking $srcdir/$ac_source to $ac_dest"
+
+  if test ! -r $srcdir/$ac_source; then
+    { echo "configure: error: $srcdir/$ac_source: File not found" 1>&2; exit 1; }
+  fi
+  rm -f $ac_dest
+
+  # Make relative symlinks.
+  # Remove last slash and all that follows it.  Not all systems have dirname.
+  ac_dest_dir=`echo $ac_dest|sed 's%/[^/][^/]*$%%'`
+  if test "$ac_dest_dir" != "$ac_dest" && test "$ac_dest_dir" != .; then
+    # The dest file is in a subdirectory.
+    test ! -d "$ac_dest_dir" && mkdir "$ac_dest_dir"
+    ac_dest_dir_suffix="/`echo $ac_dest_dir|sed 's%^\./%%'`"
+    # A "../" for each directory in $ac_dest_dir_suffix.
+    ac_dots=`echo $ac_dest_dir_suffix|sed 's%/[^/]*%../%g'`
+  else
+    ac_dest_dir_suffix= ac_dots=
+  fi
+
+  case "$srcdir" in
+  [/$]*) ac_rel_source="$srcdir/$ac_source" ;;
+  *) ac_rel_source="$ac_dots$srcdir/$ac_source" ;;
+  esac
+
+  # Make a symlink if possible; otherwise try a hard link.
+  if ln -s $ac_rel_source $ac_dest 2>/dev/null ||
+    ln $srcdir/$ac_source $ac_dest; then :
+  else
+    { echo "configure: error: can not link $ac_dest to $srcdir/$ac_source" 1>&2; exit 1; }
+  fi
+done
+EOF
+cat >> $CONFIG_STATUS <<EOF
+
+EOF
+cat >> $CONFIG_STATUS <<\EOF
+case "x$CONFIG_FILES" in
+ xMakefile*)
+   echo "Merging Makefile.sim+Make-common.sim into Makefile ..."
+   rm -f Makesim1.tmp Makesim2.tmp Makefile
+   sed -n -e '/^## COMMON_PRE_/,/^## End COMMON_PRE_/ p' <Make-common.sim >Makesim1.tmp
+   sed -n -e '/^## COMMON_POST_/,/^## End COMMON_POST_/ p' <Make-common.sim >Makesim2.tmp
+   sed -e '/^## COMMON_PRE_/ r Makesim1.tmp' \
+	-e '/^## COMMON_POST_/ r Makesim2.tmp' \
+	<Makefile.sim >Makefile
+   rm -f Makefile.sim Make-common.sim Makesim1.tmp Makesim2.tmp
+   ;;
+ esac
+ case "x$CONFIG_HEADERS" in xconfig.h:config.in) echo > stamp-h ;; esac
+
+exit 0
+EOF
+chmod +x $CONFIG_STATUS
+rm -fr confdefs* $ac_clean_files
+test "$no_create" = yes || ${CONFIG_SHELL-/bin/sh} $CONFIG_STATUS || exit 1
+
+
diff --git a/sim/microblaze/configure.in b/sim/microblaze/configure.in
new file mode 100644
index 0000000..033b0bc
--- /dev/null
+++ b/sim/microblaze/configure.in
@@ -0,0 +1,10 @@
+dnl Process this file with autoconf to produce a configure script.
+sinclude(../common/aclocal.m4)
+AC_PREREQ(2.5)dnl
+AC_INIT(Makefile.in)
+
+SIM_AC_COMMON
+
+AC_CHECK_HEADERS(unistd.h)
+
+SIM_AC_OUTPUT
diff --git a/sim/microblaze/interp.c b/sim/microblaze/interp.c
new file mode 100644
index 0000000..ea61803
--- /dev/null
+++ b/sim/microblaze/interp.c
@@ -0,0 +1,1190 @@
+/* Simulator for Xilinx MicroBlaze processor
+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.
+   Contributed by Cygnus Solutions.
+
+This file is part of GDB, the GNU debugger.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along
+with this program; if not, write to the Free Software Foundation, Inc.,
+59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/*
+ * Copyright (c) 2001 Xilinx, Inc.  All rights reserved. 
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by Xilinx, Inc.  The name of the Company may not be used to endorse 
+ * or promote products derived from this software without specific prior 
+ * written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ *	Xilinx, Inc.
+ *
+ */
+
+#include <signal.h>
+#include "sysdep.h"
+#include <sys/times.h>
+#include <sys/param.h>
+#include <netinet/in.h>	/* for byte ordering macros */
+#include "bfd.h"
+#include "gdb/callback.h"
+#include "libiberty.h"
+#include "gdb/remote-sim.h"
+#include "sim-main.h"
+
+
+#ifndef NUM_ELEM
+#define NUM_ELEM(A) (sizeof (A) / sizeof (A)[0])
+#endif
+
+
+static int            target_big_endian = 1;
+static unsigned long  heap_ptr = 0;
+static unsigned long  stack_ptr = 0;
+host_callback *       callback;
+
+unsigned long
+microblaze_extract_unsigned_integer (addr, len)
+     unsigned char * addr;
+     int len;
+{
+  unsigned long retval;
+  unsigned char * p;
+  unsigned char * startaddr = (unsigned char *)addr;
+  unsigned char * endaddr = startaddr + len;
+ 
+  if (len > (int) sizeof (unsigned long))
+    printf ("That operation is not available on integers of more than %d bytes.",
+	    sizeof (unsigned long));
+ 
+  /* Start at the most significant end of the integer, and work towards
+     the least significant.  */
+  retval = 0;
+
+  if (! target_big_endian)
+    {
+      for (p = endaddr; p > startaddr;)
+	retval = (retval << 8) | * -- p;
+    }
+  else
+    {
+      for (p = startaddr; p < endaddr;)
+	retval = (retval << 8) | * p ++;
+    }
+  
+  return retval;
+}
+
+void
+microblaze_store_unsigned_integer (addr, len, val)
+     unsigned char * addr;
+     int len;
+     unsigned long val;
+{
+  unsigned char * p;
+  unsigned char * startaddr = (unsigned char *)addr;
+  unsigned char * endaddr = startaddr + len;
+
+  if (! target_big_endian)
+    {
+      for (p = startaddr; p < endaddr;)
+	{
+	  * p ++ = val & 0xff;
+	  val >>= 8;
+	}
+    }
+  else
+    {
+      for (p = endaddr; p > startaddr;)
+	{
+	  * -- p = val & 0xff;
+	  val >>= 8;
+	}
+    }
+}
+
+struct sim_state microblaze_state;
+
+int memcycles = 1;
+
+static SIM_OPEN_KIND sim_kind;
+static char * myname;
+
+static int issue_messages = 0;
+
+long
+int_sbrk (inc_bytes)
+     int inc_bytes;
+{
+  long addr;
+  
+  addr = heap_ptr;
+  
+  heap_ptr += inc_bytes;
+  
+  if (issue_messages && heap_ptr>SP)
+    fprintf (stderr, "Warning: heap_ptr overlaps stack!\n");
+  
+  return addr;
+}
+
+static void /* INLINE */
+wbat (x, v)
+     word x, v;
+{
+  if (((uword)x) >= CPU.msize)
+    {
+      if (issue_messages)
+	fprintf (stderr, "byte write to 0x%x outside memory range\n", x);
+      
+      CPU.exception = SIGSEGV;
+    }
+  else
+    {
+      unsigned char *p = CPU.memory + x;
+      p[0] = v;
+    }
+}
+
+static void /* INLINE */
+wlat (x, v)
+     word x, v;
+{
+  if (((uword)x) >= CPU.msize)
+    {
+      if (issue_messages)
+	fprintf (stderr, "word write to 0x%x outside memory range\n", x);
+      
+      CPU.exception = SIGSEGV;
+    }
+  else
+    {
+      if ((x & 3) != 0)
+	{
+	  if (issue_messages)
+	    fprintf (stderr, "word write to unaligned memory address: 0x%x\n", x);
+      
+	  CPU.exception = SIGBUS;
+	}
+      else if (! target_big_endian)
+	{
+	  unsigned char * p = CPU.memory + x;
+	  p[3] = v >> 24;
+	  p[2] = v >> 16;
+	  p[1] = v >> 8;
+	  p[0] = v;
+	}
+      else
+	{
+	  unsigned char * p = CPU.memory + x;
+	  p[0] = v >> 24;
+	  p[1] = v >> 16;
+	  p[2] = v >> 8;
+	  p[3] = v;
+	}
+    }
+}
+
+static void /* INLINE */
+what (x, v)
+     word x, v;
+{
+  if (((uword)x) >= CPU.msize)
+    {
+      if (issue_messages)
+	fprintf (stderr, "short write to 0x%x outside memory range\n", x);
+      
+      CPU.exception = SIGSEGV;
+    }
+  else
+    {
+      if ((x & 1) != 0)
+	{
+	  if (issue_messages)
+	    fprintf (stderr, "short write to unaligned memory address: 0x%x\n",
+		     x);
+      
+	  CPU.exception = SIGBUS;
+	}
+      else if (! target_big_endian)
+	{
+	  unsigned char * p = CPU.memory + x;
+	  p[1] = v >> 8;
+	  p[0] = v;
+	}
+      else
+	{
+	  unsigned char * p = CPU.memory + x;
+	  p[0] = v >> 8;
+	  p[1] = v;
+	}
+    }
+}
+
+/* Read functions.  */
+static int /* INLINE */
+rbat (x)
+     word x;
+{
+  if (((uword)x) >= CPU.msize)
+    {
+      if (issue_messages)
+	fprintf (stderr, "byte read from 0x%x outside memory range\n", x);
+      
+      CPU.exception = SIGSEGV;
+      return 0;
+    }
+  else
+    {
+      unsigned char * p = CPU.memory + x;
+      return p[0];
+    }
+}
+
+static int /* INLINE */
+rlat (x)
+     word x;
+{
+  if (((uword) x) >= CPU.msize)
+    {
+      if (issue_messages)
+	fprintf (stderr, "word read from 0x%x outside memory range\n", x);
+      
+      CPU.exception = SIGSEGV;
+      return 0;
+    }
+  else
+    {
+      if ((x & 3) != 0)
+	{
+	  if (issue_messages)
+	    fprintf (stderr, "word read from unaligned address: 0x%x\n", x);
+      
+	  CPU.exception = SIGBUS;
+	  return 0;
+	}
+      else if (! target_big_endian)
+	{
+	  unsigned char * p = CPU.memory + x;
+	  return (p[3] << 24) | (p[2] << 16) | (p[1] << 8) | p[0];
+	}
+      else
+	{
+	  unsigned char * p = CPU.memory + x;
+	  return (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
+	}
+    }
+}
+
+static int /* INLINE */
+rhat (x)
+     word x;
+{
+  if (((uword)x) >= CPU.msize)
+    {
+      if (issue_messages)
+	fprintf (stderr, "short read from 0x%x outside memory range\n", x);
+      
+      CPU.exception = SIGSEGV;
+      return 0;
+    }
+  else
+    {
+      if ((x & 1) != 0)
+	{
+	  if (issue_messages)
+	    fprintf (stderr, "short read from unaligned address: 0x%x\n", x);
+      
+	  CPU.exception = SIGBUS;
+	  return 0;
+	}
+      else if (! target_big_endian)
+	{
+	  unsigned char * p = CPU.memory + x;
+	  return (p[1] << 8) | p[0];
+	}
+      else
+	{
+	  unsigned char * p = CPU.memory + x;
+	  return (p[0] << 8) | p[1];
+	}
+    }
+}
+
+
+#define SEXTB(x)     	(((x & 0xff) ^ (~ 0x7f)) + 0x80)
+#define SEXTW(y)    	((int)((short)y))
+
+static int
+IOMEM (addr, write, value)
+     int addr;
+     int write;
+     int value;
+{
+}
+
+/* Default to a 8 Mbyte (== 2^23) memory space.  */
+static int sim_memory_size = 1 << 23;
+
+#define	MEM_SIZE_FLOOR	64
+void
+sim_size (size)
+     int size;
+{
+  sim_memory_size = size;
+  CPU.msize = sim_memory_size;
+
+  if (CPU.memory)
+    free (CPU.memory);
+
+  CPU.memory = (unsigned char *) calloc (1, CPU.msize);
+
+  if (!CPU.memory)
+    {
+      if (issue_messages)
+	fprintf (stderr,
+		 "Not enough VM for simulation of %d bytes of RAM\n",
+		 CPU.msize);
+
+      CPU.msize = 1;
+      CPU.memory = (unsigned char *) calloc (1, 1);
+    }
+}
+
+static void
+init_pointers ()
+{
+  if (CPU.msize != (sim_memory_size))
+    sim_size (sim_memory_size);
+}
+
+static void
+set_initial_gprs ()
+{
+  int i;
+  long space;
+  unsigned long memsize;
+  
+  init_pointers ();
+
+  /* Set up machine just out of reset.  */
+  PC = 0;
+  MSR = 0;
+  
+  memsize = CPU.msize / (1024 * 1024);
+
+  if (issue_messages > 1)
+    fprintf (stderr, "Simulated memory of %d Mbytes (0x0 .. 0x%08x)\n",
+	     memsize, CPU.msize - 1);
+
+  /* Clean out the GPRs */
+  for (i = 0; i < 32; i++)
+    {
+      CPU.regs[i] = 0;
+    }
+  CPU.insts = 0;
+  CPU.cycles = 0;
+  CPU.imm_enable = 0;
+  
+}
+
+static void
+interrupt ()
+{
+  CPU.exception = SIGINT;
+}
+
+/* Functions so that trapped open/close don't interfere with the
+   parent's functions.  We say that we can't close the descriptors
+   that we didn't open.  exit() and cleanup() get in trouble here,
+   to some extent.  That's the price of emulation.  */
+
+unsigned char opened[100];
+
+static void
+log_open (fd)
+    int fd;
+{
+  if (fd < 0 || fd > NUM_ELEM (opened))
+    return;
+  
+  opened[fd] = 1;
+}
+
+static void
+log_close (fd)
+     int fd;
+{
+  if (fd < 0 || fd > NUM_ELEM (opened))
+    return;
+  
+  opened[fd] = 0;
+}
+
+static int
+is_opened (fd)
+    int fd;
+{
+  if (fd < 0 || fd > NUM_ELEM (opened))
+    return 0;
+
+  return opened[fd];
+}
+
+static void
+handle_trap1 ()
+{
+}
+
+static void
+process_stub (what)
+     int what;
+{
+  /* These values should match those in libgloss/microblaze/syscalls.s.  */
+  switch (what)
+    {
+    case 3:  /* _read */
+    case 4:  /* _write */
+    case 5:  /* _open */
+    case 6:  /* _close */
+    case 10: /* _unlink */
+    case 19: /* _lseek */
+    case 43: /* _times */
+      /*usha      CPU.regs [TRAPCODE] = what;*/
+      handle_trap1 ();
+      break;
+      
+    default:
+      if (issue_messages)
+	fprintf (stderr, "Unhandled stub opcode: %d\n", what);
+      break;
+    }
+}
+
+static void
+util (what)
+     unsigned what;
+{
+  switch (what)
+    {
+    case 0:	/* exit */
+      CPU.exception = SIGQUIT;
+      break;
+
+    case 1:	/* printf */
+      {
+	unsigned long a[6];
+	unsigned char *s;
+	int i;
+
+	/*usha	a[0] = (unsigned long)(CPU.memory + CPU.regs[PARM1]);*/
+
+	for (s = (unsigned char *)a[0], i = 1 ; *s && i < 6 ; s++)
+	  {
+	    if (*s == '%')
+	      {
+		/* usha
+		if (*++s == 's')
+		  a[i] = (unsigned long)(CPU.memory + CPU.regs[PARM1+i]);
+		else
+		  a[i] = CPU.regs[i+PARM1];
+		*/
+		i++;
+	      }
+	  }
+	
+	/*usha	CPU.regs[RET1] = printf ((char *)a[0], a[1], a[2], a[3], a[4], a[5]);*/
+      }
+      break;
+      
+    case 2:	/* scanf */
+      if (issue_messages)
+	fprintf (stderr, "WARNING: scanf unimplemented\n");
+      break;
+      
+    case 3:	/* utime */
+      /*usha      CPU.regs[RET1] = CPU.insts;*/
+      break;
+
+    case 0xFF:
+      process_stub (CPU.regs[1]);
+      break;
+      
+    default:
+      if (issue_messages)
+	fprintf (stderr, "Unhandled util code: %x\n", what);
+      break;
+    }
+}	
+
+/* For figuring out whether we carried; addc/subc use this. */
+static int
+iu_carry (a, b, cin)
+     unsigned long a;
+     unsigned long b;
+     int cin;
+{
+  unsigned long	x;
+  
+  x = (a & 0xffff) + (b & 0xffff) + cin;
+  x = (x >> 16) + (a >> 16) + (b >> 16);
+  x >>= 16;
+
+  return (x != 0);
+}
+
+#define WATCHFUNCTIONS 1
+#ifdef WATCHFUNCTIONS
+
+#define MAXWL 80
+word WL[MAXWL];
+char * WLstr[MAXWL];
+
+int ENDWL=0;
+int WLincyc;
+int WLcyc[MAXWL];
+int WLcnts[MAXWL];
+int WLmax[MAXWL];
+int WLmin[MAXWL];
+word WLendpc;
+int WLbcyc;
+int WLW;
+#endif
+
+static int tracing = 0;
+
+void
+sim_resume (sd, step, siggnal)
+     SIM_DESC sd;
+     int step, siggnal;
+{
+  int needfetch;
+  word inst;
+  enum microblaze_instr op;
+  void (* sigsave)();
+  int memops;
+  int bonus_cycles;
+  int insts;
+  int w;
+  int cycs;
+  word WLhash;
+  ubyte carry;
+  boolean imm_unsigned;
+  short ra, rb, rd;
+  long immword;
+  uword oldpc, newpc;
+  short delay_slot_enable;
+  short branch_taken;
+  short num_delay_slot; /* UNUSED except as reqd parameter */
+  enum microblaze_instr_type insn_type;
+
+  sigsave = signal (SIGINT, interrupt);
+  CPU.exception = step ? SIGTRAP: 0;
+
+  memops = 0;
+  bonus_cycles = 0;
+  insts = 0;
+  
+  do
+    {
+      /* Fetch the initial instructions that we'll decode. */
+      inst = rlat (PC & 0xFFFFFFFC);
+
+      op = get_insn_microblaze( inst, &imm_unsigned, &insn_type, &num_delay_slot );
+
+      if (op == invalid_inst)
+         fprintf (stderr, "Unknown instruction 0x%04x", inst);
+      
+      if (tracing)
+         fprintf (stderr, "%.4x: inst = %.4x ", PC, inst);
+      
+      rd = GET_RD;
+      rb = GET_RB;
+      ra = GET_RA;
+      /*      immword = IMM_W; */
+      
+      oldpc = PC;
+      delay_slot_enable = 0;
+      branch_taken = 0;
+      if (op == microblaze_brk) 
+	{
+     CPU.exception = SIGTRAP;
+	}
+      else if (inst == MICROBLAZE_HALT_INST)
+      {
+	  CPU.exception = SIGSTOP;
+	  insts += 1;
+	  bonus_cycles++;
+	}
+      else
+      {
+     switch(op){
+#define INSTRUCTION(NAME,OPCODE, TYPE, ACTION)        \
+    case NAME:                                        \
+      ACTION;                                         \
+      break;
+#include "microblaze.isa"
+#undef INSTRUCTION
+
+	  default:
+	    CPU.exception = SIGILL;
+	    fprintf(stderr,"ERROR: Unknown opcode\n");
+	  }
+	  /* Make R0 consistent */
+	  CPU.regs[0] = 0;
+
+	  /* Check for imm instr */
+	  if (op == imm)
+	    IMM_ENABLE = 1;
+	  else
+	    IMM_ENABLE = 0;
+
+	  /* Update cycle counts */
+	  insts ++;
+	  if (insn_type == memory_store_inst || insn_type == memory_load_inst)
+	    memops++;
+	  if (insn_type == mult_inst)
+	    bonus_cycles++;
+	  if (insn_type == barrel_shift_inst) // added by sathya for barrel shift instructions
+     	    bonus_cycles++;
+	  if (insn_type == anyware_inst) // added by jece
+	    bonus_cycles++;
+	  if (insn_type == div_inst) // added by jece
+	    bonus_cycles += 33;
+
+	  if ((insn_type == branch_inst || insn_type == return_inst) && (branch_taken)) {
+	    /* Add an extra cycle for taken branches */
+	    bonus_cycles++;
+	    /* For branch instructions handle the instruction in the delay slot */
+	    if (delay_slot_enable) {
+	      newpc = PC;
+	      PC = oldpc + INST_SIZE;
+	      inst = rlat (PC & 0xFFFFFFFC);
+	      op = get_insn_microblaze( inst, &imm_unsigned, &insn_type, &num_delay_slot );
+	      if (op == invalid_inst)
+		fprintf (stderr, "Unknown instruction 0x%04x", inst);
+	      if (tracing)
+		fprintf (stderr, "%.4x: inst = %.4x ", PC, inst);
+	      rd = GET_RD;
+	      rb = GET_RB;
+	      ra = GET_RA;
+	      /*	      immword = IMM_W; */
+	      if (op == microblaze_brk) 
+		{
+		  if (issue_messages)
+		    fprintf(stderr, "Breakpoint set in delay slot (at address 0x%x) will not be honored\n", PC);
+		  /* ignore the breakpoint */
+		}
+	      else if (insn_type == branch_inst || insn_type == return_inst) 
+		{
+		  if (issue_messages)
+		    fprintf(stderr, "Cannot have branch or return instructions in delay slot (at address 0x%x)\n", PC);
+		  CPU.exception = SIGILL;
+		}
+	      else
+		{
+		  switch(op){
+#define INSTRUCTION(NAME,OPCODE, TYPE, ACTION)        \
+    case NAME:                                        \
+      ACTION;                                         \
+      break;
+#include "microblaze.isa"
+#undef INSTRUCTION
+		  
+		  default:
+		    CPU.exception = SIGILL;
+		    fprintf(stderr,"ERROR: Unknown opcode at 0x%x\n", PC);
+		  }
+		  /* Update cycle counts */
+		  insts ++;
+		  if (insn_type == memory_store_inst || insn_type == memory_load_inst) {
+		    memops++;
+		  }
+		  if (insn_type == mult_inst)
+		    bonus_cycles++;
+		  if (insn_type == barrel_shift_inst) // added by jece
+		    bonus_cycles++;
+		  if (insn_type == anyware_inst)      // added by jece
+		    bonus_cycles++;
+		  if (insn_type == div_inst)          // added by jece
+		    bonus_cycles += 33;
+		}
+	      /* Restore the PC */
+	      PC = newpc;
+	      /* Make R0 consistent */
+	      CPU.regs[0] = 0;
+	      /* Check for imm instr */
+	      if (op == imm)
+		IMM_ENABLE = 1;
+	      else
+		IMM_ENABLE = 0;
+
+	    } 
+	    else 
+	      {
+		/* no delay slot: increment cycle count */
+		bonus_cycles++;
+	      }
+	  }
+	}
+
+      if (tracing)
+	fprintf (stderr, "\n");
+
+    }
+  while (!CPU.exception);
+
+  /* Hide away the things we've cached while executing.  */
+  /*  CPU.pc = pc; */
+  CPU.insts += insts;		/* instructions done ... */
+  CPU.cycles += insts;		/* and each takes a cycle */
+  CPU.cycles += bonus_cycles;	/* and extra cycles for branches */
+  CPU.cycles += memops; 	/* and memop cycle delays */
+  
+  signal (SIGINT, sigsave);
+}
+
+
+int
+sim_write (sd, addr, buffer, size)
+     SIM_DESC sd;
+     SIM_ADDR addr;
+     unsigned char * buffer;
+     int size;
+{
+  int i;
+  init_pointers ();
+  
+  memcpy (& CPU.memory[addr], buffer, size);
+  
+  return size;
+}
+
+int
+sim_read (sd, addr, buffer, size)
+     SIM_DESC sd;
+     SIM_ADDR addr;
+     unsigned char * buffer;
+     int size;
+{
+  int i;
+  init_pointers ();
+  
+  memcpy (buffer, & CPU.memory[addr], size);
+  
+  return size;
+}
+
+
+int
+sim_store_register (sd, rn, memory, length)
+     SIM_DESC sd;
+     int rn;
+     unsigned char * memory;
+     int length;
+{
+  init_pointers ();
+
+  if (rn < NUM_REGS + NUM_SPECIAL && rn >= 0)
+    {
+      if (length == 4)
+	{
+	  /* misalignment safe */
+	  long ival = microblaze_extract_unsigned_integer (memory, 4);
+	  if (rn < NUM_REGS)
+	    CPU.regs[rn] = ival;
+	  else
+	    CPU.spregs[rn-NUM_REGS] = ival;
+	  return 4;
+	}
+      else
+	return 0;
+    }
+  else
+    return 0;
+}
+
+int
+sim_fetch_register (sd, rn, memory, length)
+     SIM_DESC sd;
+     int rn;
+     unsigned char * memory;
+     int length;
+{
+  long ival;
+  init_pointers ();
+  
+  if (rn < NUM_REGS + NUM_SPECIAL && rn >= 0)
+    {
+      if (length == 4)
+	{
+	  if (rn < NUM_REGS)
+	    ival = CPU.regs[rn];
+	  else
+	    ival = CPU.spregs[rn-NUM_REGS];
+
+	  /* misalignment-safe */
+	  microblaze_store_unsigned_integer (memory, 4, ival);
+	  return 4;
+	}
+      else
+	return 0;
+    }
+  else
+    return 0;
+}
+
+
+int
+sim_trace (sd)
+     SIM_DESC sd;
+{
+  tracing = 1;
+  
+  sim_resume (sd, 0, 0);
+
+  tracing = 0;
+  
+  return 1;
+}
+
+void
+sim_stop_reason (sd, reason, sigrc)
+     SIM_DESC sd;
+     enum sim_stop * reason;
+     int * sigrc;
+{
+  if (CPU.exception == SIGQUIT)
+    {
+      * reason = sim_exited;
+      * sigrc = RETREG;
+    }
+  else
+    {
+      * reason = sim_stopped;
+      * sigrc = CPU.exception;
+    }
+}
+
+
+int
+sim_stop (sd)
+     SIM_DESC sd;
+{
+  CPU.exception = SIGINT;
+  return 1;
+}
+
+
+void
+sim_info (sd, verbose)
+     SIM_DESC sd;
+     int verbose;
+{
+#ifdef WATCHFUNCTIONS
+  int w, wcyc;
+#endif
+
+  callback->printf_filtered (callback, "\n\n# instructions executed  %10d\n",
+			     CPU.insts);
+  callback->printf_filtered (callback, "# cycles                 %10d\n",
+			     (CPU.cycles) ? CPU.cycles+2 : 0);
+
+#ifdef WATCHFUNCTIONS
+  callback->printf_filtered (callback, "\nNumber of watched functions: %d\n",
+			     ENDWL);
+
+  wcyc = 0;
+  
+  for (w = 1; w <= ENDWL; w++)
+    {
+      callback->printf_filtered (callback, "WL = %s %8x\n",WLstr[w],WL[w]);
+      callback->printf_filtered (callback, "  calls = %d, cycles = %d\n",
+				 WLcnts[w],WLcyc[w]);
+      
+      if (WLcnts[w] != 0)
+	callback->printf_filtered (callback,
+				   "  maxcpc = %d, mincpc = %d, avecpc = %d\n",
+				   WLmax[w],WLmin[w],WLcyc[w]/WLcnts[w]);
+      wcyc += WLcyc[w];
+    }
+  
+  callback->printf_filtered (callback,
+			     "Total cycles for watched functions: %d\n",wcyc);
+#endif
+}
+
+struct	aout
+{
+  unsigned char  sa_machtype[2];
+  unsigned char  sa_magic[2];
+  unsigned char  sa_tsize[4];
+  unsigned char  sa_dsize[4];
+  unsigned char  sa_bsize[4];
+  unsigned char  sa_syms[4];
+  unsigned char  sa_entry[4];
+  unsigned char  sa_trelo[4];
+  unsigned char  sa_drelo[4];
+} aout;
+
+#define	LONG(x)		(((x)[0]<<24)|((x)[1]<<16)|((x)[2]<<8)|(x)[3])
+#define	SHORT(x)	(((x)[0]<<8)|(x)[1])
+
+SIM_DESC
+sim_open (kind, cb, abfd, argv)
+     SIM_OPEN_KIND kind;
+     host_callback * cb;
+     struct _bfd * abfd;
+     char ** argv;
+{
+  /*  SIM_DESC sd = sim_state_alloc(kind, alloc);*/
+
+  int osize = sim_memory_size;
+  myname = argv[0];
+  callback = cb;
+  
+  if (kind == SIM_OPEN_STANDALONE)
+    issue_messages = 1;
+  
+  /* Discard and reacquire memory -- start with a clean slate.  */
+  sim_size (1);		/* small */
+  sim_size (osize);	/* and back again */
+
+  set_initial_gprs ();	/* Reset the GPR registers.  */
+  
+  return ((SIM_DESC) 1);
+}
+
+void
+sim_close (sd, quitting)
+     SIM_DESC sd;
+     int quitting;
+{
+  if (CPU.memory) 
+    {
+      free(CPU.memory);
+      CPU.memory = NULL;
+      CPU.msize = 0;
+    }
+}
+
+SIM_RC
+sim_load (sd, prog, abfd, from_tty)
+     SIM_DESC sd;
+     char * prog;
+     bfd * abfd;
+     int from_tty;
+{
+  /* Do the right thing for ELF executables; this turns out to be
+     just about the right thing for any object format that:
+       - we crack using BFD routines
+       - follows the traditional UNIX text/data/bss layout
+       - calls the bss section ".bss".   */
+
+  extern bfd * sim_load_file (); /* ??? Don't know where this should live.  */
+  bfd * prog_bfd;
+
+  {
+    bfd * handle;
+    asection * s;
+    int found_loadable_section = 0;
+    bfd_vma max_addr = 0;
+    handle = bfd_openr (prog, 0);      
+
+    if (!handle)
+      {
+	printf("``%s'' could not be opened.\n", prog);
+	return SIM_RC_FAIL;
+      }
+    
+    /* Makes sure that we have an object file, also cleans gets the 
+       section headers in place.  */
+    if (!bfd_check_format (handle, bfd_object))
+      {
+	/* wasn't an object file */
+	bfd_close (handle);
+	printf ("``%s'' is not appropriate object file.\n", prog);
+	return SIM_RC_FAIL;
+      }
+
+    for (s = handle->sections; s; s = s->next)
+      {
+	if (s->flags & SEC_ALLOC)
+	  {
+	    bfd_vma vma = 0;
+	    int size = bfd_get_section_size_before_reloc (s);
+	    if (size > 0) 
+	      {
+		vma = bfd_section_vma (handle, s);
+		if (vma >= max_addr)
+		  {
+		    max_addr = vma + size;
+		  }
+	      }
+	    if (s->flags & SEC_LOAD)
+	      found_loadable_section = 1;
+	  }
+      }
+
+    if (!found_loadable_section)
+      {
+	/* No loadable sections */
+	bfd_close(handle);
+	printf("No loadable sections in file %s\n", prog);
+	return SIM_RC_FAIL;
+      }
+    
+    sim_memory_size = (unsigned long) max_addr;
+
+    /* Clean up after ourselves.  */
+    bfd_close (handle);
+    
+  }
+
+  /* from sh -- dac */
+  prog_bfd = sim_load_file (sd, myname, callback, prog, abfd,
+                            /* sim_kind == SIM_OPEN_DEBUG, */
+			    1,
+                            0, sim_write);
+  if (prog_bfd == NULL)
+    return SIM_RC_FAIL;
+  
+  target_big_endian = bfd_big_endian (prog_bfd);
+  PC = bfd_get_start_address (prog_bfd);
+    
+  if (abfd == NULL)
+    bfd_close (prog_bfd);
+
+  return SIM_RC_OK;
+}
+
+SIM_RC
+sim_create_inferior (sd, prog_bfd, argv, env)
+     SIM_DESC sd;
+     struct _bfd * prog_bfd;
+     char ** argv;
+     char ** env;
+{
+  char ** avp;
+  int nargs = 0;
+  int nenv = 0;
+  int s_length;
+  int l;
+  unsigned long strings;
+  unsigned long pointers;
+  unsigned long hi_stack;
+
+
+  /* Set the initial register set.  */
+  l = issue_messages;
+  issue_messages = 0;
+  set_initial_gprs ();
+  issue_messages = l;
+  
+  hi_stack = CPU.msize - 4;
+  PC = bfd_get_start_address(prog_bfd);
+
+  /* For now ignore all parameters to the program */
+  
+  return SIM_RC_OK;
+}
+
+void
+sim_kill (sd)
+     SIM_DESC sd;
+{
+  /* nothing to do */
+}
+
+void
+sim_do_command (sd, cmd)
+     SIM_DESC sd;
+     char * cmd;
+{
+  /* Nothing there yet; it's all an error.  */
+  
+  if (cmd != NULL)
+    {
+      char ** simargv = buildargv (cmd);
+      
+      if (strcmp (simargv[0], "watch") == 0)
+	{
+	  if ((simargv[1] == NULL) || (simargv[2] == NULL))
+	    {
+	      fprintf (stderr, "Error: missing argument to watch cmd.\n");
+	      return;
+	    }
+	  
+	  ENDWL++;
+	  
+	  WL[ENDWL] = strtol (simargv[2], NULL, 0);
+	  WLstr[ENDWL] = strdup (simargv[1]);
+	  fprintf (stderr, "Added %s (%x) to watchlist, #%d\n",WLstr[ENDWL],
+		   WL[ENDWL], ENDWL);
+
+	}
+      else if (strcmp (simargv[0], "dumpmem") == 0)
+	{
+	  unsigned char * p;
+	  FILE * dumpfile;
+
+	  if (simargv[1] == NULL)
+	    fprintf (stderr, "Error: missing argument to dumpmem cmd.\n");
+
+	  fprintf (stderr, "Writing dumpfile %s...",simargv[1]);
+	  
+	  dumpfile = fopen (simargv[1], "w");
+	  p = CPU.memory;
+	  fwrite (p, CPU.msize-1, 1, dumpfile);
+	  fclose (dumpfile);
+	  
+	  fprintf (stderr, "done.\n");
+	}
+      else if (strcmp (simargv[0], "clearstats") == 0)
+	{
+	  CPU.cycles = 0;
+	  CPU.insts = 0;
+	  ENDWL = 0;
+	}
+      else if (strcmp (simargv[0], "verbose") == 0)
+	{
+	  issue_messages = 2;
+	}
+      else
+	{
+	  fprintf (stderr,"Error: \"%s\" is not a valid M.CORE simulator command.\n",
+		   cmd);
+	}
+    }
+  else
+    {
+      fprintf (stderr, "M.CORE sim commands: \n");
+      fprintf (stderr, "  watch <funcname> <addr>\n");
+      fprintf (stderr, "  dumpmem <filename>\n");
+      fprintf (stderr, "  clearstats\n");
+      fprintf (stderr, "  verbose\n");
+    }
+}
+
+void
+sim_set_callbacks (ptr)
+     host_callback * ptr;
+{
+  callback = ptr; 
+}
diff --git a/sim/microblaze/microblaze.h b/sim/microblaze/microblaze.h
new file mode 100644
index 0000000..5e12f42
--- /dev/null
+++ b/sim/microblaze/microblaze.h
@@ -0,0 +1,108 @@
+#ifndef MICROBLAZE_H
+#define MICROBLAZE_H
+
+/*
+ * Copyright (c) 2001 Xilinx, Inc.  All rights reserved. 
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by Xilinx, Inc.  The name of the Company may not be used to endorse 
+ * or promote products derived from this software without specific prior 
+ * written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ *	Xilinx, Inc.
+ * $Header:
+ */
+#include "../../opcodes/microblaze-opcm.h"
+
+#define GET_RD	((inst & RD_MASK) >> RD_LOW)
+#define GET_RA	((inst & RA_MASK) >> RA_LOW)
+#define GET_RB	((inst & RB_MASK) >> RB_LOW)
+
+#define CPU     microblaze_state.cpu[0].microblaze_cpu
+
+#define RD      CPU.regs[rd]
+#define RA      CPU.regs[ra]
+#define RB      CPU.regs[rb]
+/* #define IMM     immword */
+
+#define SA	CPU.spregs[IMM & 0x1]
+
+#define IMM_H	CPU.imm_high
+#define IMM_L	((inst & IMM_MASK) >> IMM_LOW)
+
+#define IMM_ENABLE CPU.imm_enable
+
+#define IMM             (IMM_ENABLE ?					\
+                         (((uhalf)IMM_H << 16) | (uhalf)IMM_L) :	\
+                         (imm_unsigned ?				\
+			  (0xFFFF & IMM_L) :				\
+                          (IMM_L & 0x8000 ?                             \
+			   (0xFFFF0000 | IMM_L) :                       \
+			   (0x0000FFFF & IMM_L))))
+
+#define PC	CPU.spregs[0]
+#define	MSR	CPU.spregs[1]
+#define SP      CPU.regs[29]
+#define RETREG  CPU.regs[1]
+
+
+#define MEM(X)	memory[X]
+
+#define MEM_RD_BYTE(X)	rbat(X)
+#define MEM_RD_HALF(X)	rhat(X)
+#define MEM_RD_WORD(X)	rlat(X)
+#define MEM_RD_UBYTE(X) (ubyte)MEM_RD_BYTE(X)
+#define MEM_RD_UHALF(X) (uhalf)MEM_RD_HALF(X) 
+#define MEM_RD_UWORD(X) (uword)MEM_RD_WORD(X) 
+
+#define MEM_WR_BYTE(X,D) wbat(X, D)
+#define MEM_WR_HALF(X,D) what(X, D)
+#define MEM_WR_WORD(X,D) wlat(X, D)
+
+
+#define MICROBLAZE_SEXT8(X)	((char) X)
+#define MICROBLAZE_SEXT16(X)	((short) X)
+
+
+#define CARRY		carry
+#define C_rd		((MSR & 0x4) >> 2)
+#define C_wr(D)		MSR = (D ? MSR | 0x80000004 : MSR & 0x7FFFFFFB)
+//#define OVF		overflow
+//#define O_rd		(MSR & 0x2)
+//#define O_wr(D)		MSR = (D ? MSR | 0x2 : MSR & 0xFFFD)
+
+#define C_calc(X,Y,C)	((((uword)Y == MAX_WORD) && (C == 1)) ?		 \
+			 1 :						 \
+			 ((MAX_WORD - (uword)X) < ((uword)Y + C)))
+
+#define BIP_MASK	0x00000008
+#define CARRY_MASK	0x00000004
+#define INTR_EN_MASK	0x00000002
+#define BUSLOCK_MASK	0x00000001
+
+#define DELAY_SLOT      delay_slot_enable = 1
+#define BRANCH          branch_taken = 1
+
+#define NUM_REGS 	32
+#define NUM_SPECIAL 	2
+#define INST_SIZE 	4
+
+#define MAX_WORD	0xFFFFFFFF
+#define MICROBLAZE_HALT_INST  0xb8000000
+
+typedef char		byte;
+typedef short		half;
+typedef int		word;
+typedef unsigned char	ubyte;
+typedef unsigned short	uhalf;
+typedef unsigned int	uword;
+
+#endif /* MICROBLAZE_H */
+
diff --git a/sim/microblaze/microblaze.isa b/sim/microblaze/microblaze.isa
new file mode 100644
index 0000000..a906a7c
--- /dev/null
+++ b/sim/microblaze/microblaze.isa
@@ -0,0 +1,826 @@
+/*
+ * Copyright (c) 2001 Xilinx, Inc.  All rights reserved. 
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by Xilinx, Inc.  The name of the Company may not be used to endorse 
+ * or promote products derived from this software without specific prior 
+ * written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ *	Xilinx, Inc.
+ * $Header:
+ */
+
+/*
+ *  MICROBLAZE Instruction Set Architecture
+ *
+ *  INSTRUCTION(NAME,
+ *              OPCODE,
+ *              TYPE,
+ *              SEMANTICS)
+ *
+ */
+
+INSTRUCTION(add,
+	    0x00,
+	    INST_TYPE_RD_RA_RB,
+	    CARRY = C_calc(RA, RB, 0); 
+	    RD = RA + RB;
+	    C_wr(CARRY);
+	    PC += INST_SIZE)
+
+INSTRUCTION(rsub,
+	    0x01,
+            INST_TYPE_RD_RA_RB, 
+	    CARRY = C_calc(RB, ~RA, 1);
+	    RD = RB + ~RA + 1;
+            C_wr(CARRY);
+	    PC += INST_SIZE)
+
+INSTRUCTION(addc,
+	    0x02,
+            INST_TYPE_RD_RA_RB, 
+	    CARRY = C_calc(RA, RB, C_rd);
+	    RD = RA + RB + C_rd;
+	    C_wr(CARRY);
+	    PC += INST_SIZE)
+
+INSTRUCTION(rsubc,
+	    0x03,
+            INST_TYPE_RD_RA_RB, 
+	    CARRY = C_calc(RB, ~RA, C_rd);
+	    RD = RB + ~RA + C_rd;
+            C_wr(CARRY); 
+	    PC += INST_SIZE)
+
+INSTRUCTION(addk,
+	    0x04,
+            INST_TYPE_RD_RA_RB, 
+	    RD = RA + RB;
+	    PC += INST_SIZE)
+
+INSTRUCTION(rsubk,
+	    0x05,
+            INST_TYPE_RD_RA_RB, 
+	    RD = RB + ~RA + 1;
+	    PC += INST_SIZE)
+
+INSTRUCTION(cmp,
+            0x05,
+            INST_TYPE_RD_RA_RB,
+            {
+	      int tmp_reg = RB + ~RA + 1;
+	      if ((RB & 0x80000000) ^ (RA & 0x80000000)) {
+		tmp_reg = ((tmp_reg & 0x7fffffff) | (RB & 0x80000000));
+	      }
+	      RD = tmp_reg;
+	      PC += INST_SIZE;
+	    })
+
+INSTRUCTION(cmpu,
+            0x05,
+            INST_TYPE_RD_RA_RB,
+            {
+	      int tmp_reg = RB + ~RA + 1;
+	      if ((RB & 0x80000000) ^ (RA & 0x80000000)) {
+		tmp_reg = ((tmp_reg & 0x7fffffff) | (RA & 0x80000000));
+	      }
+	      RD = tmp_reg;
+	      PC += INST_SIZE;
+	    })
+
+INSTRUCTION(addkc,
+	    0x06,
+            INST_TYPE_RD_RA_RB, 
+	    RD = RA + RB + C_rd;
+	    PC += INST_SIZE)
+
+INSTRUCTION(rsubkc,
+	    0x07,
+            INST_TYPE_RD_RA_RB, 
+	    RD = RB + ~RA + C_rd; 
+	    PC += INST_SIZE)	
+
+INSTRUCTION(addi,
+	    0x08,
+	    INST_TYPE_RD_RA_IMM, 
+            CARRY = C_calc(RA, IMM, 0); 
+	    RD = RA + IMM;
+	    C_wr(CARRY); 
+	    PC += INST_SIZE) 
+
+INSTRUCTION(rsubi,
+	    0x09,
+	    INST_TYPE_RD_RA_IMM,
+            CARRY = C_calc(IMM, ~RA, 1); 
+	    RD = IMM + ~RA + 1; 
+            C_wr(CARRY); 
+	    PC += INST_SIZE)
+
+INSTRUCTION(addic,
+	    0x0A,
+            INST_TYPE_RD_RA_IMM, 
+            CARRY = C_calc(RA, IMM, C_rd);  
+	    RD = RA + IMM + C_rd;
+            C_wr(CARRY); 
+	    PC += INST_SIZE)
+
+INSTRUCTION(rsubic,
+	    0x0B,
+            INST_TYPE_RD_RA_IMM, 
+            CARRY = C_calc(IMM, ~RA, C_rd);
+	    RD = IMM + ~RA + C_rd; 
+            C_wr(CARRY); 
+	    PC += INST_SIZE)
+
+INSTRUCTION(addik,
+	    0x0C,
+            INST_TYPE_RD_RA_IMM, 
+	    RD = RA + IMM;
+	    PC += INST_SIZE) 
+
+INSTRUCTION(rsubik,
+	    0x0D,
+            INST_TYPE_RD_RA_IMM, 
+	    RD = IMM + ~RA + 1; 
+	    PC += INST_SIZE)
+
+INSTRUCTION(addikc,
+	    0x0E,
+            INST_TYPE_RD_RA_IMM, 
+	    RD = RA + IMM + C_rd;
+	    PC += INST_SIZE)
+
+INSTRUCTION(rsubikc,
+	    0x0F,
+            INST_TYPE_RD_RA_IMM, 
+            RD = IMM + ~RA + C_rd;  
+	    PC += INST_SIZE)
+
+INSTRUCTION(mul,
+	    0x10,
+            INST_TYPE_RD_RA_RB, 
+	    RD = RA * RB;
+	    PC += INST_SIZE)
+     
+INSTRUCTION(bsrl,
+	    0x11,
+	    INST_TYPE_RD_RA_RB,
+	    RD = (uword)RA >> RB;
+	    PC += INST_SIZE)
+     
+INSTRUCTION(bsra,
+	    0x11,
+	    INST_TYPE_RD_RA_RB,
+	    RD = (word)RA >> RB;      
+	    PC += INST_SIZE)
+
+INSTRUCTION(bsll,
+	    0x11,
+	    INST_TYPE_RD_RA_RB,
+	    RD = (uword)RA << RB;
+	    PC += INST_SIZE)	 
+
+INSTRUCTION(idiv,
+	    0x12,
+	    INST_TYPE_RD_RA_RB,
+	    RD = (word) RB / (word) RA;
+	    PC += INST_SIZE)
+
+INSTRUCTION(idivu,
+	    0x12,
+	    INST_TYPE_RD_RA_RB,
+	    RD = (uword) RB / (uword) RA;
+	    PC += INST_SIZE) 
+
+INSTRUCTION(muli,
+	    0x18,
+            INST_TYPE_RD_RA_IMM, 
+	    RD = RA * IMM;
+	    PC += INST_SIZE) 
+
+INSTRUCTION(bsrli,
+	    0x19,
+	    INST_TYPE_RD_RA_IMM5,
+	    RD = (uword)RA >> (IMM & 0x1F);
+	    PC += INST_SIZE)	
+
+INSTRUCTION(bsrai,
+	    0x19,
+	    INST_TYPE_RD_RA_IMM5,
+	    RD = (word)RA >> (IMM & 0x1F);
+	    PC += INST_SIZE)	
+
+INSTRUCTION(bslli,
+	    0x19,
+	    INST_TYPE_RD_RA_IMM5,
+	    RD = (uword)RA << (IMM & 0x1F);
+	    PC += INST_SIZE)
+
+INSTRUCTION(get,
+            0x1b,
+            INST_TYPE_RD_IMM12,
+            PC += INST_SIZE )
+
+INSTRUCTION(put,
+            0x1b,
+            INST_TYPE_R1_IMM12,
+            PC += INST_SIZE )
+
+INSTRUCTION(nget,
+            0x1b,
+            INST_TYPE_RD_IMM12,
+            PC += INST_SIZE )
+
+INSTRUCTION(nput,
+            0x1b,
+            INST_TYPE_R1_IMM12,
+            PC += INST_SIZE )
+
+INSTRUCTION(cget,
+            0x1b,
+            INST_TYPE_RD_IMM12,
+            PC += INST_SIZE )
+
+INSTRUCTION(cput,
+            0x1b,
+            INST_TYPE_R1_IMM12,
+            PC += INST_SIZE )
+
+INSTRUCTION(ncget,
+            0x1b,
+            INST_TYPE_RD_IMM12,
+            PC += INST_SIZE )
+
+INSTRUCTION(ncput,
+            0x1b,
+            INST_TYPE_R1_IMM12,
+            PC += INST_SIZE )    
+
+INSTRUCTION(or,
+	    0x20,
+            INST_TYPE_RD_RA_RB, 
+	    RD = RA | RB;
+	    PC += INST_SIZE)
+
+INSTRUCTION(and,
+	    0x21,
+            INST_TYPE_RD_RA_RB, 
+	    RD = RA & RB;
+	    PC += INST_SIZE) 
+
+INSTRUCTION(xor,
+	    0x22,
+            INST_TYPE_RD_RA_RB, 
+	    RD = RA ^ RB;
+	    PC += INST_SIZE)
+
+INSTRUCTION(andn,
+	    0x23,
+            INST_TYPE_RD_RA_RB, 
+	    RD = RA & ~RB;
+	    PC += INST_SIZE)
+
+INSTRUCTION(sra,
+	    0x24,
+	    INST_TYPE_RD_RA,
+	    CARRY = (RA & 0x1);
+	    RD = (int) (RA >> 1);
+	    C_wr(CARRY);
+	    PC += INST_SIZE)
+
+INSTRUCTION(src,
+	    0x24,
+            INST_TYPE_RD_RA, 
+	    CARRY = (RA & 0x1);
+            RD = ((((int) (RA >> 1)) & 0x7FFFFFFF) | (uword)(C_rd << 31));
+            C_wr(CARRY); 
+	    PC += INST_SIZE) 
+
+INSTRUCTION(srl,
+	    0x24,
+            INST_TYPE_RD_RA,
+            CARRY = (RA & 0x1); 
+	    RD = (uword) ((RA >> 1) & 0x7FFFFFFF);
+            C_wr(CARRY); 
+	    PC += INST_SIZE) 
+
+INSTRUCTION(sext8,
+	    0x24,
+            INST_TYPE_RD_RA,
+	    RD = MICROBLAZE_SEXT8(RA);
+	    PC += INST_SIZE)
+
+INSTRUCTION(sext16,
+            0x24,
+            INST_TYPE_RD_RA, 
+	    RD = MICROBLAZE_SEXT16(RA);
+            PC += INST_SIZE) 
+
+INSTRUCTION(wdc,
+            0x24,
+            INST_TYPE_RA_RB,
+            PC += INST_SIZE)
+
+INSTRUCTION(wic,
+            0x24,
+            INST_TYPE_RA_RB,
+            PC += INST_SIZE)  
+
+INSTRUCTION(mts,
+	    0x25,
+	    INST_TYPE_SA_RA, 
+	    SA = RA;
+	    PC += INST_SIZE) 
+
+INSTRUCTION(mfs,
+	    0x25,
+            INST_TYPE_RD_SA, 
+	    RD = SA;
+	    PC += INST_SIZE) 
+
+INSTRUCTION(br,
+	    0x26,
+	    INST_TYPE_RB,
+	    PC += RB;
+	    BRANCH)
+
+INSTRUCTION(brd,
+            0x26,
+            INST_TYPE_RB,
+            PC += RB;
+	    BRANCH;
+            DELAY_SLOT)  
+
+INSTRUCTION(brld,
+	    0x26,
+	    INST_TYPE_RD_RB,
+	    RD = PC;
+	    PC += RB;
+	    BRANCH;
+	    DELAY_SLOT) 
+
+INSTRUCTION(bra,
+	    0x26,
+            INST_TYPE_RB, 
+	    PC = RB;
+	    BRANCH)
+
+INSTRUCTION(brad,
+            0x26,
+            INST_TYPE_RB,
+            PC = RB;
+	    BRANCH;
+            DELAY_SLOT)   
+
+INSTRUCTION(brald,
+	    0x26,
+            INST_TYPE_RD_RB, 
+	    RD = PC;
+	    PC = RB;
+	    BRANCH;
+	    DELAY_SLOT) 
+
+INSTRUCTION(microblaze_brk,
+	    0x26,
+            INST_TYPE_RD_RB, 
+	    RD = PC;
+	    PC = RB;
+            MSR = MSR | BIP_MASK;
+	    BRANCH)
+
+INSTRUCTION(beq,
+	    0x27,
+            INST_TYPE_RA_RB, 
+	    if (RA == 0) {
+	      PC += RB;
+	      BRANCH;
+            } else {
+	      PC += INST_SIZE;
+	    }) 
+
+INSTRUCTION(beqd,
+            0x27,
+            INST_TYPE_RA_RB, 
+            if (RA == 0) {
+	      PC += RB;
+	      BRANCH;
+	    } else {
+	      PC += INST_SIZE;
+	    }
+	    DELAY_SLOT) 
+
+INSTRUCTION(bne,
+	    0x27,
+            INST_TYPE_RA_RB, 
+	    if (RA != 0) {
+	      PC += RB;
+	      BRANCH;
+	    } else {
+	      PC += INST_SIZE;
+	    }) 
+
+INSTRUCTION(bned,
+            0x27,
+            INST_TYPE_RA_RB, 
+            if (RA != 0) {
+	      PC += RB;
+	      BRANCH;
+	    } else {
+	      PC += INST_SIZE;
+	    }
+	    DELAY_SLOT)  
+
+INSTRUCTION(blt,
+	    0x27,
+            INST_TYPE_RA_RB, 
+	    if (RA < 0) {
+	      PC += RB;
+	      BRANCH;
+	    } else {
+	      PC += INST_SIZE;
+	    }) 
+
+INSTRUCTION(bltd,
+            0x27,
+            INST_TYPE_RA_RB, 
+            if (RA < 0) {
+	      PC += RB;
+	      BRANCH;
+	    } else {
+	      PC += INST_SIZE;
+	    }
+	    DELAY_SLOT)  
+
+INSTRUCTION(ble,
+	    0x27,
+            INST_TYPE_RA_RB, 
+	    if (RA <= 0) {
+	      PC += RB;
+	      BRANCH;
+	    } else {
+	      PC += INST_SIZE;
+	    }) 
+
+INSTRUCTION(bled,
+            0x27,
+            INST_TYPE_RA_RB, 
+            if (RA <= 0) {
+	      PC += RB;
+	      BRANCH;
+	    } else {
+	      PC += INST_SIZE;
+	    }
+	    DELAY_SLOT)
+
+INSTRUCTION(bgt,
+	    0x27,
+            INST_TYPE_RA_RB, 
+	    if (RA > 0) {
+	      PC += RB;
+	      BRANCH;
+	    } else {
+	      PC += INST_SIZE;
+	    })
+
+INSTRUCTION(bgtd,
+            0x27,
+            INST_TYPE_RA_RB, 
+            if (RA > 0) {
+	      PC += RB;
+	      BRANCH;
+	    } else {
+	      PC += INST_SIZE;
+	    }
+	    DELAY_SLOT)  
+
+INSTRUCTION(bge,
+	    0x27,
+            INST_TYPE_RA_RB, 
+	    if (RA >= 0) {
+	      PC += RB;
+	      BRANCH;
+	    } else {
+	      PC += INST_SIZE;
+	    }) 
+
+INSTRUCTION(bged,
+            0x27,
+            INST_TYPE_RA_RB, 
+            if (RA >= 0) {
+	      PC += RB;
+	      BRANCH;
+	    } else {
+	      PC += INST_SIZE;
+	    }
+	    DELAY_SLOT) 
+
+INSTRUCTION(ori,
+	    0x28,
+            INST_TYPE_RD_RA_IMM, 
+	    RD = RA | IMM;
+	    PC += INST_SIZE) 
+
+INSTRUCTION(andi,
+	    0x29,
+            INST_TYPE_RD_RA_IMM, 
+	    RD = RA & IMM;
+	    PC += INST_SIZE)
+
+INSTRUCTION(xori,
+	    0x2A,
+            INST_TYPE_RD_RA_IMM, 
+	    RD = RA ^ IMM;
+	    PC += INST_SIZE)
+
+INSTRUCTION(andni,
+	    0x2B,
+            INST_TYPE_RD_RA_IMM, 
+	    RD = RA & ~IMM;
+	    PC += INST_SIZE)
+
+INSTRUCTION(imm,
+	    0x2C,
+	    INST_TYPE_IMM, 
+	    IMM_H = IMM_L;
+	    PC += INST_SIZE) 
+
+INSTRUCTION(rtsd,
+	    0x2D,
+            INST_TYPE_RA_IMM, 
+	    PC = RA + IMM;
+    	    BRANCH;
+	    DELAY_SLOT)
+
+INSTRUCTION(rtid,
+	    0x2D,
+            INST_TYPE_RA_IMM, 
+	    PC = RA + IMM;
+	    MSR = MSR | INTR_EN_MASK;
+	    BRANCH;
+	    DELAY_SLOT) 
+
+INSTRUCTION(rtbd,
+	    0x2D,
+	    INST_TYPE_RA_IMM,
+	    PC = RA + IMM;
+	    MSR = MSR & ~BIP_MASK;
+	    BRANCH;
+            DELAY_SLOT;)
+
+INSTRUCTION(bri,
+	    0x2E,
+            INST_TYPE_IMM, 
+	    PC += IMM;
+	    BRANCH)
+
+INSTRUCTION(brid,
+            0x2E,
+            INST_TYPE_IMM,
+            PC += IMM;
+	    BRANCH;
+            DELAY_SLOT) 
+
+INSTRUCTION(brlid,
+	    0x2E,
+            INST_TYPE_RD_IMM, 
+	    RD = PC;
+	    PC += IMM;
+	    BRANCH;
+	    DELAY_SLOT)
+
+INSTRUCTION(brai,
+	    0x2E,
+            INST_TYPE_IMM, 
+	    PC = IMM;
+	    BRANCH)
+
+INSTRUCTION(braid,
+            0x2E,
+            INST_TYPE_IMM,
+            PC = IMM;
+	    BRANCH;
+            DELAY_SLOT)  
+
+INSTRUCTION(bralid,
+	    0x2E,
+	    INST_TYPE_RD_IMM, 
+	    RD = PC;
+	    PC = IMM;
+	    BRANCH;
+	    DELAY_SLOT)
+
+INSTRUCTION(brki,
+	    0x2E,
+            INST_TYPE_RD_IMM, 
+	    RD = PC;
+	    PC = IMM;
+            MSR = MSR | BIP_MASK;
+	    BRANCH)
+
+INSTRUCTION(beqi,
+	    0x2F,
+            INST_TYPE_RA_IMM, 
+	    if (RA == 0) {
+	      PC += IMM;
+	      BRANCH;
+	    } else {
+	      PC += INST_SIZE;
+	    })
+
+INSTRUCTION(beqid,
+            0x2F,
+            INST_TYPE_RA_IMM, 
+            if (RA == 0) {
+	      PC += IMM;
+	      BRANCH;
+	    } else {
+	      PC += INST_SIZE;
+	    }
+	    DELAY_SLOT) 
+
+INSTRUCTION(bnei,
+	    0x2F,
+            INST_TYPE_RA_IMM, 
+	    if (RA != 0) {
+	      PC += IMM;
+	      BRANCH;
+	    } else {
+	      PC += INST_SIZE;
+	    })
+
+INSTRUCTION(bneid,
+            0x2F,
+            INST_TYPE_RA_IMM, 
+            if (RA != 0) {
+	      PC += IMM;
+	      BRANCH;
+	    } else {
+	      PC += INST_SIZE;
+	    }
+	    DELAY_SLOT) 
+
+INSTRUCTION(blti,
+	    0x2F,
+            INST_TYPE_RA_IMM, 
+	    if (RA < 0) {
+	      PC += IMM;
+	      BRANCH;
+	    } else {
+	      PC += INST_SIZE;
+	    })
+
+INSTRUCTION(bltid,
+            0x2F,
+            INST_TYPE_RA_IMM, 
+            if (RA < 0) {
+	      PC += IMM;
+	      BRANCH;
+	    } else {
+	      PC += INST_SIZE;
+	    }
+	    DELAY_SLOT) 
+
+INSTRUCTION(blei,
+	    0x2F,
+            INST_TYPE_RA_IMM, 
+	    if (RA <= 0) {
+	      PC += IMM;
+	      BRANCH;
+	    } else {
+	      PC += INST_SIZE;
+	    })
+
+INSTRUCTION(bleid,
+            0x2F,
+            INST_TYPE_RA_IMM, 
+            if (RA <= 0) {
+	      PC += IMM;
+	      BRANCH;
+	    } else {
+	      PC += INST_SIZE;
+	    }
+	    DELAY_SLOT)  
+
+INSTRUCTION(bgti,
+	    0x2F,
+            INST_TYPE_RA_IMM, 
+	    if (RA > 0) {
+	      PC += IMM;
+	      BRANCH;
+	    } else {
+	      PC += INST_SIZE;
+	    })
+
+INSTRUCTION(bgtid,
+            0x2F,
+            INST_TYPE_RA_IMM, 
+            if (RA > 0) {
+	      PC += IMM;
+	      BRANCH;
+	    } else {
+	      PC += INST_SIZE;
+	    }
+	    DELAY_SLOT)  
+
+INSTRUCTION(bgei,
+	    0x2F,
+            INST_TYPE_RA_IMM, 
+	    if (RA >= 0) {
+	      PC += IMM;
+	      BRANCH;
+	    } else {
+	      PC += INST_SIZE;
+	    })
+
+INSTRUCTION(bgeid,
+            0x2F,
+            INST_TYPE_RA_IMM, 
+            if (RA >= 0) {
+	      PC += IMM;
+	      BRANCH;
+	    } else {
+	      PC += INST_SIZE;
+	    }
+	    DELAY_SLOT) 
+
+INSTRUCTION(lbu,
+	    0x30,
+            INST_TYPE_RD_RA_RB, 
+	    RD = (MEM_RD_UBYTE(RA + RB));
+	    PC += INST_SIZE)
+
+INSTRUCTION(lhu,
+	    0x31,
+	    INST_TYPE_RD_RA_RB, 
+	    RD = (MEM_RD_UHALF((RA + RB) & ~0x1));
+	    PC += INST_SIZE)
+
+INSTRUCTION(lw,
+	    0x32,
+            INST_TYPE_RD_RA_RB, 
+	    RD = (MEM_RD_WORD((RA + RB) & ~0x3));
+	    PC += INST_SIZE)
+
+INSTRUCTION(sb,
+	    0x34,
+            INST_TYPE_RD_RA_RB, 
+	    MEM_WR_BYTE(RA + RB, RD); 
+	    PC += INST_SIZE)
+
+INSTRUCTION(sh,
+	    0x35,
+            INST_TYPE_RD_RA_RB, 
+	    MEM_WR_HALF((RA + RB) & ~0x1, RD);
+	    PC += INST_SIZE)
+
+INSTRUCTION(sw,
+	    0x36,
+            INST_TYPE_RD_RA_RB, 
+	    MEM_WR_WORD((RA + RB) & ~0x3, RD);
+	    PC += INST_SIZE) 
+
+INSTRUCTION(lbui,
+	    0x38,
+            INST_TYPE_RD_RA_IMM, 
+	    RD = (MEM_RD_UBYTE(RA + IMM));
+	    PC += INST_SIZE) 
+
+INSTRUCTION(lhui,
+	    0x39,
+            INST_TYPE_RD_RA_IMM, 
+	    RD = (MEM_RD_UHALF((RA+IMM) & ~0x1));
+	    PC += INST_SIZE) 
+
+INSTRUCTION(lwi,
+	    0x3A,
+            INST_TYPE_RD_RA_IMM, 
+	    RD = (MEM_RD_WORD((RA+IMM) & ~0x3));
+	    PC += INST_SIZE) 
+
+INSTRUCTION(sbi,
+	    0x3C,
+            INST_TYPE_RD_RA_IMM, 
+	    MEM_WR_BYTE(RA + IMM, RD);
+	    PC += INST_SIZE) 
+
+INSTRUCTION(shi,
+	    0x3D,
+            INST_TYPE_RD_RA_IMM, 
+	    MEM_WR_HALF((RA + IMM) & ~0x1, RD);
+	    PC += INST_SIZE) 
+
+INSTRUCTION(swi,
+	    0x3E,
+            INST_TYPE_RD_RA_IMM, 
+	    MEM_WR_WORD((RA + IMM) & ~0x3, RD);
+	    PC += INST_SIZE) 
+
+
+
diff --git a/sim/microblaze/sim-main.h b/sim/microblaze/sim-main.h
new file mode 100644
index 0000000..49982d5
--- /dev/null
+++ b/sim/microblaze/sim-main.h
@@ -0,0 +1,64 @@
+#ifndef MICROBLAZE_SIM_MAIN
+#define MICROBLAZE_SIM_MAIN
+
+/*
+ * Copyright (c) 2001 Xilinx, Inc.  All rights reserved. 
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by Xilinx, Inc.  The name of the Company may not be used to endorse 
+ * or promote products derived from this software without specific prior 
+ * written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ *	Xilinx, Inc.
+ * $Header:
+ */
+
+#include "microblaze.h"
+#include "sim-basics.h"
+typedef address_word sim_cia;
+#include "sim-base.h"
+
+/* The machine state.
+   This state is maintained in host byte order.  The 
+   fetch/store register functions must translate between host
+   byte order and the target processor byte order.  
+   Keeping this data in target byte order simplifies the register
+   read/write functions.  Keeping this data in native order improves
+   the performance of the simulator.  Simulation speed is deemed more
+   important.  */
+
+/* The ordering of the microblaze_regset structure is matched in the
+   gdb/config/microblaze/tm-microblaze.h file in the REGISTER_NAMES macro.  */
+ struct microblaze_regset
+{
+  word	          regs [32];		/* primary registers */
+  word	          spregs [2];		/* pc + msr */
+  int		  cycles;
+  int		  insts;
+  int		  exception;
+  unsigned long   msize;
+  unsigned char * memory;
+  ubyte           imm_enable;
+  half            imm_high;
+};
+
+struct _sim_cpu {
+  struct microblaze_regset microblaze_cpu;
+  sim_cpu_base base;
+};
+
+#define MAX_NR_PROCESSORS 1
+struct sim_state {
+  sim_cpu cpu[MAX_NR_PROCESSORS];
+#define STATE_CPU(sd,n) (&(sd)->cpu[0])
+  sim_state_base base;
+};
+#endif /* MICROBLAZE_SIM_MAIN */
+
diff --git a/sim/microblaze/sysdep.h b/sim/microblaze/sysdep.h
new file mode 100644
index 0000000..7dabc92
--- /dev/null
+++ b/sim/microblaze/sysdep.h
@@ -0,0 +1,113 @@
+/* System includes and definitions used by the Xilinx MicroBlaze simulator.
+   Copyright (C) 1999 Free Software Foundation, Inc.
+   Contributed by Cygnus Solutions.
+
+This file is part of GDB, the GNU debugger.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along
+with this program; if not, write to the Free Software Foundation, Inc.,
+59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/*
+ * Copyright (c) 2001 Xilinx, Inc.  All rights reserved. 
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by Xilinx, Inc.  The name of the Company may not be used to endorse 
+ * or promote products derived from this software without specific prior 
+ * written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ *	Xilinx, Inc.
+ */
+
+#ifndef __SYSDEP_H
+#define __SYSDEP_H
+
+#ifndef	hosts_std_host_H
+#include <fcntl.h>
+#include <errno.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <ctype.h>
+#include <string.h>
+#include <sys/file.h>
+#include "ansidecl.h"
+
+#ifndef	O_ACCMODE
+#define O_ACCMODE (O_RDONLY | O_WRONLY | O_RDWR)
+#endif
+#ifndef	SEEK_SET
+#define SEEK_SET 0
+#endif
+#ifndef	SEEK_CUR
+#define SEEK_CUR 1
+#endif
+#ifdef STDC_HEADERS
+#include <stdlib.h>
+/*#include <string.h>*/
+#else
+extern char * mktemp ();
+#ifndef memset
+extern PTR    memset ();
+#endif
+
+#ifndef	DONTDECLARE_MALLOC
+extern PTR   malloc ();
+extern PTR   realloc ();
+#endif
+
+#ifndef	__GNUC__
+extern PTR   memcpy ();
+#else
+/* char * memcpy (); */
+#endif
+
+#ifdef __STDC__
+extern void free ();
+#else
+extern int free();
+#endif
+
+#ifndef strchr
+extern char * strchr();
+#endif
+extern char * getenv();
+extern PTR    memchr();
+extern char * strrchr();
+
+extern char * strrchr();
+extern char * ctime();
+extern long   atol();
+extern char * getenv();
+#endif /* STDC_HEADERS */
+
+#ifndef	BYTES_IN_PRINTF_INT
+#define BYTES_IN_PRINTF_INT 4
+#endif
+
+#include "fopen-same.h"
+#define hosts_std_host_H
+#endif
+
+#ifdef	STDC_HEADERS
+#include <stddef.h>
+#endif /* STDC_HEADERS */
+
+#endif /* __SYSDEP_H */
-- 
1.7.0.4

